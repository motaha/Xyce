<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE admst PUBLIC "-//adms//DTD admst 2.0//-" "http://mot-adms.sourceforge.net/xml-files/adms/admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

  <!--
  Filename:   $RCSfile: xyceBasicTemplates.xml,v $
  Purpose:  Provide a basic set of ADMST templates for working on Xyce
            modules
      Creator:   Tom Russo, SNL, Electrical and Microsystems Modeling
      Creation Date: 8 May 2008

        Revision Information:
        ====================-

        Revision Number: $Revision: 1.94.2.1 $
        Revision Date:   $Date: 2014/02/27 17:23:09 $
        Current Owner:   $Author: tvrusso $

   =================================================================-
   =================================================================-
    simple templates for producing commonly-used information
   =================================================================-
   =================================================================-
  -->

  <!--
   =================================================================-
   xyceNumberNodes
    return the number of nodes (internal and external)in the given
    module
   =================================================================-
  -->
  <admst:template match="xyceNumberNodes">
    <admst:text format="%(count(node[grounded='no']))"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNumberProbes
    return the number of nodes (internal and external)in the given
    module
   =================================================================-
  -->
  <admst:template match="xyceNumberProbes">
    <admst:text format="%(count(probe)+count(@extraProbeBranches))"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNumberInternalNodes
    return the number of nodes (internal)in the given
    module
   =================================================================-
  -->
  <admst:template match="xyceNumberInternalNodes">
    <admst:text format="%(count(node[grounded='no' and location='internal']))"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNumberExternalNodes
    return the number of nodes (External)in the given
    module
   =================================================================-
  -->
  <admst:template match="xyceNumberExternalNodes">
    <admst:text format="%(count(node[grounded='no' and location='external']))"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeviceNamespace
    Given a module, return what Xyce namespace we'd want it to be called
   =================================================================-
  -->
  <admst:template match="xyceDeviceNamespace">
    <admst:return name="classname" value="ADMS%(name)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceClassBaseName
    Given a module, return what Xyce class we'd want it to be called
   =================================================================-
  -->
  <admst:template match="xyceClassBaseName">
    <admst:return name="classname" value="N_DEV_ADMS%(name)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceInstanceClassName
    Given a module, return what Xyce class we'd want it to be called
   =================================================================-
  -->
  <admst:template match="xyceInstanceClassName">
    <admst:return name="classname" value="N_DEV_ADMS%(name)Instance"/>
  </admst:template>

  <!--
   =================================================================-
   xyceModelClassName
    Given a module, return what Xyce class we'd want it to be called
   =================================================================-
  -->
  <admst:template match="xyceModelClassName">
    <admst:return name="classname" value="N_DEV_ADMS%(name)Model"/>
  </admst:template>

  <!--
   =================================================================-
   xyceGuardSymbol: make a symbol for the header file to use to prevent
   multiple inclusion
   =================================================================-
  -->
  <admst:template match="xyceGuardSymbol">
    <admst:return name="symbolname" value="Xyce_N_DEV_ADMS%(name)_h"/>
  </admst:template>

  <!--
   =================================================================-
   xyceNodeConstantName
    given a node, generate the name of the integer symbol used to
    identify it in Xyce
   =================================================================-
  -->
  <admst:template match="xyceNodeConstantName">
    <admst:return name="nodeConstant" value="admsNodeID_%(name)"/>
  </admst:template>
  <!--
   =================================================================-
   xyceBranchConstantName
    given a branch, generate the name of the integer symbol used to
    identify it in Xyce
   =================================================================-
  -->
  <admst:template match="xyceBranchConstantName">
    <admst:return name="branchConstant" value="admsBRA_ID_%(pnode)_%(nnode)"/>
  </admst:template>


  <!--
   =================================================================-
   xyceProbeConstantName
    given a probe, generate the name of the integer symbol used to
    identify it in Xyce
   =================================================================-
  -->
  <admst:template match="xyceProbeConstantName">
    <admst:return name="probeConstant" value="admsProbeID_%(nature)_%(branch/pnode)_%(branch/nnode)"/>
  </admst:template>

  <!--
   =================================================================-
   xycePotentialProbeConstantName
    given a branch, generate the name of the integer symbol used to
    identify its associated potetial probe constant in Xyce
   =================================================================-
  -->
  <admst:template match="xycePotentialProbeConstantName">
    <admst:return name="probeConstant" value="admsProbeID_V_%(pnode)_%(nnode)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceFlowProbeConstantName
    given a branch, generate the name of the integer symbol used to
    identify it's associated flow probe in Xyce
   =================================================================-
  -->
  <admst:template match="xyceFlowProbeConstantName">
    <admst:return name="probeConstant" value="admsProbeID_I_%(pnode)_%(nnode)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceJacobianOffsetName
    given a jacobian element, generate the name of the integer symbol
    used to identify its offset
   =================================================================-
  -->
  <admst:template match="xyceJacobianOffsetName">
    <admst:text format="A_%(row/name)_Equ_%(column/name)_NodeOffset"/>
  </admst:template>

  <!--
   =================================================================-
   xycedFdXPtrName
    given a jacobian element, generate the name of the pointer var
    used to identify its location
   =================================================================-
  -->
  <admst:template match="xycedFdXPtrName">
    <admst:text format="f_%(row/name)_Equ_%(column/name)_Node_Ptr"/>
  </admst:template>
  <!--
   =================================================================-
   xycedQdXPtrName
    given a jacobian element, generate the name of the pointer var
    used to identify its location
   =================================================================-
  -->
  <admst:template match="xycedQdXPtrName">
    <admst:text format="q_%(row/name)_Equ_%(column/name)_Node_Ptr"/>
  </admst:template>

  <!--
   =================================================================-
    xyceDeclareVariable
    Given a variable, emit a C++ declaration for that variable
   =================================================================-
  -->
  <admst:template match="xyceDeclareVariable">
    <admst:assert test="adms[datatypename='variable' or datatypename='variableprototype']" format="xyceDeclareVariable expecting datatypename=variable or variableprototype, got %(adms/datatypename)"/>
    <admst:choose>
      <admst:when test="[type='real' and exists(probe)]">
        <admst:text format="AdmsFadType"/>
      </admst:when>
      <admst:otherwise>
        <admst:apply-templates select="." match="verilog2CXXtype"/>
      </admst:otherwise>
    </admst:choose>
    <admst:text format=" %(name);\n"/>
  </admst:template>

  <!--
   =================================================================-
   =================================================================-
    Specialized templates for dealing with guessing device model cards
    and/or header files to include
   =================================================================-
   -->

   <!--
   =================================================================-
   xyceIncludeModelBaseHeader
   Given a module, this template generates an appropriate "#include"
   for the base device IF the module has a "xyceModelGroup" attribute.
   If the attribute doesn't exist, no include is generated.

   Recognized groups:        Header included:
      MOSFET                  N_DEV_MOSFET1.h
      <anything else>         N_DEV_<that>.h
   =================================================================-
   -->
   <admst:template match="xyceIncludeModelBaseHeader">
     <admst:choose>
       <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
         <admst:choose>
           <admst:when test="[attribute[name='xyceModelGroup']/value='MOSFET']">
             <admst:text format="#include &lt;N_DEV_MOSFET1.h&gt;\n"/>
           </admst:when>
           <admst:otherwise>
             <admst:text format="#include &lt;N_DEV_%(attribute[name='xyceModelGroup']/value).h&gt;\n"/>
           </admst:otherwise>
         </admst:choose>
       </admst:when>
     </admst:choose>
   </admst:template>

   <!--
   =================================================================-
   xyceDeclareTraits
   Given a module, this template generates an appropriate "typedef"
   for the DeviceTraits.  IF the module has a "xyceModelGroup" attribute,
   then this uses the base group instance as the group in the template.
   If the attribute doesn't exist, no base group is used.

   Recognized groups:        Base instance:
      MOSFET                  MOSFET1
      <anything else>         <verbatim>
   =================================================================-
   -->
   <admst:template match="xyceDeclareTraits">
struct Traits: public DeviceTraits&lt;Model, Instance
     <admst:choose>
       <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
         <admst:choose>
           <admst:when test="[attribute[name='xyceModelGroup']/value='MOSFET']">
             <admst:text format=", MOSFET1::Traits"/>
           </admst:when>
           <admst:otherwise>
             <admst:text format=", %(attribute[name='xyceModelGroup']/value)::Traits"/>
           </admst:otherwise>
         </admst:choose>
       </admst:when>
     </admst:choose>&gt;
{

    <!-- Figure out a level number -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceLevelNumber'])]">
        <admst:variable name="theLevelNumber" select="%(attribute[name='xyceLevelNumber']/value)"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theLevelNumber" select="FIXME!"/>
      </admst:otherwise>
    </admst:choose>

    <!-- Choose a device name -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceDeviceName'])]">
        <admst:variable name="theDeviceName" select="%(attribute[name='xyceDeviceName']/value)"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theDeviceName" select="ADMS %(name)"/>
      </admst:otherwise>
    </admst:choose>

    <!-- Figure out what spice symbol we use -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceSpiceDeviceName'])]">
        <admst:variable name="theSpiceDevice" select="%(attribute[name='xyceSpiceDeviceName']/value)"/>
      </admst:when>
      <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
        <admst:choose>
          <admst:when test="[attribute[name='xyceModelGroup']/value='MOSFET']">
            <admst:variable name="theSpiceDevice" select="m"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='BJT']">
            <admst:variable name="theSpiceDevice" select="q"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Diode']">
            <admst:variable name="theSpiceDevice" select="d"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Resistor']">
            <admst:variable name="theSpiceDevice" select="r"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Capacitor']">
            <admst:variable name="theSpiceDevice" select="c"/>
          </admst:when>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theSpiceDevice" select="FIXME!"/>
      </admst:otherwise>
    </admst:choose>

    <admst:text format="  static const char *name() {return &quot;%($theDeviceName)&quot;;}\n"/>
    <admst:text format="  static const char *deviceTypeName() {return &quot;%($theSpiceDevice) level %($theLevelNumber)&quot;;}\n"/>
  static const int numNodes() {return <admst:text format="%(xyceNumberExternalNodes(.))"/>;}
  static const bool modelRequired() {return 
     <admst:choose>
       <admst:when test="variable[parametertype='model' and input='yes']">
         <admst:text format="true"/>
       </admst:when>
       <admst:otherwise>
         <admst:text format="false"/>
       </admst:otherwise>
     </admst:choose>
     <admst:text format=";}"/>
  static const bool isLinearDevice() {return false;}

  static Device *factory(const Configuration &amp;configuration, const FactoryBlock &amp;factory_block);
  static void loadModelParameters(ParametricData&lt;Model&gt; &amp;model_parameters);
  static void loadInstanceParameters(ParametricData&lt;Instance&gt; &amp;instance_parameters);
};
   </admst:template>

  <!--
   =================================================================-
   xyceAddModelTypes

   Given a module, this template generates appropriate addModel lines
   for the device.  IF the module has one or more "xyceModelCardType"
   attributes, those are used to emit addModel statements.  If there
   are no xyceModelCardType attributes, but there is a xyceModelGroup
   attribute, the group is used to determine which model types to
   use. If neither exists, a "fixme" line is added (just like the
   behavior in older versions of the back-end).

   Recognized groups:        Model Types
      MOSFET                  PMOS, NMOS
      BJT                     NPN, PNP
      Diode                   D
      Resistor                R
      Capacitor               C
   =================================================================-
   -->
  <admst:template match="xyceAddModelTypes">
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceModelCardType'])]">
        <admst:for-each select="attribute[name='xyceModelCardType']">
          <admst:text format="  addModelType(&quot;%(./value)&quot;);\n"/>
        </admst:for-each>
      </admst:when>
      <admst:otherwise>
        <admst:choose>
          <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
            <admst:choose>
              <admst:when test="[attribute[name='xyceModelGroup']/value='MOSFET']">
                <admst:text format="  addModelType(&quot;NMOS&quot;);\n"/>
                <admst:text format="  addModelType(&quot;PMOS&quot;);\n"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='BJT']">
                <admst:text format="  addModelType(&quot;NPN&quot;);\n"/>
                <admst:text format="  addModelType(&quot;PNP&quot;);\n"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='Diode']">
                <admst:text format="  addModelType(&quot;D&quot;);\n"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='Resistor']">
                <admst:text format="  addModelType(&quot;R&quot;);\n"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='Capacitor']">
                <admst:text format="  addModelType(&quot;C&quot;);\n"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:text format="//  FIXME!    addModelType(&quot;WTF;quot;);\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:otherwise>
    </admst:choose>
  </admst:template>


  <!--
   =================================================================-
   xyceDeviceFactoryandRegisterDevice

   Given a module, this template generates appropriate code for a
   device factory and registerDevice method.  If the attribute
   xyceDeviceName exists, we use that as the name of the device.  If
   not, we use "ADMS <module name>".  Other expected attributes are:

      xyceSpiceDeviceName:   if not given, guess at one from xyceModelGroup.
                             If that is not given, emit a "FIXME"
      xyceLevelNumber:       If not given, "FIXME"

   -->
  <admst:template match="xyceDeviceFactoryandRegisterDevice">

    <!-- Figure out what spice symbol we use -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceSpiceDeviceName'])]">
        <admst:variable name="theSpiceDevice" select="%(attribute[name='xyceSpiceDeviceName']/value)"/>
      </admst:when>
      <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
        <admst:choose>
          <admst:when test="[attribute[name='xyceModelGroup']/value='MOSFET']">
            <admst:variable name="theSpiceDevice" select="m"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='BJT']">
            <admst:variable name="theSpiceDevice" select="q"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Diode']">
            <admst:variable name="theSpiceDevice" select="d"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Resistor']">
            <admst:variable name="theSpiceDevice" select="r"/>
          </admst:when>
          <admst:when test="[attribute[name='xyceModelGroup']/value='Capacitor']">
            <admst:variable name="theSpiceDevice" select="c"/>
          </admst:when>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theSpiceDevice" select="FIXME!"/>
      </admst:otherwise>
    </admst:choose>

    <!-- Figure out a level number -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceLevelNumber'])]">
        <admst:variable name="theLevelNumber" select="%(attribute[name='xyceLevelNumber']/value)"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="theLevelNumber" select="FIXME!"/>
      </admst:otherwise>
    </admst:choose>

    <!-- Now emit the factory -->
    <admst:text format="Device *Traits::factory(const Configuration &amp;configuration, const FactoryBlock &amp;factory_block)\n"/>
    <admst:text format="{\n"/>
    <admst:text format="  return new DeviceMaster&lt;Traits&gt;(configuration, factory_block, factory_block.solverState_, factory_block.deviceOptions_);\n"/>
    <admst:text format="}\n\n"/>

    <!-- and the registerDevice -->
    <admst:text format="void registerDevice()\n"/>
    <admst:text format="{\n"/>
    <admst:text format="  Config&lt;Traits&gt;::addConfiguration()\n"/>
    <admst:text format="    .registerDevice(&quot;%($theSpiceDevice)&quot;, %($theLevelNumber))"/>

    <!-- and all the registerModelTypes... -->
    <admst:choose>
      <admst:when test="[exists(attribute[name='xyceModelCardType'])]">
        <admst:for-each select="attribute[name='xyceModelCardType']">
          <admst:text format="\n    .registerModelType(&quot;%(./value)&quot;, %($theLevelNumber))"/>
        </admst:for-each>
      </admst:when>
      <admst:otherwise>
        <admst:choose>
          <admst:when test="[exists(attribute[name='xyceModelGroup'])]">
            <admst:choose>
              <admst:when  test="[attribute[name='xyceModelGroup']/value='MOSFET']">
                <admst:text format="\n    .registerModelType(&quot;nmos&quot;, %($theLevelNumber))"/>
                <admst:text format="\n    .registerModelType(&quot;pmos&quot;, %($theLevelNumber))"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='BJT']">
                <admst:text format="\n    .registerModelType(&quot;npn&quot;, %($theLevelNumber))"/>
                <admst:text format="\n    .registerModelType(&quot;pnp&quot;, %($theLevelNumber))"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='Diode']">
                <admst:text format="\n    .registerModelType(&quot;d&quot;, %($theLevelNumber))"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='Resistor']">
                <admst:text format="\n    .registerModelType(&quot;r&quot;, %($theLevelNumber))"/>
              </admst:when>
              <admst:when test="[attribute[name='xyceModelGroup']/value='Capacitor']">
                <admst:text format="\n    .registerModelType(&quot;c&quot;, %($theLevelNumber))"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <!-- If the device requires a model (i.e. there are any 
                  parameters of type "model"), and no modely type has
                  been given in attributes, emit comments to fix the issue -->
            <admst:if test="variable[parametertype='model' and input='yes']">

                <admst:text format="\n//  FIXME!    .registerModelType(&quot;WTF;quot;, %($theLevelNumber))\n"/>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:otherwise>
    </admst:choose>

    <admst:text format=";\n}\n\n"/>

  </admst:template>
  <!--
   =================================================================-
   =================================================================-
    Specialized templates for declaring and initializing Instance and
    Model variables
   =================================================================-

   =================================================================-
   xyceDeclareInstanceVariables
   Extract all the variables that are either instance parameters or
   instance variables (with "global_instance" scope) and declare them
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceDeclareInstanceVariables">
    <admst:text format="    // Begin verilog Instance Variables\n"/>
    <admst:text format="    //   Instance Parameters\n"/>
    <admst:for-each select="variable[parametertype='instance' and input='yes']">
      <admst:text format="    "/>
      <admst:apply-templates select="." match="verilog2CXXtype"/>
      <admst:text format=" %(name);\n"/>
    </admst:for-each>
    <admst:text format="    //  Variables of global_instance scope\n"/>
    <admst:for-each select="variable[scope='global_instance' and input='no']">
      <admst:text format="    "/>
      <admst:apply-templates select="." match="xyceDeclareVariable"/>
    </admst:for-each>
    <admst:text format="    // end verilog Instance Variables=====\n"/>
  </admst:template>


  <!--
   =================================================================-
   xyceDeclareNodeConstants
    Declare const integers giving the node number of all named nodes
   =================================================================-
  -->
  <admst:template match="xyceDeclareNodeConstants">
    <admst:text format="   // node numbers\n"/>
    <admst:for-each select="node[grounded='no']">
      <admst:text format="    static const int %(xyceNodeConstantName(.)/[name='nodeConstant']/value) = %(position(.)-1);\n"/>
    </admst:for-each>
    <admst:text format="   // end node numbers\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareBranchConstants
    Declare const integers giving the node number of all named nodes
   =================================================================-
  -->
  <admst:template match="xyceDeclareBranchConstants">
    <admst:text format="   // Additional IDs for branch equations\n"/>
    <admst:for-each select="/module/@extraUnknowns">
      <admst:text format="    static const int %(xyceBranchConstantName(.)/[name='branchConstant']/value) = %(position(.)-1 + count(/module/node[grounded='no']));\n"/>
    </admst:for-each>
    <admst:text format="   // end branch numbers\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareProbeConstants
    Declare const integers giving the probe number of all used probes
   =================================================================-
  -->
  <admst:template match="xyceDeclareProbeConstants">
    <admst:text format="   // Probe numbers\n"/>
    <admst:for-each select="$thisModule/probe">
      <admst:text format="    static const int %(xyceProbeConstantName(.)/[name='probeConstant']/value) = %(position(.)-1);\n"/>
    </admst:for-each>
    <admst:for-each select="@extraProbeBranches">
      <admst:text format="    static const int %(xyceFlowProbeConstantName(.)/[name='probeConstant']/value) = %(count($thisModule/probe)+position(.)-1);\n"/>
    </admst:for-each>
    <admst:text format="   // end probe numbers\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareLimitedProbeStateLIDs
    Declare integers for state LIDs of limited probes, given a module
   =================================================================-
  -->
  <admst:template match="xyceDeclareLimitedProbeStateLIDs">
    <admst:text format="   // State LIDs\n"/>
    <admst:for-each select="@limitedProbes">
      <admst:text format="    int %(xyceLimitedProbeStateLIDVariable(.));\n"/>
    </admst:for-each>
    <admst:text format="   // end state LIDs\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceInstanceInitializers
   Extract all the variables that are either instance parameters or
   instance variables (with "global_instance" scope) and generate
   an initializer list for the constructor.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceInstanceInitializers">
    <admst:if test="[exists(variable[(parametertype='instance' and input='yes') or (scope='global_instance' and input='no')])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="variable[(parametertype='instance' and input='yes') or (scope='global_instance' and input='no')]" separator=",\n    ">
      <admst:text format="%(name)("/>
      <admst:choose>
        <admst:when test="[exists(default) and not exists(#dependent)]">
          <admst:text format="%(printTerm(default))"/>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[type='real']">
              <admst:text format="0.0"/>
            </admst:when>
            <admst:when test="[type='integer']">
              <admst:text format="0"/>
            </admst:when>
            <admst:when test="[type='string']">
              <admst:text format="&quot;&quot;"/>
            </admst:when>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
      <admst:text format=")"/>
    </admst:join>
    <!-- now initialize the LIDs: -->
    <admst:if test="[exists(node[grounded='no'])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="node[grounded='no']" separator=",\n    ">
      <admst:text format="%(xyceNodeLIDVariable(.))(-1)"/>
    </admst:join>
    <!-- now initialize the jacobian pointers: -->
    <admst:if test="[exists(jacobian)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="jacobian" separator=",\n    ">
      <admst:text format="%(xycedFdXPtrName(.))(0)"/>
    </admst:join>
    <!-- extra pointers from branch equations -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:text format=",\n    "/>
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr(0)"/>
      </admst:join>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:if test="[not(nilled(@nodeDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@nodeDeps" separator=",\n    ">
        <admst:text format="f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr(0)"/>
      </admst:join>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr(0)"/>
      </admst:join>
    </admst:for-each>
    <!-- for the Q jacobian -->
    <admst:if test="[exists(jacobian)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="jacobian" separator=",\n    ">
      <admst:text format="%(xycedQdXPtrName(.))(0)"/>
    </admst:join>
    <!-- extra pointers from branch equations -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:text format=",\n    "/>
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr(0)"/>
      </admst:join>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:if test="[not(nilled(@nodeDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@nodeDeps" separator=",\n    ">
        <admst:text format="q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr(0)"/>
      </admst:join>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr(0)"/>
      </admst:join>
    </admst:for-each>
    <admst:text format=",\n    admsTemperature(getDeviceOptions().temp.getImmutableValue&lt;double&gt;())\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceModelInitializers
   Extract all the variables that are either model parameters or
   model variables (with "global_model" scope) and generate
   an initializer list for the constructor.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceModelInitializers">
    <admst:if test="[exists(variable[(parametertype='model' and input='yes') or (scope='global_model' and input='no')])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="variable[(parametertype='model' and input='yes') or (scope='global_model' and input='no')]" separator=",\n    ">
      <admst:text format="%(name)("/>
      <admst:choose>
        <admst:when test="[exists(default) and not exists(#dependent)]">
          <admst:text format="%(printTerm(default))"/>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[type='real']">
              <admst:text format="0.0"/>
            </admst:when>
            <admst:when test="[type='integer']">
              <admst:text format="0"/>
            </admst:when>
            <admst:when test="[type='string']">
              <admst:text format="&quot;&quot;"/>
            </admst:when>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
      <admst:text format=")"/>
    </admst:join>
  </admst:template>

  <!--
   =================================================================-
   xyceInstanceCopyInitializers
   Extract all the variables that are either instance parameters or
   instance variables (with "global_instance" scope) and generate
   an initializer list for the copy constructor.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceInstanceCopyInitializers">
    <admst:if test="[exists(variable[(parametertype='instance' and input='yes') or (scope='global_instance' and input='no')])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="variable[(parametertype='instance' and input='yes') or (scope='global_instance' and input='no')]" separator=",\n    ">
      <admst:text format="%(name)(right.%(name))"/>
    </admst:join>
    <!-- now initialize the LIDs: -->
    <admst:if test="[exists(node[grounded='no'])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="node[grounded='no']" separator=",\n    ">
      <admst:text format="%(xyceNodeLIDVariable(.))(right.%(xyceNodeLIDVariable(.)))"/>
    </admst:join>
    <!-- now initialize the jacobian offsets: -->
    <admst:if test="[exists(jacobian)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="jacobian" separator=",\n    ">
      <admst:text format="%(xycedFdXPtrName(.))(right.%(xycedFdXPtrName(.)))"/>
    </admst:join>
    <!-- extra pointers from branch equations -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:text format=",\n    "/>
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr(right.f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr)"/>
      </admst:join>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:if test="[not(nilled(@nodeDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@nodeDeps" separator=",\n    ">
        <admst:text format="f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr(right.f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr)"/>
      </admst:join>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr(right.f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr)"/>
      </admst:join>
    </admst:for-each>
    <!-- same for Q -->
    <admst:if test="[exists(jacobian)]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="jacobian" separator=",\n    ">
      <admst:text format="%(xycedQdXPtrName(.))(right.%(xycedQdXPtrName(.)))"/>
    </admst:join>
    <!-- extra pointers from branch equations -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:text format=",\n    "/>
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr(right.q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr)"/>
      </admst:join>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:if test="[not(nilled(@nodeDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@nodeDeps" separator=",\n    ">
        <admst:text format="q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr(right.q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr)"/>
      </admst:join>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format=",\n    "/>
      </admst:if>
      <admst:join select="@branchDeps" separator=",\n    ">
        <admst:text format="q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr(right.q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr)"/>
      </admst:join>
    </admst:for-each>
    <admst:text format=",\n    admsTemperature(right.admsTemperature)\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceModelCopyInitializers
   Extract all the variables that are either model parameters or
   model variables (with "global_model" scope) and generate
   an initializer list for the copy constructor.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceModelCopyInitializers">
    <admst:if test="[exists(variable[(parametertype='model' and input='yes') or (scope='global_model' and input='no')])]">
      <admst:text format=",\n    "/>
    </admst:if>
    <admst:join select="variable[(parametertype='model' and input='yes') or (scope='global_model' and input='no')]" separator=",\n    ">
      <admst:text format="%(name)(right.%(name))"/>
    </admst:join>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareModelVariables
   Extract all the variables that are either model parameters or
   model variables (with "global_model" scope) and declare them.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceDeclareModelVariables">
    <admst:text format="// Begin verilog Model Variables\n"/>
    <admst:text format="//   Model Parameters\n"/>
    <admst:for-each select="variable[(parametertype='model' or (parametertype='instance' and exists(attribute[name='xyceAlsoModel']))) and input='yes']">
      <admst:text format="    "/>
      <admst:apply-templates select="." match="verilog2CXXtype"/>
      <admst:text format=" %(name);\n"/>
    </admst:for-each>
    <admst:text format="    //  Variables of global_model scope\n"/>
    <admst:for-each select="variable[scope='global_model' and input='no']">
      <admst:text format="    "/>
      <admst:apply-templates select="." match="xyceDeclareVariable"/>
      <admst:if test="[type='real' and exists(probe)]">
        <admst:warning format="WARNING!  global model variable %(name) has probe dependence.  That smells like an error.\n"/>
      </admst:if>
    </admst:for-each>
    <admst:text format="    // end verilog model variables====="/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareNodeLIDVariables
   Generate a set of declarations for LID variables given module's
   nodes.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceDeclareNodeLIDVariables">
    <admst:text format="    // Nodal LID Variables\n"/>
    <admst:for-each select="node[grounded='no']">
      <admst:text format="    int %(xyceNodeLIDVariable(.));\n"/>
    </admst:for-each>
    <admst:text format="    // end Nodal LID Variables\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareBranchLIDVariables
   Generate a set of declarations for LID variables given module's
   branch equations.
   Give the module for "select"
   =================================================================-
  -->
  <admst:template match="xyceDeclareBranchLIDVariables">
    <admst:text format="    // Branch LID Variables\n"/>
    <admst:for-each select="@extraUnknowns">
      <admst:text format="    int %(xyceBranchLIDVariable(.));\n"/>
    </admst:for-each>
    <admst:text format="    // end Branch LID Variables\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareJacobianOffsets
   given a module, declare the batch of Offset variables used when
   accessing jacobian elements
   =================================================================-
  -->
  <admst:template match="xyceDeclareJacobianOffsets">
    <admst:text format="    // Jacobian  pointers\n"/>
    <!-- normal jacobian pointers -->
    <admst:for-each select="jacobian">
      <admst:text format="    double * %(xycedFdXPtrName(.));\n"/>
    </admst:for-each>
    <!-- extra pointers for columns from branch equation dependencies -->
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:for-each select="@branchDeps">
        <admst:text format="    double * f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr;\n"/>
      </admst:for-each>
    </admst:for-each>
    <!-- extra pointers for branch equation rows -->
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:for-each select="@nodeDeps">
        <admst:text format="    double * f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr;\n"/>
      </admst:for-each>
      <admst:for-each select="@branchDeps">
        <admst:text format="    double * f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr;\n"/>
      </admst:for-each>
    </admst:for-each>

    <!-- now the same thing for Q -->
    <admst:for-each select="jacobian">
      <admst:text format="    double * %(xycedQdXPtrName(.));\n"/>
    </admst:for-each>
    <admst:for-each select="node/[not(nilled(@branchDeps))]">
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:for-each select="@branchDeps">
        <admst:text format="    double * q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr;\n"/>
      </admst:for-each>
    </admst:for-each>
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
        <admst:for-each select="@nodeDeps">
          <admst:text format="    double * q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr;\n"/>
        </admst:for-each>
        <admst:for-each select="@branchDeps">
          <admst:text format="    double * q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr;\n"/>
        </admst:for-each>
    </admst:for-each>
    <admst:text format="    // end of Jacobian and pointers\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareFadArrays
   Given a module, generate declaration of contribution arrays
   =================================================================-
  -->
  <admst:template match="xyceDeclareFadArrays">
    <admst:text format=" // Arrays to hold probes\n"/>
    <admst:text format=" std::vector &lt; AdmsFadType &gt; probeVars;\n"/>
    <admst:text format=" // Arrays to hold contributions\n"/>
    <admst:text format=" // dynamic contributions are differentiated w.r.t time\n"/>
    <admst:text format=" std::vector &lt; AdmsFadType &gt; staticContributions;\n"/>
    <admst:text format=" std::vector &lt; AdmsFadType &gt; dynamicContributions;\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceDeclareLimitingTemporaries
   Declare the various temporary variables that we need for limiting
   in updateIntermediateVarsBlock.  Pass in the module.
   =================================================================-
  -->
  <admst:template match="xyceDeclareLimitingTemporaries">
    <admst:text format=" // temporary variables for limiting\n"/>
    <admst:for-each select="@limiters">
      <admst:text format=" double %(printTerm(lhs))_orig,%(printTerm(lhs))_limited,%(printTerm(lhs))_old;\n"/>
    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   xyceNodeLIDVariable
   Given a node, return its associated LID variable
   =================================================================-
  -->
  <admst:template match="xyceNodeLIDVariable">
    <admst:text format="li_%(name)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceBranchLIDVariable
   Given a branch, return its associated LID variable
   =================================================================-
  -->
  <admst:template match="xyceBranchLIDVariable">
    <admst:text format="li_BRA_%(pnode)_%(nnode)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceLimitedProbeStateLIDVariable
   Given a probe, return its associated state LID variable for limiting
   =================================================================-
  -->
  <admst:template match="xyceLimitedProbeStateLIDVariable">
    <admst:text format="li_state_%(xyceProbeConstantName(.)/[name='probeConstant']/value)"/>
  </admst:template>

  <!--
   =================================================================-
   xyceAnalogFunctionDeclaration
    Given an analog function, return a declaration for putting in
    the header file.
    Unlike the way "analogfunction.xml" from the ADMS source does,
    we do NOT prefix the function with the module name, because
    we're going to make it a member function of the class, and the
    prefix will be redundant
   =================================================================-
  -->
  <admst:template match="xyceAnalogFunctionDeclaration">
    <admst:value-of select="name"/>
    <admst:variable name="function" select="%s"/>
    <admst:apply-templates
       select="."
       match="verilog2CXXtype"/>
    <admst:text format=" $function("/>
    <admst:join
       select="variable[input='yes']"
       separator=", ">
      <admst:value-of select="name"/>
      <admst:apply-templates select="." match="verilog2CXXtype"/>
      <admst:text format=" %s"/>
    </admst:join>
    <admst:text format=");\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceTemplatedAnalogFunctionDeclaration
    Given an analog function, return a declaration for putting in
    the header file.
   Unlike xyceAnalogFunctionDeclaration, we don't actually declare
   the function as it's declared in the verilog source, but rather
   as a templated function whose return type is assumed to be the
   type of all its arguments, which are assumed to be all of
   exactly the same type.  We'll simply puke with an error if this
   condition isn't met.
    Unlike the way "analogfunction.xml" from the ADMS source does,
    we do NOT prefix the function with the module name, because
    we're going to make it a member function of the class, and the
    prefix will be redundant
   =================================================================-
  -->
  <admst:template match="xyceTemplatedAnalogFunctionDeclaration">
    <admst:value-of select="name"/>
    <admst:variable name="function" select="%s"/>
    <!-- save the return type -->
    <admst:value-of select="type"/>
    <admst:variable name="returnType" select="%s"/>

    <!-- puke if any variable fails to match type -->
    <admst:for-each select="variable[input='yes' and
                            type!='$returnType']">
      <admst:fatal format="Variable %(name) of type %(type) is not of same type as return
                      type of function $function, which is of type$returnType\n"/>
    </admst:for-each>

    <!-- if we get here, all's good. Just churn out the declaration -->
    <!-- must output variables defined as input, output, or inout, but not
         the one that has the same name as the function -->
    <admst:text format="template&lt;typename ScalarT&gt; ScalarT $function("/>
    <admst:join
       select="variable[input='yes' or (input='no' and output='yes' and name!=$function)]"
       separator=", ">
      <admst:text format="ScalarT "/>
      <!-- only pass by reference if it's an output variable. -->
      <!-- this does cost us in copy constructions of Sacado type variables,
           but is needed for correctness if analog functions modify their
           "input" variables, which they're allowed to do -->
      <admst:if test="[output='yes']">
        <admst:text format="&amp; "/>
      </admst:if>
      <admst:text format="%(name)"/>
    </admst:join>
    <admst:text format=")\n"/>
    <admst:text format="{\n"/>

    ScalarT %($function);

    <admst:for-each select="variable[input='no' and output='no']">
      <admst:text select="[type='$returnType']" format="ScalarT "/>
      <admst:text select="[type!='$returnType']" format="%(verilog2CXXtype(.)) "/>
      <admst:text format="%(name);\n"/>
    </admst:for-each>
    <admst:apply-templates select="tree" match="%(adms/datatypename)"/>
    <admst:text format="return(%(name));\n"/>
    <admst:text format="}\n"/>
  </admst:template>

  <!--
   =================================================================-
   xyceCopyModelVars
     given a module, generate code for assuring that instance vars
     that override model vars get appropriate defaults
   =================================================================-
  -->
  <admst:template match="xyceCopyModelVars">
    <admst:for-each select="variable[parametertype='instance' and exists(attribute[name='xyceAlsoModel']) and input='yes']">
      <admst:text format="   if (!(given(&quot;%(name)&quot;)))\n"/>
      <admst:text format="   {\n"/>
      <admst:text format="      %(name) = model_.%(name);\n"/>
      <admst:text format="   }\n"/>
    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   xyceRegisterJacLIDs
     given a module, generate code for initializing jacobian LIDs
   =================================================================-
  -->
  <admst:template match="xyceRegisterJacLIDs">
    <admst:variable name="theModule" select="%(.)"/>
    <admst:for-each select="node[grounded='no']">
      <admst:variable name="theEquation" select="%(.)"/>
      <admst:variable name="theEquationNumber" select="%(position(.)-1)"/>
      <admst:variable name="theEquationName" select="%(name)"/>
      <admst:variable name="theEquationConstant" select="%(xyceNodeConstantName($theEquation)/[name='nodeConstant']/value)"/>
      <admst:for-each select="$theModule/jacobian[row/name='$theEquationName']">
        <admst:text format="    %(xyceJacobianOffsetName(.)) = jacLIDVec[map[$theEquationConstant]][map2[$theEquationConstant][%(position(.)-1)]];\n"/>
      </admst:for-each>
    </admst:for-each>

    <admst:text format="#ifdef Xyce_DEBUG_DEVICE\n"/>
    <admst:text format="  if (getDeviceOptions().debugLevel&gt;1)\n"/>
    <admst:text format="  {\n"/>
    <admst:for-each select="node[grounded='no']">
      <admst:variable name="theEquation" select="%(.)"/>
      <admst:variable name="theEquationNumber" select="%(position(.)-1)"/>
      <admst:variable name="theEquationName" select="%(name)"/>
      <admst:variable name="theEquationConstant" select="%(xyceNodeConstantName($theEquation)/[name='nodeConstant']/value)"/>
      <admst:for-each select="$theModule/jacobian[row/name='$theEquationName']">
        <admst:text format="    std::cout &lt;&lt; &quot;%(xyceJacobianOffsetName(.)) = &quot; &lt;&lt; %(xyceJacobianOffsetName(.)) &lt;&lt; std::endl;\n"/>
      </admst:for-each>
    </admst:for-each>
    <admst:text format="  }\n"/>
    <admst:text format="#endif\n"/>
  </admst:template>


  <!--
   =================================================================-
   xyceSetupPointers
     given a module, generate code for initializing jacobian LIDs
   =================================================================-
  -->
  <admst:template match="xyceSetupPointers">
    <admst:variable name="theModule" select="%(.)"/>
    <admst:for-each select="node[grounded='no']">
      <admst:variable name="theEquation" select="%(.)"/>
      <admst:variable name="theEquationNumber" select="%(position(.)-1)"/>
      <admst:variable name="theEquationName" select="%(name)"/>
      <admst:variable name="theEquationConstant" select="%(xyceNodeConstantName($theEquation)/[name='nodeConstant']/value)"/>
      <admst:for-each select="$theModule/jacobian[row/name='$theEquationName']">
        <admst:text format="    %(xycedFdXPtrName(.)) = dFdxMatPtr->returnRawEntryPointer(%(xyceNodeLIDVariable(row)),%(xyceNodeLIDVariable(column)));\n"/>
        <admst:text format="    %(xycedQdXPtrName(.)) = dQdxMatPtr->returnRawEntryPointer(%(xyceNodeLIDVariable(row)),%(xyceNodeLIDVariable(column)));\n"/>
      </admst:for-each>

      <!-- set up pointers for extra columns due to branches-->
      <admst:variable name="theNodeName" select="%(./name)"/>
      <admst:for-each select="@branchDeps">
        <admst:text format="    f_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr = dFdxMatPtr->returnRawEntryPointer(%(xyceNodeLIDVariable($theEquation)),%(xyceBranchLIDVariable(.)));\n"/>
        <admst:text format="    q_%($theNodeName)_Equ_BRA_%(pnode)_%(nnode)_Var_Ptr = dQdxMatPtr->returnRawEntryPointer(%(xyceNodeLIDVariable($theEquation)),%(xyceBranchLIDVariable(.)));\n"/>
      </admst:for-each>
    </admst:for-each>

    <!-- Now we need to generate the pointers for the extra rows for branch
         equations -->
    <admst:for-each select="@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(./pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(./nnode/name)"/>
      <admst:variable name="theBranch" select="%(.)"/>
      <admst:for-each select="@nodeDeps">
        <admst:text format="    f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr = dFdxMatPtr->returnRawEntryPointer(%(xyceBranchLIDVariable($theBranch)),%(xyceNodeLIDVariable(.)));\n"/>
        <admst:text format="    q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_%(name)_Node_Ptr = dQdxMatPtr->returnRawEntryPointer(%(xyceBranchLIDVariable($theBranch)),%(xyceNodeLIDVariable(.)));\n"/>
      </admst:for-each>
      <admst:for-each select="@branchDeps">
        <admst:text format="    f_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr=dFdxMatPtr->returnRawEntryPointer(%(xyceBranchLIDVariable($theBranch)),%(xyceBranchLIDVariable(.)));\n"/>
        <admst:text format="    q_BRA_%($thePnodeName)_%($theNnodeName)_Equ_BRA_%(pnode/name)_%(nnode/name)_Var_Ptr=dQdxMatPtr->returnRawEntryPointer(%(xyceBranchLIDVariable($theBranch)),%(xyceBranchLIDVariable(.)));\n"/>
      </admst:for-each>
    </admst:for-each>

  </admst:template>


  <!--
   =================================================================-
   xyceGenerateJacStamp
     given a module, generate code for initializing  jacobian stamp
   =================================================================-
  -->
  <admst:template match="xyceGenerateJacStamp">
    <admst:variable name="theModule" select="%(.)"/>
    <admst:text format="    jacStamp.resize(%(count(node[grounded='no'])));\n"/>
    <admst:for-each select="node[grounded='no']">
      <admst:variable name="theEquation" select="%(.)"/>
      <admst:variable name="theEquationName" select="%(name)"/>
      <admst:variable name="theEquationConstant" select="%(xyceNodeConstantName($theEquation)/[name='nodeConstant']/value)"/>
      <admst:text format="    jacStamp[$theEquationConstant].resize(%(count($theModule/jacobian[row/name='$theEquationName'])+count(@branchDeps)));\n"/>
      <admst:for-each select="$theModule/jacobian[row/name='$theEquationName']">
        <admst:text format="    jacStamp[$theEquationConstant][%(position(.)-1)] = %(xyceNodeConstantName(column)/[name='nodeConstant']/value);\n"/>
      </admst:for-each>
      <admst:if test="[not(nilled(@branchDeps))]">
        <admst:text format="    // Extra columns for dependence on branches\n"/>
        <admst:text format="    {\n      int tempOffset=0;\n"/>
        <admst:for-each select="@branchDeps">
        <admst:text format="    jacStamp[$theEquationConstant][%(count($theModule/jacobian[row/name='$theEquationName']))+(tempOffset++)] = %(xyceBranchConstantName(.)/[name='branchConstant']/value);\n"/>
        </admst:for-each>
        <admst:text format="    }\n\n"/>
      </admst:if>

    </admst:for-each>
    <admst:apply-templates select="." match="xyceAugmentJacStamp"/>
  </admst:template>


  <!--
   =================================================================-
   xyceAugmentJacStamp
     given a module, generate code for adding branch equations/variables
     to an existing  jacobian stamp
   =================================================================-
  -->
  <admst:template match="xyceAugmentJacStamp">

<!--
    <admst:for-each select="@extraJac1">
      <admst:variable name="theRow" select="%(xyceNodeConstantName(.)/[name='nodeConstant']/value)"/>
      <admst:variable name="theRowName" select="%(name)"/>
      //Augment jacobian row for %($theRowName)
    {
      int rowsize;
      int tempColOffset=0;
      rowsize=jacStamp[%($theRow)].size();
      jacStamp[%($theRow)].resize(rowsize+%(count(@branchDeps)));
      <admst:for-each select="@branchDeps">
      jacStamp[%($theRow)][rowsize+(tempColOffset++)] = %(xyceBranchConstantName(.)/[name='branchConstant']/value); // eqn %($theRowName) - branch var %(.)
      </admst:for-each>
    }
    </admst:for-each>
-->
    <admst:if test="[not(nilled(@extraUnknowns))]">
      <admst:text format="    // Jacobian rows for branch equations\n"/>
    </admst:if>
    <admst:for-each select="@extraUnknowns">
    {
      int jacsize=jacStamp.size();
      jacStamp.resize(jacsize+1);
      <admst:variable name="theRow" select="%(xyceBranchConstantName(.)/[name='branchConstant']/value)"/>
      <admst:variable name="theBranchName" select="%(.)"/>
      jacStamp[$theRow].resize(%(count(@nodeDeps)+count(@branchDeps)));
      int tempCol = 0;
      <admst:for-each select="@nodeDeps">
      jacStamp[$theRow][tempCol++] = %(xyceNodeConstantName(.)/[name='nodeConstant']/value);   // Branch eqn %($theBranchName) - node %(./name)
      </admst:for-each>
      <admst:for-each select="@branchDeps">
      jacStamp[$theRow][tempCol++] = %(xyceBranchConstantName(.)/[name='branchConstant']/value); // Branch eqn %($theBranchName) - branch var %(.)
      </admst:for-each>
    }
    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   collectBranchDepends
   Given a branch (which is assumed to have an associated
   branch variable due to use of flow probes and/or potential sources),
   count up how many jacobian columns should be allocated for the
   associated branch equation.  When returns, /module/@countNodes
   will list all the nodes this branch equation depends on (through
   potential probes) and /module/@countBranches will list the branch
   flows it depends on (through flow probes).
   =================================================================-
   -->
  <admst:template match="collectBranchDepends">
    <admst:variable name="thePnode" select="%(pnode)"/>
    <admst:variable name="theNnode" select="%(nnode)"/>
    <admst:reset select="/module/@countNodes"/>
    <admst:reset select="/module/@countBranches"/>
    <admst:for-each select="/module/contribution[lhs/branch/pnode=$thePnode and lhs/branch/nnode=$theNnode]">
      <admst:for-each select="rhs/probe">
        <admst:choose>
          <!-- potential probes on the RHS add nodal dependencies to
               the branch equation-->
          <admst:when test="[nature=discipline/potential]">
            <admst:push into="/module/@countNodes" select="branch/pnode" onduplicate="ignore"/>
            <admst:if test="[branch/nnode/grounded='no']">
              <admst:push into="/module/@countNodes" select="branch/nnode" onduplicate="ignore"/>
            </admst:if>
          </admst:when>
          <!-- flow probes on the RHS add branch dependencies to the
               branch equation -->
          <admst:otherwise>
            <admst:push into="/module/@countBranches" select="branch" onduplicate="ignore"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
      <!-- Finally, if this is a potential source, the branch equation
           also depends on the nodes of the lhs.  If it's a flow source,
           the branch equation depends on the flow variable.
      -->
      <admst:choose>
        <admst:when test="[lhs/nature=lhs/discipline/potential]">
          <admst:push into="/module/@countNodes" select="lhs/branch/pnode" onduplicate="ignore"/>
          <admst:if test="[lhs/branch/nnode/grounded='no']">
            <admst:push into="/module/@countNodes" select="lhs/branch/nnode" onduplicate="ignore"/>
            </admst:if>
        </admst:when>
        <admst:otherwise>
          <admst:push into="/module/@countBranches" select="lhs/branch" onduplicate="ignore"/>
        </admst:otherwise>
      </admst:choose>

    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   =================================================================-
   Basic templates for processing verilog

   =================================================================-
   =================================================================-

   =================================================================-
   collectAssignedVariables
   Given a node of the ADMS data tree, determine all variables that
   appear on the left-hand side of assignments in that node and all
   of its children.  This is done recursively.

   The list of all those variables is deposited in the @assignedVars
   array of the *PARENT* of the node passed in.  This is fishy, and
   I wish I could figure out a way to do it without pushing the data
   up above the node we start with.

   Since we push data upward, it's probably best not to call this on
   the top level "analog/code" node of the tree, but rather loop over
   all of that node's children instead if one needs to process it.
   =================================================================-
  -->
<admst:template match="collectAssignedVariables">
  <admst:choose>
    <!-- ASSIGNMENT -->
    <admst:when test="adms[datatypename='assignment']">
      <admst:push into="../@assignedVars" select="lhs" onduplicate="ignore"/>
    </admst:when>
    <!-- BLOCK -->
    <admst:when test="adms[datatypename='block']">
      <!-- recurse -->
      <admst:for-each select="item">
        <admst:apply-templates select="." match="collectAssignedVariables"/>
      </admst:for-each>
      <!-- the result should be that our current node, which is a block,
           has received all the variables of all its children listed in
           @assignedVars -->
    </admst:when>
    <!-- CONDITIONAL -->
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="then" match="collectAssignedVariables"/>
      <admst:apply-templates select="else" match="collectAssignedVariables"/>
    </admst:when>
    <!-- WHILELOOP -->
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="collectAssignedVariables"/>
    </admst:when>
    <!-- FORLOOP -->
    <admst:when test="adms[datatypename='forloop']">
      <admst:apply-templates select="initial" match="collectAssignedVariables"/>
      <admst:apply-templates select="forblock" match="collectAssignedVariables"/>
      <admst:apply-templates select="update" match="collectAssignedVariables"/>
    </admst:when>
    <!-- CASE -->
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="caseitem" match="collectAssignedVariables"/>
    </admst:when>
    <!-- caseitem -->
    <admst:when test="adms[datatypename='caseitem']">
      <admst:apply-templates select="code" match="collectAssignedVariables"/>
    </admst:when>
    <!-- CODE -->
    <admst:when test="adms[datatypename='code']">
      <admst:apply-templates select="item" match="collectAssignedVariables">
      </admst:apply-templates>
    </admst:when>
    <!-- none of the following types can do assignment -->
    <admst:when test="adms[datatypename='contribution']"/>
    <admst:when test="adms[datatypename='callfunction']"/>
    <admst:when test="adms[datatypename='nilled']"/>
    <admst:when test="adms[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:fatal format="'datatypename=%(adms/datatypename)':collectAssignedVariables cannot process this type, should not be reached.\n"/>
    </admst:otherwise>
  </admst:choose>
  <!-- At this point, we have processed our own and our children's variables,
       and our @assignedVars array contains all the variables we or our
       children have assigned into.  Pass this information up to our parent
       if we haven't already done it (because we're an assignment). -->
  <admst:if test="adms[datatypename!='assignment']">
    <admst:variable name="parent" select="%(..)"/>
    <admst:for-each select="@assignedVars">
<!--      <admst:warning format="Got something other than assignment (%(../datatypename
)), pushing %(.) into $parent whcih is of type %($parent/datatypename)\n"/>-->
      <admst:push into="$parent/@assignedVars" select="." onduplicate="ignore"/>
    </admst:for-each>
  </admst:if>
</admst:template>

<!--
 =================================================================-
 collectInterdependentParams
 Given a module, run through all the parameter variables it has and
 mark as "#dependent='yes'" any that have default values that depend
 on other variables in any way.

 These variables cannot have their defaults determined by their addPar
 calls, and must have their defaults set (if not given in the netlist)
 at constructor time instead.

 This template is intended to be called early in processing, like
 collectLimters and collectCollapsibles
 =================================================================-
 -->
 <admst:template match="collectInterdependentParams">
   <admst:for-each select="variable[(parametertype='instance' or parametertype='model') and input='yes' and exists(default)]">
     <admst:apply-templates select="default" match="recursiveDetectVariableDependence">
       <admst:if test="[returned('isDependent')/value = 'yes']">
         <admst:value-to select="../#dependent" string="yes"/>
       </admst:if>
     </admst:apply-templates>
   </admst:for-each>
 </admst:template>

<!--
 =================================================================-
 recursiveDetectVariableDependence
 Given a node, try to determine if the expression it represents has
 dependence on parameter variables
 =================================================================-
 -->
 <admst:template match="recursiveDetectVariableDependence">
 <admst:choose>
   <admst:when test="[datatypename='number']">
     <admst:return name="isDependent" value="no"/>
   </admst:when>
   <admst:when test="[datatypename='variable']">
     <admst:return name="isDependent" value="yes"/>
   </admst:when>
   <admst:when test="[datatypename='expression']">
     <admst:apply-templates select="tree" match="recursiveDetectVariableDependence">
       <admst:return name="isDependent" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
   </admst:when>
   <admst:when test="[datatypename='mapply_unary']">
     <admst:apply-templates select="arg1" match="recursiveDetectVariableDependence">
       <admst:return name="isDependent" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
   </admst:when>
   <admst:when test="[datatypename='mapply_binary']">
     <admst:apply-templates select="arg1" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:apply-templates select="arg2" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent2" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:choose>
       <admst:when test="[$isDependent1='yes' or $isDependent2='yes']">
         <admst:return name="isDependent" value="yes"/>
       </admst:when>
       <admst:otherwise>
         <admst:return name="isDependent" value="no"/>
       </admst:otherwise>
     </admst:choose>
   </admst:when>
   <admst:when test="[datatypename='mapply_ternary']">
     <admst:apply-templates select="arg1" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent1" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:apply-templates select="arg2" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent2" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:apply-templates select="arg3" match="recursiveDetectVariableDependence">
       <admst:variable name="isDependent3" value="%(returned('isDependent')/value)"/>
     </admst:apply-templates>
     <admst:choose>
       <admst:when test="[$isDependent1='yes' or $isDependent2='yes' or $isDependent3='yes']">
         <admst:return name="isDependent" value="yes"/>
       </admst:when>
       <admst:otherwise>
         <admst:return name="isDependent" value="no"/>
       </admst:otherwise>
     </admst:choose>
   </admst:when>
   <admst:otherwise>
     <admst:return name="isDependent" value="no"/>
   </admst:otherwise>
 </admst:choose>
 </admst:template>
<!--
 =================================================================-
 collectLimiters
 Given a module, create an "arobavar" (@limiters) containing all the
 assignments in which the verilog limiter function is called.
 Also, create another arobavar (@limitedProbes) containing just
 the probes that are limited by those assignments.
 This template is called early in processing, and the arrays it
 produces will be used to produce the various bits of code needed
 to implement voltage limiting in the device.

  Example:  <admst:apply-templates select="/module" match="collectLimiters"/>

  will result in there being a /module/@limiters and /module/@limitedProbes
 =================================================================-
-->

<admst:template match="collectLimiters">
  <admst:variable name="thisModule" select="%(.)"/>
  <admst:for-each select="assignment[rhs/function/name='\$limit']">
    <admst:push into="../@limiters" select="." onduplicate="ignore"/>
  </admst:for-each>
  <admst:for-each select="@limiters">
    <admst:for-each select="rhs/probe">
      <admst:value-to select="#limited" string="yes"/>
      <admst:if test="[../function/[name='\$limit']/arguments[2]/datatypename='string']">
        <admst:if test="[../function/[name='\$limit']/arguments[2]/value='typedpnjlim' or ../function/[name='\$limit']/arguments[2]/value='typedpnjlim_new' or ../function/[name='\$limit']/arguments[2]/value='typeddummy' or ../function/[name='\$limit']/arguments[2]/value='typedfetlim']">
          <admst:value-to select="#typed" string="yes"/>
        </admst:if>
      </admst:if>
      <admst:push into="$thisModule/@limitedProbes" select="." onduplicate="ignore"/>
    </admst:for-each>
  </admst:for-each>
</admst:template>

<!--
 =================================================================-
 collectCollapsibles
 This template is intended to be called very early in verilog processing.
 It runs through all contributions and tries to identify those that
 allow some node to be collapsed into another (i.e. contributions of the
 form "V(a,b) <+ 0;"
 If it locates such a collapsible, it adds a "#collapsible='yes'" variable
 to the node, and a "@collapsesTo" variable containing the node to which
 this one could collapse.
 In considering which node to collapse of a,b, if there's only one internal
 in the pair, that's the collapsible one.  If both are internal, it'll
 collapse the negative into the positive.
 =================================================================-
 -->
<admst:template match="collectCollapsibles">
  <admst:variable name="thisModule" select="%(.)"/>
  <admst:for-each select="$thisModule/contribution[lhs/discipline/potential=lhs/nature]">
    <admst:if test="[(rhs/datatypename='expression' and rhs/tree/datatypename='number' and (rhs/tree/value='0' or rhs/tree/value='0.0')) or (rhs/datatypename='number' and (rhs/value='0' or rhs/value='0.0'))]">
      <admst:choose>
        <admst:when test="lhs/branch[grounded='no']">
          <admst:choose>
            <admst:when test="lhs/branch/nnode[location='internal']">
              <!-- <admst:warning format="collectCollapsibles found internal nnode %(lhs/branch/nnode/name) it wants to collapse into %(lhs/branch/pnode/name)\n"/> -->
              <!-- nnode is internal, collapse it into pnode -->
              <admst:if test="[exists(lhs/branch/nnode/#collapsible) and lhs/branch/nnode/#collapsible='yes']">
                <!-- nnode is already collapsible to something, so don't just
                     blindly collapse it to pnode... check that pnode is
                     not collapsible, and collapse p into n if not -->
                <!-- <admst:warning format="    %(lhs/branch/nnode/name) is already collapsible...\n"/> -->
                <admst:choose>
                  <admst:when test="[not(exists(lhs/branch/pnode/#collapsible))]">
                    <!-- <admst:warning format="    but %(lhs/branch/pnode/name) is not collapsible...\n"/> -->
                    <admst:choose>
                      <admst:when test="[lhs/branch/pnode/name=lhs/branch/nnode/@collapsesTo/name]">
                        <!-- <admst:warning format="But that is OK, because we were already going to do that collapsing!\n"/> -->
                      </admst:when>
                      <admst:when test="lhs/branch/pnode[location='external']">
                        <!-- <admst:warning format="     unfortunately, that is external... rearranging\n"/> -->
                        <!-- <admst:warning format="     we will make %(lhs/branch/nnode/@collapsesTo/name) collapse to %(lhs/branch/nnode/name) instead, and make %(lhs/branch/nnode/name) collapse to %(lhs/branch/pnode/name) instead\n"/> -->
                        <admst:variable name="saveCollapse" select="%(lhs/branch/nnode/@collapsesTo)"/>
                        <admst:if test="[exists($saveCollapse/#collapsible)]">
                          <admst:error format="fatal error --- tried to rearrange collapsing of %(lhs/branch/nnode/name) and %($saveCollapse/name) but the latter is already collapsible.\n"/>
                        </admst:if>
                        <admst:value-to select="$saveCollapse/#collapsible" string="yes"/>
                        <admst:push into="$saveCollapse/@collapsesTo" onduplicate="ignore" select="lhs/branch/nnode"/>
                        <admst:reset select="lhs/branch/nnode/@collapsesTo"/>
                        <admst:push into="lhs/branch/nnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/pnode"/>
                      </admst:when>
                      <admst:otherwise>
                        <admst:value-to select="lhs/branch/pnode/#collapsible" string="yes"/>
                        <admst:push into="lhs/branch/pnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/nnode"/>
                      </admst:otherwise>
                    </admst:choose>
                  </admst:when>
                  <admst:otherwise>
                    <admst:error format="Not yet supported: collapsing a node multiply... both %(lhs/branch/nnode/name) and %(lhs/branch/pnode/name) are already collapsible.  %(lhs/branch/nnode/name) collapses already into %(lhs/branch/nnode/@collapsesTo) and %(lhs/branch/pnode/name) collapses already into %(lhs/branch/pnode/@collapsesTo)\n"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:if>
              <admst:if test="[not(exists(lhs/branch/nnode/#collapsible))]">
                <!-- nnode is not already collapsible, collapse it into p -->
                <admst:value-to select="lhs/branch/nnode/#collapsible" string="yes"/>
                <admst:push into="lhs/branch/nnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/pnode"/>
              </admst:if>
            </admst:when>
            <admst:when test="lhs/branch/pnode[location='internal']">
              <!-- we only get here if nnode was external -->
              <admst:value-to select="lhs/branch/pnode/#collapsible" string="yes"/>
              <admst:push into="lhs/branch/pnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/nnode"/>
            </admst:when>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:warning format="Not yet supported in collectCollapsibles: collapsing node to ground\n"/>
          <!-- Even though nothing downstream of this will work, let's
               at least push the machinery a little.  Find the node that's
               not ground, and mark it as collapsing to ground -->
          <admst:warning format="    Generated code will not be correct.  \n"/>

          <admst:choose>
            <admst:when test="lhs/branch/nnode/[grounded='yes']">
              <admst:value-to select="lhs/branch/pnode/#collapsible" string="yes"/>
              <admst:push into="lhs/branch/pnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/nnode"/>
            </admst:when>
            <admst:when test="lhs/branch/pnode/[grounded='yes']">
              <admst:value-to select="lhs/branch/nnode/#collapsible" string="yes"/>
              <admst:push into="lhs/branch/nnode/@collapsesTo" onduplicate="ignore" select="lhs/branch/pnode"/>
            </admst:when>
          </admst:choose>

        </admst:otherwise>
      </admst:choose>
    </admst:if>
  </admst:for-each>
</admst:template>

<!--
 =================================================================-
 declareCollapsibleBools
 For each node that may be collapsed, generate a declaration of a bool
 that will be used by Xyce to tell whether to collapse it or not.
 Pass the module in the select field of the apply-templates call.
 =================================================================-
 -->
<admst:template match="declareCollapsibleBools">
  <admst:if test="[count(node[#collapsible='yes'])>0]">
    <admst:text format="     // bools for collapsing nodes\n"/>
    <admst:for-each select="node[#collapsible='yes']">
      <admst:text format="     bool collapseNode_%(name);\n"/>
    </admst:for-each>
  </admst:if>
</admst:template>

<!--
 =================================================================-
 evaluateCollapse
 This runs through an element and outputs code only for assignments
 that depend only on constants, conditionals depending only on constants,
 and contributions into voltages (only to set a collapsible bool)
 =================================================================-
 -->

<admst:template match="evaluateCollapse">
  <admst:choose>

    <!--WHILE-->
    <admst:when test="[datatypename='whileloop']">
      <admst:variable name="whileblockOutput" select=""/>
      <admst:variable name="whileOutput" select=""/>
      <admst:apply-templates select="whileblock" match="evaluateCollapse">
        <admst:value-of select="returned('outputSomething')/value"/>
        <admst:variable name="whileblockOutputSomething" select="%s"/>
        <admst:value-of select="returned('output')/value"/>
        <admst:variable name="whileblockOutput" select="%s"/>
        <admst:if test="[$whileblockOutputSomething = 'yes']">
          <admst:variable name="whileblockOutput" string="%($whileblockOutput)\n"/>
        </admst:if>
      </admst:apply-templates>
      <admst:apply-templates select="while" match="evaluateCollapse">
        <admst:value-of select="returned('outputSomething')/value"/>
        <admst:variable name="whileOutputSomething" select="%s"/>
        <admst:value-of select="returned('output')/value"/>
        <admst:variable name="whileOutput" select="%s"/>
      </admst:apply-templates>
      <admst:choose>
        <admst:when test="[$whileblockOutputSomething='yes' or $whileOutputSomething='yes']">
          <admst:return name="outputSomething" string="yes"/>
          <admst:return name="output" string="%($whileblockOutput)$(whileOutput)"/>
        </admst:when>
        <admst:otherwise>
          <admst:return name="outputSomething" string="no"/>
          <admst:return name="output" string=""/>
        </admst:otherwise>
      </admst:choose>

    </admst:when>

    <!--FOR-->
    <!-- KLUDGE:  The "evaluateCollapse" template is a mess, and invariably
         outputs completely useless junk that has to be hand-edited out
         anyway.  Odds are extremely good that any forloop encountered
         will be among the stuff that really doesn't belong.  So just don't
         do anything.  -->
    <admst:when test="[datatypename='forloop']">
      <admst:return name="outputSomething" string="no"/>
      <admst:return name="output" string=""/>
    </admst:when>


    <!--IF/ELSE-->
    <admst:when test="[datatypename='conditional']">
      <admst:choose>
        <admst:when test="if[nilled(variable[OPdependent='yes'])]">
          <admst:choose>
            <admst:when test="if/math[dependency='constant']">
              <admst:variable name="thenOutputSomething" string="no"/>
              <admst:variable name="thenOutput" string=""/>
              <admst:variable name="elseOutputSomething" string="no"/>
              <admst:variable name="elseOutput" string=""/>
              <admst:apply-templates select="then" match="evaluateCollapse">
                <admst:value-of select="returned('outputSomething')/value"/>
                <admst:variable name="thenOutputSomething" select="%s"/>
                <admst:value-of select="returned('output')/value"/>
                <admst:variable name="thenOutput" select="%s"/>
              </admst:apply-templates>
              <admst:if test="[exists(else)]">
                <admst:apply-templates select="else" match="evaluateCollapse">
                  <admst:value-of select="returned('outputSomething')/value"/>
                  <admst:variable name="elseOutputSomething" select="%s"/>
                  <admst:value-of select="returned('output')/value"/>
                  <admst:variable name="elseOutput" select="%s"/>
                </admst:apply-templates>
              </admst:if>

              <admst:if test="[$thenOutputSomething='yes']">
                <admst:variable name="output" string="if (%(processTerm(if)/[name='returnedExpression']/value))"/>
                <admst:variable name="output" string="$output\n{\n$thenOutput\n}\n"/>
                <admst:if test="[$elseOutputSomething='yes']">
                  <admst:variable name="output" string="$output\nelse\n{\n$elseOutput\n}\n"/>
                </admst:if>
                <admst:variable name="outputSomething" string="yes"/>
              </admst:if>
              <admst:if test="[$thenOutputSomething='no' and $elseOutputSomething='yes']">
                <admst:variable name="output" string="if (!(%(processTerm(if)/[name='returnedExpression']/value)))"/>
                <admst:variable name="output" string="$output\n{\n$elseOutput\n}\n"/>
              </admst:if>

              <admst:choose>
                <admst:when test="[$thenOutputSomething='yes' or $elseOutputSomething='yes']">
                  <admst:return name="outputSomething" string="yes"/>
                  <admst:return name="output" string="$output"/>
                </admst:when>
                <admst:otherwise>
                  <admst:return name="outputSomething" string="no"/>
                  <admst:return name="output" string=""/>
                </admst:otherwise>
              </admst:choose>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="thenOutputSomething" string="no"/>
              <admst:variable name="thenOutput" string=""/>
              <admst:variable name="elseOutputSomething" string="no"/>
              <admst:variable name="elseOutput" string=""/>
              <admst:apply-templates select="then" match="evaluateCollapse">
                <admst:value-of select="returned('outputSomething')/value"/>
                <admst:variable name="thenOutputSomething" select="%s"/>
                <admst:value-of select="returned('output')/value"/>
                <admst:variable name="blockOutput" select="%s"/>
                <admst:if test="[$thenOutputSomething = 'yes']">
                  <admst:variable name="thenOutput" string="%($blockOutput)\n"/>
                </admst:if>
              </admst:apply-templates>
              <admst:apply-templates select="else" match="evaluateCollapse">
                <admst:value-of select="returned('outputSomething')/value"/>
                <admst:variable name="elseOutputSomething" select="%s"/>
                <admst:value-of select="returned('output')/value"/>
                <admst:variable name="blockOutput" select="%s"/>
                <admst:if test="[$elseOutputSomething = 'yes']">
                  <admst:variable name="outputSomething" string="yes"/>
                  <admst:variable name="elseOutput" string="%($blockOutput)"/>
                </admst:if>
              </admst:apply-templates>
              <admst:variable name="output" string="%($thenOutput)%($elseOutput)"/>
              <admst:choose>
                <admst:when test="[$thenOutputSomething='yes' or $elseOutputSomething='yes']">
                  <admst:return name="outputSomething" string="yes"/>
                  <admst:return name="output" string="$output"/>
                </admst:when>
                <admst:otherwise>
                  <admst:return name="outputSomething" string="no"/>
                  <admst:return name="output" string=""/>
                </admst:otherwise>
              </admst:choose>

            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:return name="outputSomething" string="no"/>
          <admst:return name="output" string=""/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>

    <!--CONTRIBUTION-->
    <admst:when test="[datatypename='contribution']">
      <admst:choose>
        <admst:when test="lhs[discipline/potential=nature]">
          <admst:choose>
            <admst:when test="lhs/branch[grounded='no']">
              <admst:if test="[exists(lhs/branch/nnode/#collapsible) and lhs/branch/nnode/#collapsible='yes' and lhs/branch/nnode/@collapsesTo=lhs/branch/pnode]">
                <admst:return name="output" string="collapseNode_%(lhs/branch/nnode/name) = true;\n"/>
                <admst:return name="outputSomething" string="yes"/>
              </admst:if>
              <admst:if test="[exists(lhs/branch/pnode/#collapsible) and lhs/branch/pnode/#collapsible='yes' and lhs/branch/pnode/@collapsesTo=lhs/branch/nnode]">
                <admst:return name="output" string="collapseNode_%(lhs/branch/pnode/name) = true;\n"/>
                <admst:return name="outputSomething" string="yes"/>
              </admst:if>

            </admst:when>
            <admst:otherwise>
              <admst:warning format="Unsupported feature, collapsing node to ground in contribution %(.)\n"/>
              <admst:return name="output" string="//should collapse %(lhs/branch/nnode/name)  and %(lhs/branch/pnode/name) \n"/>
              <admst:return name="outputSomething" string="yes"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:return name="output" string=""/>
          <admst:return name="outputSomething" string="no"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>

    <!--ASSIGNMENT-->
    <admst:when test="[datatypename='assignment']">
      <admst:choose>
        <admst:when test="[(lhs/insource='yes') and (lhs/OPdependent='no')]">
          <admst:return name="output" string="%(processTerm(lhs)/[name='returnedExpression']/value) = %(processTerm(rhs)/[name='returnedExpression']/value);\n"/>
          <admst:return name="outputSomething" string="yes"/>
        </admst:when>
        <admst:otherwise>
          <admst:return name="output" string=""/>
          <admst:return name="outputSomething" string="no"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>

    <!--BLOCK-->
    <admst:when test="[datatypename='block']">
      <admst:value-to select="./#tempOutput" value=""/>
      <admst:variable name="outputSomething" value="no"/>
      <admst:if test="[name != '']">
        <admst:value-to select="./#tempOutput" value="// begin block named %(name)\n"/>
      </admst:if>
<!--      <admst:warning format="Processing a block...%(.)\n"/> -->
      <admst:apply-templates select="item" match="evaluateCollapse">
<!--        <admst:warning format=" processed item %(.) in block %(../name)\n"/> -->
        <admst:value-of select="returned('outputSomething')/value"/>
        <admst:variable name="blockOutputSomething" select="%s"/>
        <admst:value-of select="returned('output')/value"/>
        <admst:variable name="blockOutput" select="%s"/>
<!--        <admst:warning format=" item %(.) in block %(../name) returned %($blockOutput) and blockOutputSomething=%($blockOutputSomething)\n"/> -->
        <admst:if test="[$blockOutputSomething = 'yes']">
          <admst:variable name="outputSomething" string="yes"/>
          <admst:variable name="tempOutput" select="%(../#tempOutput)\n$blockOutput"/>
<!--          <admst:warning format=" current tempOutput is %($tempOutput)\n"/> -->
          <admst:value-to select="../#tempOutput" value="$tempOutput"/>
<!--          <admst:warning format=" current #tempOutput is %(../#tempOutput)\n"/>-->
        </admst:if>
      </admst:apply-templates>
      <admst:variable name="output" select="%(./#tempOutput)"/>
      <admst:if test="[name != '']">
        <admst:variable name="output" select="%($output)\n// end block  named %(name)\n"/>
      </admst:if>
      <admst:choose>
        <admst:when test="[$outputSomething='yes']">
          <admst:return name="output" string="$output"/>
          <admst:return name="outputSomething" string="yes"/>
        </admst:when>
        <admst:otherwise>
          <admst:return name="output" string=""/>
          <admst:return name="outputSomething" string="no"/>
        </admst:otherwise>
      </admst:choose>
<!--      <admst:warning  format="   returning %($output), outputSomething is %($outputSomething)\n"/> -->
    </admst:when>


    <!--other stuff to ignore-->
    <admst:when test="[datatypename='expression' or datatypename='probe' or datatypename='variable' or datatypename='mapply_unary' or datatypename='mapply_binary' or datatypename='mapply_ternary' or datatypename='function' or datatypename='number' or datatypename='string' or datatypename='nilled' or datatypename='blockvariable' or datatypename='callfunction' or datatypename='case']">
      <admst:return name="output" string=""/>
      <admst:return name="outputSomething" string="no"/>
    </admst:when>

    <admst:otherwise>
      <admst:fatal format="%(datatypename): adms element not implemented\n"/>
    </admst:otherwise>
  </admst:choose>

  <!-- we have to clear this now, and it has to be after the return.
       If we clear it before the return, somehow $output gets cleared.  Is
       that because it's still tied to the memory location of #tempoutput?
       And if we do NOT clear it, we consume all available memory and puke
       on complex files. -->
  <admst:value-to select="./#tempOutput" value=""/>
</admst:template>

<!--
   =================================================================-
   collectExtraUnknowns
   Another "execute early in the processing" deal.
   Any use of "flow probes" requires an extra unknown (the flow through
   the branch).
   Any use of "potential sources" *also* requires an extra unknown (also
   the flow through the branch).
   These two cases also, naturally, require an additional equation.  There
   are multiple possibilities:

    A)  Flow probe used only in a flow source, without any associated
        contribution:
        I(b2) &lt;+ I(b1);
        In this case, the extra unknown is I(b1), and the extra equation is
          V(b1) = 0.

    B)  Flow probe used in a flow source, with an associated contribution:
        I(b1) &lt;+ expression;
        I(b2) &lt;+ A*I(b1);
        In this case, the extra unknown is I(b1), but the extra equation is:
          sum(contributions into I(b1)) -I(b1) = 0

    C)  Potential source
        V(B1) &lt;+ expression_not_referencing_the_branch_B1;
        Extra unknown is still I(B1), extra equation is:
          sum (all contributions into V(B1)) - V(B1) = 0

    D) Potential source referencing a flow probe:
        V(b1) &lt;+ expression;
        V(b2) &lt;+ A*I(B1)
        Extra unknown is I(B1), extra equation same as C

   Of course, each of these impacts the loads for the KCLs of the endpoints
   of B1 and B2.

      A) add/subtract I(B1) to endpoint nodes of B1
      B) add/subtract I(B1) to endpoint nodes of B1
      C) add/subtract I(B1) to endpoints of B1
      D) add/subtract I(B1) to endpoints of B1, use unknown I(B1) in
         equations for endpoints of B2.

   There are other cases, too, but these are already handled elsewhere.

   The purpose of this template is to figure out which new unknowns to
   allocate for, which is pretty easy (look for flow probes in the module's
   list of probes, and look for potential sources that aren't already flagged
   as collapsible (zero RHS) in the module's list of sources: each one
   means there has to be an associated current branch).

   Determining what type of *equation* to do really depends on the contribution
   involved.
   -->
<admst:template match="collectExtraUnknowns">
  <admst:variable name="thisModule" select="%(.)"/>
  <admst:reset select="$thisModule/@extraUnknowns"/>

  <!-- First find the extra unknowns due to flow probes -->
  <admst:for-each select="/module/probe[nature=discipline/flow]">
    <admst:push into="$thisModule/@extraUnknowns" select="branch" onduplicate="ignore"/>
    <admst:value-to select="#branchvar" string="yes" />
  </admst:for-each>

  <!-- Now find the extra unknowns due to potential sources -->
  <admst:for-each select="$thisModule/source[not(exists(branch/nnode/#collapsible)) and not(exists(branch/pnode/#collapsible)) and nature=discipline/potential]">
    <admst:push into="$thisModule/@extraUnknowns" select="branch" onduplicate="ignore"/>
  </admst:for-each>

  <!-- we now know the extra unknowns, which are all branches.  Unfortunately,
       ADMS does not store any information about this stuff in its "jacobian"
       structure, which makes life difficult for us.  So let us create our
       own data.  -->
  <!-- we'll make three arrays to help us figure out jacobian stuff

       we need a list of nodes
       that depend on branch variables.  We'll push the branch into the
       node. We handle this by pushing the list of branch dependencies
       into the actual node structure.

       We need  a list of branches that depend on nodal vars.
       This will let us create the jacobian row for the branch and fill it
       with nodal dependencies.  These will simply be put in an array
       inside the @extraUnknowns array called @nodeDeps.

       We need a list of branches that depend on branch vars.
       This will let us augment the branch equation rows.  This, too,
       will be stored in the @branchDeps array under the @extraUnknowns.
       -->
    <admst:for-each select="$thisModule/@extraUnknowns">
    <admst:variable name="thisBranch" select="%(.)"/>

      <admst:push into="pnode/@branchDeps" select="." onduplicate="ignore"/>
      <admst:if test="[nnode/grounded = 'no']">
        <admst:push into="nnode/@branchDeps" select="." onduplicate="ignore"/>
      </admst:if>

      <admst:apply-templates match="collectBranchDepends" select="."/>
      <admst:for-each select="/module/@countNodes">
        <admst:push into="$thisBranch/@nodeDeps" select="." onduplicate="ignore"/>
      </admst:for-each>
      <admst:for-each select="/module/@countBranches">
        <admst:push into="$thisBranch/@branchDeps" select="." onduplicate="ignore"/>
      </admst:for-each>
    </admst:for-each>

    <!-- Finally, we have an issue:  if a voltage source is uses, but
         the corresponding current probe is never used (such is done if
         one has a pure voltage source), then our process so far will never
         allocate a place for the current branch probe that we need to use in
         updateIntermediateVars.  So here, we'll go through our list of
         extra branch equations and make a list of branches for which there
         is no probe in the tree.  This will be used later to allocate what's
         missing. -->
    <admst:reset select="$thisModule/@extraProbeBranches"/>
    <admst:for-each select="$thisModule/@extraUnknowns">
      <admst:variable name="thePnodeName" select="%(pnode/name)"/>
      <admst:variable name="theNnodeName" select="%(nnode/name)"/>
      <admst:if test="[not(exists($thisModule/probe[nature=discipline/flow and branch/pnode/name=$thePnodeName and branch/nnode/name=$theNnodeName]))]">
        <admst:push into="$thisModule/@extraProbeBranches" select="." onduplicate="ignore"/>
      </admst:if>
    </admst:for-each>

<!--   Debugging output commented out

  <admst:for-each select="$thisModule/@extraUnknowns">
    // branch %(.) depends on nodes %(@nodeDeps)
    // branch %(.) depends on branches %(@branchDeps)

  </admst:for-each>

  <admst:for-each select="$thisModule/node[grounded='no']">
    <admst:if test="[not(nilled(@branchDeps))]">
      // Node %(.) depends on branches %(@branchDeps)

    </admst:if>
  </admst:for-each>
-->
</admst:template>


  <!--
   =================================================================-
   finishUpBranchEquations

   Branch equations are of the form:
     (sum of contributions into source) - (value of source) = 0

   Our contribution template does the sum part, but we now need to do
   the last bit.

    . must be a module
   =================================================================-
   -->
  <admst:template match="finishUpBranchEquations">

    <admst:variable name="thisModule" select="%(.)"/>
    <admst:for-each select="./contribution[lhs/nature=lhs/discipline/potential and not(rhs/tree/datatypename='number' and (rhs/tree/value='0' or rhs/tree/value='0.0'))]">

      <!-- The extra terms into the voltage nodes are only done once,
           and only into the static contributions. -->
      <admst:variable name="pnode" select="%(lhs/branch/pnode)"/>
      <admst:variable name="pnodeConstant" select="%(xyceNodeConstantName($pnode)/[name='nodeConstant']/value)"/>
      <admst:variable name="nnode" select="%(lhs/branch/nnode)"/>
      <admst:if test="[rhs/static='yes' or (rhs/dynamic='yes' and not(exists($thisModule/contribution[lhs/nature=lhs/discipline/potential and lhs/branch/pnode=$pnode and lhs/branch/nnode=$nnode and rhs/static='yes'])))]">
  // Additional term resulting from contributions into %(lhs)

        <admst:text format="staticContributions[$pnodeConstant] += probeVars[%(xyceFlowProbeConstantName(lhs/branch)/[name='probeConstant']/value)];\n"/>
        <admst:if test="$nnode[grounded='no']">
          <admst:variable name="nnodeConstant" select="%(xyceNodeConstantName($nnode)/[name='nodeConstant']/value)"/>
          <admst:text format="staticContributions[$nnodeConstant] -= probeVars[%(xyceFlowProbeConstantName(lhs/branch)/[name='probeConstant']/value)];\n"/>
        </admst:if>
      </admst:if>
    </admst:for-each>

    <admst:for-each select="./@extraUnknowns">
      <!-- There is one special case:  a branch where the
           flow probe is used AND there is a flow source for it.
            In this case the branch equation is
              (sum of contributions into I(branch)) - I(branch) =0

            In all other cases, the branch equation will always be:
              (sum of contributions into V(branch)) - V(branch) = 0
       -->
       <admst:text format="  // Final term for branch equation %(xyceBranchConstantName(.)/[name='branchConstant']/value) \n"/>
  <admst:variable name="thePnodeName" select="%(pnode/name)"/>
  <admst:variable name="theNnodeName" select="%(nnode/name)"/>
       <admst:choose>
         <admst:when test="[exists(/module/contribution[lhs/branch/pnode/name='$thePnodeName' and lhs/branch/nnode/name='$theNnodeName' and lhs/nature=lhs/discipline/flow])]">
           <admst:text format="  staticContributions[%(xyceBranchConstantName(.)/[name='branchConstant']/value)] -= probeVars[%(xyceFlowProbeConstantName(.)/[name='probeConstant']/value)];\n"/>
         </admst:when>
         <admst:otherwise>
           <!-- ICK.  In this case, we don't usually HAVE a probe variable,
                and so we must calculate the drop V(branch) directly.
                We can't rely on Sacado to do derivatives w.r.t. this,
                and will have to have a manual +/- dependence in the
                branch's static jacobian. -->
           <admst:text format="  staticContributions[%(xyceBranchConstantName(.)/[name='branchConstant']/value)] -= (*solVectorPtr)[%(xyceNodeLIDVariable(./pnode))]"/>
           <admst:if test="[nnode/grounded='no']">
             <admst:text format="-(*solVectorPtr)[%(xyceNodeLIDVariable(./nnode))]"/>
           </admst:if>
         <admst:text format=";\n"/>
         </admst:otherwise>
       </admst:choose>

    </admst:for-each>
  </admst:template>

  <!--
   =================================================================-
   verilog2CXXtype
     given an admst data tree node, return the C++ datatype
     corresponding to its type
    The node passed in is usually a variable
   =================================================================-
  -->
  <admst:template match="verilog2CXXtype">
    <admst:choose>
      <admst:when test="[type='integer']">
        <admst:text format="int"/>
      </admst:when>
      <admst:when test="[type='real']">
        <admst:text format="double"/>
      </admst:when>
      <admst:when test="[type='string']">
        <admst:text format="string"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="should not be reached\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>

  <!--
   =================================================================-
   processTerm
   given any node, run the associated template over it
   =================================================================-
  -->
  <admst:template match="processTerm" >
    <admst:apply-templates select="." match="%(adms/datatypename)">
      <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
    </admst:apply-templates>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>

  <!--
   =================================================================-
   printTerm
   given any node, run the associated template over it and print
   =================================================================-
  -->
  <admst:template match="printTerm" >
    <admst:apply-templates select="." match="%(adms/datatypename)">
      <admst:text format="%(returned('returnedExpression')/value)"/>
    </admst:apply-templates>
  </admst:template>

  <!--
   =================================================================-
   handling of expression
   expression
   This template returns the expression passed to it in the select
   field
   It processes each element of the tree using a template of the
   same name as the datatype name.

   To understand what it's doing, be aware that the datatypenames
   that typically end up in the tree  are things like number,
   mapply_binary, mapply_unary, expression (implying recursion back
   into this template), ... (fill in, it would be good for this
   comment to document all the templates we can call)

   Each of the templates called does little more than return the C++
   representation of that type of data, and when we return the entire
   expression will be printed in C++
   =================================================================-
  -->
  <admst:template match="expression">
    <admst:apply-templates select="tree" match="%(adms/datatypename)" required="yes">
      <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
    </admst:apply-templates>
    <admst:return name="returnedExpression" value="$expression"/>

  </admst:template>

  <!--
   =================================================================-
   number
   Print out a number, properly accounting for scaling unit suffixes
   =================================================================-
  -->
  <admst:template match="number">
    <admst:value-of select="value"/>
    <admst:choose>
      <admst:when test="[scalingunit='1']"><admst:return name="returnedExpression" value="%s"/></admst:when>
      <admst:when test="[scalingunit='E']"><admst:return name="returnedExpression" value="(%s*1.0e+18)"/></admst:when>
      <admst:when test="[scalingunit='P']"><admst:return name="returnedExpression" value="%s*1.0e+15"/></admst:when>
      <admst:when test="[scalingunit='T']"><admst:return name="returnedExpression" value="%s*1.0e+12"/></admst:when>
      <admst:when test="[scalingunit='G']"><admst:return name="returnedExpression" value="%s*1.0e+9"/></admst:when>
      <admst:when test="[scalingunit='M']"><admst:return name="returnedExpression" value="%s*1.0e+6"/></admst:when>
      <admst:when test="[scalingunit='k']"><admst:return name="returnedExpression" value="%s*1.0e+3"/></admst:when>
      <admst:when test="[scalingunit='h']"><admst:return name="returnedExpression" value="%s*1.0e+2"/></admst:when>
      <admst:when test="[scalingunit='D']"><admst:return name="returnedExpression" value="%s*1.0e+1"/></admst:when>
      <admst:when test="[scalingunit='d']"><admst:return name="returnedExpression" value="%s*1.0e-1"/></admst:when>
      <admst:when test="[scalingunit='c']"><admst:return name="returnedExpression" value="%s*1.0e-2"/></admst:when>
      <admst:when test="[scalingunit='m']"><admst:return name="returnedExpression" value="%s*1.0e-3"/></admst:when>
      <admst:when test="[scalingunit='u']"><admst:return name="returnedExpression" value="%s*1.0e-6"/></admst:when>
      <admst:when test="[scalingunit='n']"><admst:return name="returnedExpression" value="%s*1.0e-9"/></admst:when>
      <admst:when test="[scalingunit='A']"><admst:return name="returnedExpression" value="%s*1.0e-10"/></admst:when>
      <admst:when test="[scalingunit='p']"><admst:return name="returnedExpression" value="%s*1.0e-12"/></admst:when>
      <admst:when test="[scalingunit='f']"><admst:return name="returnedExpression" value="%s*1.0e-15"/></admst:when>
      <admst:when test="[scalingunit='a']"><admst:return name="returnedExpression" value="%s*1.0e-18"/></admst:when>
      <admst:otherwise>
        <admst:value-of select="scalingunit"/>
        <admst:fatal format="%s%s: scaling unit not supported\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>

  <!--
   =================================================================-
   mapply_unary
   This template handles unary operators, printing out the result
   surrounded by parentheses
   =================================================================-
  -->
  <admst:template match="mapply_unary">
    <admst:if test="[name='plus']"> <admst:variable name="op" select="+"/> </admst:if>
    <admst:if test="[name='minus']"> <admst:variable name="op" select="-"/> </admst:if>
    <admst:if test="[name='not']"> <admst:variable name="op" select="!"/> </admst:if>
    <admst:if test="[name='bw_not']"> <admst:variable name="op" select="~"/> </admst:if>
    <admst:value-of select="arg1/adms/datatypename"/>
    <admst:apply-templates select="arg1" match="%s" required="yes">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="expression" select="($op%s)"/>
    </admst:apply-templates>

    <admst:return name="returnedExpression" value="$expression"/>

  </admst:template>

  <!--
   =================================================================-
   mapply_binary
   This template handles binary operators, printing out the C++
   version surrounded by parentheses
   =================================================================-
  -->
  <admst:template match="mapply_binary">
    <admst:apply-templates select="arg1" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a1" select="%s"/>
    </admst:apply-templates>
    <admst:apply-templates select="arg2" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a2" select="%s"/>
    </admst:apply-templates>

    <admst:choose>
      <!-- addition -->
      <admst:when test="[name='addp']">
        <admst:choose>
          <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
            <admst:variable name="expression" select="0.0"/>
          </admst:when>
          <admst:when test="[arg1/math/value=0.0]">
            <admst:variable name="expression" select="(+%($a2))"/>
          </admst:when>
          <admst:when test="[arg2/math/value=0.0]">
            <admst:variable name="expression" select="(%($a1))"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="($a1+$a2)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <!-- subtraction -->
      <admst:when test="[name='addm']">
        <admst:choose>
          <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
            <admst:variable name="expression" select="0.0"/>
          </admst:when>
          <admst:when test="[arg1/math/value=0.0]">
            <admst:variable name="expression" select="(-%($a2))"/>
          </admst:when>
          <admst:when test="[arg2/math/value=0.0]">
            <admst:variable name="expression" select="(%($a1))"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="($a1-$a2)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multtime']">
        <admst:choose>
          <admst:when test="[(arg1/math/value=0.0)or(arg2/math/value=0.0)]">
            <admst:variable name="expression" select="0.0"/>
          </admst:when>
          <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:variable name="expression" select="1.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="($a1*$a2)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <admst:choose>
          <admst:when test="[arg1/math/value=0.0]">
            <admst:variable name="expression" select="0.0"/>
          </admst:when>
          <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
            <admst:variable name="expression" select="1.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="($a1/$a2)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="expression" select="($a1%(bname(.)/[name='bname']/value)$a2)"/>
      </admst:otherwise>
    </admst:choose>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>

  <!--
   =================================================================-
   mapply_ternary
   Given a ternary operator (cond)?yes:no
   format for C++
   Note: this will fail badly if any of the things involved are FAD
   types.  FIXME!
   =================================================================-
  -->
  <admst:template match="mapply_ternary">
    <admst:apply-templates select="arg1" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a1" select="%s"/>
    </admst:apply-templates>
    <admst:apply-templates select="arg2" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a2" select="%s"/>
    </admst:apply-templates>
    <admst:apply-templates select="arg3" match="processTerm">
      <admst:value-of select="returned('returnedExpression')/value"/>
      <admst:variable name="a3" select="%s"/>
    </admst:apply-templates>
    <admst:variable name="expression" select="($a1?$a2:$a3)"/>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>

  <!--
   =================================================================-
   assignment
   Given an assignment, format it for C++

   Special Case:  If the assignment happens to be one that uses
   $limit, we don't emit anything.  Those special things are handled
   differently.
   =================================================================-
  -->
  <admst:template match="assignment">
    <admst:assert test="adms[datatypename='assignment']" format="assignment template called with something that is not an assignment\n"/>
    <admst:choose>
    <admst:when test="[nilled(rhs/function/[name='\$limit'])]">
      <admst:variable name="saveTemplateUse" select="$globalMustUseTemplate"/>
      <admst:variable name="saveScalarForce" select="$globalMustForceScalar"/>
      <!-- if the lhs has any probe dependence recorded, then it's a Fad type -->
      <admst:if test="lhs/probe">
        <admst:variable name="globalMustUseTemplate" select="yes"/>
      </admst:if>
      <!-- Bleh.  Sometimes, even if the lhs is not probe dependent, the
           rhs could depend on a variable that is *sometimes*
           probe-dependent but isn't at the moment (as, for example,
           when a temporary variable is sometimes used to store the
           results of probe-dependent computations, and sometimes just
           plain constant expressions).  In this case, both lhs/probe
           and rhs/probe are nilled because the overall rhs expression
           has no probe dependence, but some variable in it has a
           non-nilled probe:  That means that the RHS has a Fad typed
           variable in it, that the current value stored in that
           variable has NO dependence on any probes, but the LHS is a
           double.  This requires that we generate all references to the
           Fad Variable with ".val() calls. -->
      <admst:if test="[nilled(lhs/probe) and nilled(rhs/probe)]">
        <admst:variable name="globalMustForceScalar" select="yes"/>
      </admst:if>
      <admst:text format="%(printTerm(lhs)) = %(printTerm(rhs));\n"/>
      <admst:variable name="globalMustUseTemplate" select="$saveTemplateUse"/>
      <admst:variable select="$saveScalarForce" name="globalMustForceScalar"/>
    </admst:when>
    <admst:otherwise>
      <admst:apply-templates select="." match="limiterAssignment"/>
    </admst:otherwise>
    </admst:choose>
  </admst:template>

  <!--
   =================================================================-
   limiterAssignment
   Handle special case output for assignments that involve limiters
   These require lots of extra output, and it's only part of the deal.
   =================================================================-
  -->
  <admst:template match="limiterAssignment">
    <admst:text format="\n\n//%(printTerm(lhs)) = %(rhs);\n"/>
    <admst:text format="if (getDeviceOptions().voltageLimiterFlag)\n"/>
    <admst:text format="{\n"/>
    <admst:text format="  int icheck=0;\n"/>
    <admst:choose>
      <admst:when test="[rhs/function[name='\$limit']/arguments[2]/datatypename='string']">
        <admst:choose>
          <!-- the string could be "pnjlim" or "fetlim" -->
          <admst:when test="[rhs/function[name='\$limit']/arguments[2]/value='pnjlim' or rhs/function[name='\$limit']/arguments[2]/value='typedpnjlim']">
            <!-- handle "pnjlim" -->
            <admst:text format="  %(printTerm(lhs))_limited = devSupport.pnjlim(%(printTerm(lhs))_limited,%(printTerm(lhs))_old,%(printTerm((rhs/function[name='\$limit']/arguments[3]))),%(printTerm((rhs/function[name='\$limit']/arguments[4]))),&amp;icheck);\n"/>
          </admst:when>
          <admst:when test="[rhs/function[name='\$limit']/arguments[2]/value='pnjlim_new' or rhs/function[name='\$limit']/arguments[2]/value='typedpnjlim_new']">
            <!-- handle "pnjlim_new" -->
            <admst:text format="  %(printTerm(lhs))_limited = devSupport.pnjlim_new(%(printTerm(lhs))_limited,%(printTerm(lhs))_old,%(printTerm((rhs/function[name='\$limit']/arguments[3]))),%(printTerm((rhs/function[name='\$limit']/arguments[4]))),&amp;icheck);\n"/>
          </admst:when>
        <!-- if "fetlim" we would do something else, but for now nothing... -->
          <admst:when test="[rhs/function[name='\$limit']/arguments[2]/value='fetlim' or rhs/function[name='\$limit']/arguments[2]/value='typedfetlim']">
            <admst:warning format="Warning: fetlim not implemented, ignoring."/>
          </admst:when>
          <admst:when test="[rhs/function[name='\$limit']/arguments[2]/value='dummy' or rhs/function[name='\$limit']/arguments[2]/value='typeddummy']">
            <admst:text format="  // dummy limiting for initialization purposes\n"/>
          </admst:when>
<!-- KLUDGE ALERT!  ADMS has a bug.  It does not properly allow us to
     pass the name of the analog function to the $limit function as it
     should, and pukes an error saying "identifier never declared."
     To get something usable, I am going to support passing a string
     other than pnjlim or fetlim, and treat it as an analog function
     name if so.  This is NOT standard verilog and needs fixing. -->

          <admst:otherwise>
            <admst:text format="  %(printTerm(lhs))_limited = model_.analogFunctions.%(rhs/function[name='\$limit']/arguments[2]/value)(%(printTerm(lhs))_limited,%(printTerm(lhs))_old"/>
            <admst:if test="[count(rhs/function[name='\$limit']/arguments)>2]">
              <admst:text format=","/>
              <admst:join select="rhs/function[name='\$limit']/arguments[position(.)>2]" separator=",">
                <admst:text format="%(printTerm(.))"/>
              </admst:join>
            </admst:if>
            <admst:text format=");\n"/>
            <admst:text format="if (%(printTerm(lhs))_limited != %(printTerm(lhs))_orig)\n"/>
            <admst:text  format="{\n"/>
            <admst:text  format="icheck=1;\n"/>
            <admst:text  format="}\n"/>
          </admst:otherwise>

        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:text format="  %(printTerm(lhs))_limited = model_.analogFunctions.%(rhs/function[name='\$limit']/arguments[2])((%(printTerm(lhs))_limited,%(printTerm(lhs))_old"/>
        <admst:if test="[count(rhs/function[name='\$limit']/arguments)>2]">
          <admst:text format=","/>
          <admst:join select="rhs/function[name='\$limit']/arguments[position(.)>2]" separator=",">
            <admst:text format="%(printTerm(.))"/>
          </admst:join>
        </admst:if>
        <admst:text format=");\n"/>
      </admst:otherwise>
    </admst:choose>
    <admst:text format="  if (icheck == 1)\n"/>
    <admst:text format="     origFlag = false;\n"/>

    <admst:text format="  if (!origFlag)\n  {\n"/>
    <admst:text format="    probeDiffs[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)] = %(printTerm(lhs))_limited - %(printTerm(lhs))_orig;\n"/>
    <admst:text format="    probeVars[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)] += probeDiffs[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)];\n"/>
    <admst:text format="  }\n"/>
    <admst:text format="}\n"/>
    <admst:text format="%(printTerm(lhs)) = probeVars[%(xyceProbeConstantName(rhs/function[name='\$limit']/arguments[1])/[name='probeConstant']/value)];\n\n"/>
  </admst:template>
<!--
   =================================================================-
   contribution
   Given a contribution, format it for xyce's updateIntermediateVars

   This template is complicated by the need to compute Jdxp terms
   when we are working with any RHS that involves limited probes.
   =================================================================-
  -->
  <admst:template match="contribution">
    <!-- Do sanity check to make sure we're actually processing a contribution
    -->
    <admst:assert test="adms[datatypename='contribution']" format="contribution template called with something that is not a contribution\n"/>

    <!-- Error out if this module uses contribution types we don't grok -->
    <!--
    <admst:if test="[lhs/discipline/potential=lhs/nature and rhs/datatypename='expression' and not(rhs/tree/datatypename='number' and (rhs/tree/value='0' or rhs/tree/value='0.0'))]">
      <admst:error format="this version of the Xyce ADMS interface does not support contributions into voltages unless one is setting them to 0 or 0.0.  Attempt to do %(lhs) &lt; %(rhs) failed\n"/>
    </admst:if>
    -->

    <!-- force template functions used on rhs to be explicitly instantiated -->
    <admst:variable name="saveTemplateUse" select="$globalMustUseTemplate"/>
    <admst:variable name="globalMustUseTemplate" select="yes"/>

    <!-- actual contribution processing done here -->
    <admst:text format="// %(lhs) &lt;+ %(rhs)\n"/>

    <!-- static and dynamic go to different places (F vs. Q) -->
    <admst:choose>
      <admst:when test="[dynamic='yes']">
        <admst:variable name="mode" select="dynamic"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="mode" select="static"/>
      </admst:otherwise>
    </admst:choose>


    <admst:choose>

      <!-- Contributions into potential sources with rhs 0 are only
           used for node collapse in set-up, so do nothing -->
      <admst:when test="[lhs/discipline/potential=lhs/nature and (rhs/tree/datatypename='number' and (rhs/tree/value='0' or rhs/tree/value='0.0'))]">
        <admst:text format="// do nothing at all\n"/>
      </admst:when>

      <!-- Contributions into potential sources that are nonzero are
           really different.  In this case, we add/subtract the
           associated branch current from the pos and negative nodes,
           and also add to the branch equation -->
      <admst:when test="[lhs/discipline/potential=lhs/nature]">

        <!-- Positive and negative nodes get +/- the branch variable value -->
        <!-- But this is not done once for every contribution to a source,
             just once for each source!  So these terms will be done
             in the same finish-up operation mentioned below -->
        <admst:variable name="branchConstant" select="%(xyceBranchConstantName(lhs/branch)/[name='branchConstant']/value)"/>

        <admst:choose>
          <admst:when test="[count(module/@limitedProbes)>0 and not(nilled(rhs/probe/[#limited='yes']))]">
            <!-- Special processing when RHS involves limited probes -->
            <admst:text format="{\n"/>
            <admst:text format="AdmsFadType contribTemp;\n"/>
            <admst:text format="contribTemp = %(printTerm(rhs));\n"/>
            <admst:text format="%($mode)Contributions[%($branchConstant)] += contribTemp;\n"/>
            <admst:text format="Jdxp_%($mode)[$branchConstant] += "/>
            <admst:join select="rhs/probe[#limited='yes']" separator="+">
              <admst:text format="contribTemp.dx(%(xyceProbeConstantName(.)/[name='probeConstant']/value))*probeDiffs[%(xyceProbeConstantName(.)/[name='probeConstant']/value)]*probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)].dx(%(xyceProbeConstantName(.)/[name='probeConstant']/value))"/>
            </admst:join>
            <admst:text format=";\n"/>

          </admst:when>

          <admst:otherwise>
            <!-- this is the simple case, no limiting needed -->
            <!-- Branch equation gets + the RHS -->
            <admst:text format="%($mode)Contributions[%($branchConstant)] += %(printTerm(rhs));\n"/>
          </admst:otherwise>
        </admst:choose>

        <!-- There is one last contribution necessary, but we don't do it here.
             The branch equation also needs to get - the potential
             from the solution, but it should only get this once, and there
             could be multiple contributions to this potential.  We'll
             have to do it in a finish-up loop later -->
      </admst:when>

      <!-- Otherwise it's a contribution into flow source, which is
           the most most straightforward case -->
      <admst:otherwise>
        <!-- do nothing if a noise term -->
        <admst:if test="[whitenoise='no' and flickernoise='no']">
          <admst:variable name="pnode" select="%(lhs/branch/pnode)"/>
          <admst:variable name="pnodeConstant" select="%(xyceNodeConstantName($pnode)/[name='nodeConstant']/value)"/>
          <admst:variable name="nnode" select="%(lhs/branch/nnode)"/>
          <!-- special processing when contribution RHS involves limited
               probes.  We must compute the rhs of the contribution,
               but also generate the Jdxp terms-->
          <admst:choose>
            <admst:when test="[count(module/@limitedProbes)>0 and not(nilled(rhs/probe/[#limited='yes']))]">
              <admst:text format="{\n"/>
              <admst:text format="AdmsFadType contribTemp;\n"/>
              <admst:text format="contribTemp= %(printTerm(rhs));\n"/>
              <admst:text format="%($mode)Contributions[$pnodeConstant] += contribTemp;\n"/>
              <admst:if test="$nnode[grounded='no']">
                <admst:variable name="nnodeConstant" select="%(xyceNodeConstantName($nnode)/[name='nodeConstant']/value)"/>
                <admst:text format="%($mode)Contributions[$nnodeConstant] -= contribTemp;\n"/>
              </admst:if>

              <admst:text format="\n"/>

              <!-- generate the Jdxp's:
                   Jdxp[pnode]+= d(rhs)/d(probe)*deltaprobe*dlimitedprobe/dprobe

                   The "dlimitedprobe/dprobe" thing is to handle cases
                   where there could be a minus sign introduced by limiting,
                   which can happen with PNP/PMOS vs. NPN/NMOS limiting hacks.

                   Similar for Jdxp[nnode]
                   -->
              <admst:text format="Jdxp_%($mode)[$pnodeConstant] += "/>
              <admst:join select="rhs/probe[#limited='yes']" separator="+">
                <admst:text format="contribTemp.dx(%(xyceProbeConstantName(.)/[name='probeConstant']/value))*probeDiffs[%(xyceProbeConstantName(.)/[name='probeConstant']/value)]*probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)].dx(%(xyceProbeConstantName(.)/[name='probeConstant']/value))"/>
              </admst:join>
              <admst:text format=";\n"/>
              <admst:if test="$nnode[grounded='no']">
                <admst:variable name="nnodeConstant" select="%(xyceNodeConstantName($nnode)/[name='nodeConstant']/value)"/>
                <admst:text format="Jdxp_%($mode)[$nnodeConstant] -= "/>
                <admst:join select="rhs/probe[#limited='yes']" separator="+">
                  <admst:text format="contribTemp.dx(%(xyceProbeConstantName(.)/[name='probeConstant']/value))*probeDiffs[%(xyceProbeConstantName(.)/[name='probeConstant']/value)]*probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)].dx(%(xyceProbeConstantName(.)/[name='probeConstant']/value))"/>
                </admst:join>
                <admst:text format=";\n"/>
              </admst:if>
              <admst:text format="}\n"/>
            </admst:when>

            <!-- When no limiting, this is much simpler: Just output RHS -->
            <admst:otherwise>
              <admst:text format="%($mode)Contributions[$pnodeConstant] += %(printTerm(rhs));\n"/>
              <admst:if test="$nnode[grounded='no']">
                <admst:variable name="nnodeConstant" select="%(xyceNodeConstantName($nnode)/[name='nodeConstant']/value)"/>
                <admst:text format="%($mode)Contributions[$nnodeConstant] -= %(printTerm(rhs));\n"/>
              </admst:if>
            </admst:otherwise>
          </admst:choose>
        </admst:if>
      </admst:otherwise>
    </admst:choose>
    <admst:variable name="globalMustUseTemplate" select="$saveTemplateUse"/>
  </admst:template>

  <!--
   =================================================================-
   probe
   Given a probe, format it for xyce's updateIntermediateVars
   =================================================================-
  -->
  <admst:template match="probe">
<!--
    <admst:assert test="[nature!=discipline/flow]" format="Xyce ADMS interface does not yet support current probes.  %(.) not supported./n"/>
-->
    <admst:variable name="expression" select="(probeVars[%(xyceProbeConstantName(.)/[name='probeConstant']/value)])"/>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>

  <!--
   =================================================================-
   variable
   given a variable, emit C++ reference thereto
   =================================================================-
  -->
  <admst:template match="variable">
    <admst:assert test="adms[datatypename='variable']" format="variable template called on non-variable\n"/>
    <admst:choose>
      <admst:when test="[scope='local']">
        <admst:variable name="expression" select="%(name)"/>
      </admst:when>
      <admst:when test="[scope='global_instance']">
        <admst:choose>
          <admst:when test="[$globalCurrentScope='instance' or exists(attribute[name='xyceAlsoModel'])]">
            <admst:variable name="expression" select="%(name)"/>
          </admst:when>
          <admst:otherwise>
            <admst:fatal format="it is not legal to access instance variable %(name) outside of the instance class!  Our current scope is $globalCurrentScope\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[scope='global_model']">
        <admst:choose>
          <admst:when test="[$globalCurrentScope='model']">
            <admst:variable name="expression" select="%(name)"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="expression" select="(model_.%(name))"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="Unknown variable scope for %(name): %(scope)\n"/>
      </admst:otherwise>
    </admst:choose>
    <admst:if test="[$globalMustForceScalar='yes' and not(nilled(probe))]">
      <admst:variable name="expression" select="$expression.val()"/>
    </admst:if>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>

  <!--
   =================================================================-
   function
   =================================================================-
  -->
  <admst:template match="function">
    <admst:choose>
      <admst:when test="[name='min']">
        <admst:variable name="expression" select="std::min"/>
        <admst:variable name="args" select=""/>
        <admst:for-each select="arguments">
          <!-- if *ANY* argument depends on probes, can't use std::min, must
               use Sacado's overloaded min -->
          <admst:if test="[exists(math/dependency)]">
            <admst:if test="[math/dependency='linear' or math/dependency='nonlinear']">
              <admst:variable name="expression" select="min"/>
            </admst:if>
          </admst:if>
          <admst:if test="[$args!='']">
            <admst:variable name="args" select="$args,"/>
          </admst:if>
          <admst:apply-templates select="." match="processTerm">
            <admst:variable name="args" select="$args%(returned('returnedExpression')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:variable name="expression" select="$expression($args)"/>
      </admst:when>
      <admst:when test="[name='max']">
        <admst:variable name="expression" select="std::max"/>
        <admst:variable name="args" select=""/>
        <admst:for-each select="arguments">
          <!-- if *ANY* argument depends on probes, can't use std::max, must
               use Sacado's overloaded max -->
          <admst:if test="[exists(math/dependency)]">
            <admst:if test="[math/dependency='linear' or math/dependency='nonlinear']">
              <admst:variable name="expression" select="max"/>
            </admst:if>
          </admst:if>
          <admst:if test="[$args!='']">
            <admst:variable name="args" select="$args,"/>
          </admst:if>
          <admst:apply-templates select="." match="processTerm">
            <admst:variable name="args" select="$args%(returned('returnedExpression')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:variable name="expression" select="$expression($args)"/>
      </admst:when>
      <admst:when test="[name='absdelay']">
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="FIXMEabsdelay(%(returned('returnedExpression')/value))"/>
        </admst:apply-templates>
      </admst:when>
      <!-- DDT is a null function in Xyce we'll load such things into
           dynamic contributions, and those will be differentiated elsewhere -->
      <admst:when test="[name='ddt']">
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="(%(returned('returnedExpression')/value))"/>
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[name='\$given' or name='\$param_given']">
        <admst:variable name="arg1" select="%(arguments[1])"/>
        <admst:assert test="$arg1[datatypename='variable' and input='yes']" format="%(name): argument is not a parameter\n"/>
        <admst:choose>
          <admst:when test="$arg1/[parametertype='model']">
            <admst:choose>
              <admst:when test="[$globalCurrentScope = 'model']">
                <admst:variable name="expression" select="given(&quot;$arg1&quot;)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="expression" select="(model_.given(&quot;$arg1&quot;))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="$arg1/[parametertype='instance']">
            <admst:choose>
              <admst:when test="[$globalCurrentScope = 'instance']">
                <admst:variable name="expression" select="given(&quot;$arg1&quot;)"/>
              </admst:when>
              <admst:otherwise>
                <admst:fatal format="Attempt to use \$given() on an instance variable outside of instance scope\n"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:fatal format="%(name): should not be reached\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='\$temperature']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
        <admst:choose>
          <admst:when test="[$globalCurrentScope='instance']">
            <admst:variable name="expression" select="admsTemperature"/>
          </admst:when>
          <!-- KLUDGE!!!!!! -->
          <!-- Assumes that when at model scope, $temperature is taken as
               the default temperature of the simulator. -->
          <!-- At instance scope, we use whatever Xyce passed in to
               updateTemperature for that instance. -->
          <admst:when test="[$globalCurrentScope='model']">
            <admst:variable name="expression" select="admsModTemp"/>
          </admst:when>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='\$mfactor']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
        <admst:variable name="expression" select="FIXME_MFACTOR"/>
      </admst:when>
      <admst:when test="[name='\$vt']">
        <admst:choose>
          <admst:when test="[nilled(arguments)]">
            <admst:variable name="expression" select="adms_vt_nom"/>
          </admst:when>
          <admst:when test="arguments[count(.)=1]">
            <admst:apply-templates select="arguments[1]" match="processTerm">
              <admst:variable name="expression" select="adms_vt(%(returned('returnedExpression')/value))"/>
            </admst:apply-templates>
          </admst:when>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='\$scale']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
        <admst:variable name="expression" select="FIXME_scale"/>
      </admst:when>
      <admst:when test="[name='\$abstime']">
        <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
        <admst:variable name="expression" select="FIXME_abstime"/>
      </admst:when>
      <admst:when test="[name='ddx']">
        <admst:assert test="arguments[count(.)=2]" format="%(name): should have two arguments exactly\n"/>
        <admst:assert test="arguments[2]/adms[datatypename='probe']" format="%(name): second argument is not a probe\n"/>
        <admst:variable name="expression" select="FIXME: ddx(%(arguments[1]),%(arguments[2]))"/>
      </admst:when>
      <admst:when test="[name='floor']">
        <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="floor(%(returned('returnedExpression')/value))"/>
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[name='ceil']">
        <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
        <admst:apply-templates select="arguments[1]" match="processTerm">
          <admst:variable name="expression" select="ceil(%(returned('returnedExpression')/value))"/>
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[name='\$simparam']">
        <admst:choose>
          <admst:when test="[arguments[1]/datatypename='string' and arguments[1]/value='gmin']">
            <admst:variable name="expression" select="getDeviceOptions().gmin"/>
          </admst:when>
          <admst:otherwise>
            <admst:assert test="arguments[count(.)=2]" format="Unrecognized simparam %(arguments[1]) and no expression provided.\n"/>
            <admst:apply-templates select="arguments[2]" match="processTerm">
              <admst:variable name="expression" select="%(returned('returnedExpression')/value)"/>
            </admst:apply-templates>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="expression" select="%(funcname(.)/[name='fname']/value)"/>
        <admst:variable name="args" select=""/>
        <admst:for-each select="arguments">
          <admst:if test="[$args!='']">
            <admst:variable name="args" select="$args,"/>
          </admst:if>
          <admst:apply-templates select="." match="processTerm">
            <admst:variable name="args" select="$args%(returned('returnedExpression')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:variable name="expression" select="$expression($args)"/>
      </admst:otherwise>
    </admst:choose>
    <admst:return name="returnedExpression" value="$expression"/>
  </admst:template>

  <!--
   =================================================================-
   string
   format a string for output
   =================================================================-
  -->
  <admst:template match="string">
    <admst:return name="returnedExpression" value="&quot;%(value)&quot;"/>
  </admst:template>

  <!--
   =================================================================-
   conditional
   output if/then/else
   =================================================================-
  -->
  <admst:template match="conditional">
    <admst:assert test="adms[datatypename='conditional']" format="conditional template called on something other than conditional\n"/>

    <admst:text format="if (%(printTerm(if)))\n"/>
    <!-- blocks will print their own braces, but we always want them -->
    <admst:text select="then/adms[datatypename!='block']" format="{\n"/>
    <admst:apply-templates select="then" match="%(adms/datatypename)"/>
    <!-- blocks will print their own braces, but we always want them -->
    <admst:text select="then/adms[datatypename!='block']"  format="}\n"/>
    <admst:if test="else">
      <admst:text format="else\n"/>
      <admst:text select="else/adms[datatypename!='block']" format="{\n"/>
      <admst:apply-templates select="else" match="%(adms/datatypename)"/>
      <admst:text select="else/adms[datatypename!='block']"  format="}\n"/>
    </admst:if>
  </admst:template>

  <!--
   =================================================================-
   block
   output block
   =================================================================-
  -->
  <admst:template match="block">
    <admst:assert test="adms[datatypename='block']" format="block template called on something other than block\n"/>
    <admst:text select="[name!='']" format="//Begin block %(name)\n"/>
    <admst:text format="{\n"/>
    <admst:apply-templates select="item" match="%(adms/datatypename)"/>
    <admst:text format="}\n"/>
    <admst:text select="[name!='']" format="// End block %(name)\n"/>
  </admst:template>


  <!--
   =================================================================-
   blockvariable
     declare block-local variables
   =================================================================-
  -->
  <admst:template match="blockvariable">
    <admst:text format="//Block-local variables for block %(block/name)\n"/>
    <admst:for-each select="variable">
      <admst:apply-templates select="." match="xyceDeclareVariable"/>
    </admst:for-each>
    <admst:text format="//End of Block-local variables\n"/>
  </admst:template>

  <!--
   =================================================================-
   nilled
   do nothing, when nothing is found
   =================================================================-
  -->
  <admst:template match="nilled">
  </admst:template>

  <!--
   =================================================================-
   whileloop
   output while loop
   =================================================================-
  -->
  <admst:template match="whileloop">
    <admst:text format="while (%(printTerm(while)))\n"/>
    <admst:text select="whileblock/adms[datatypename!='block']" format="{\n"/>
    <admst:apply-templates select="whileblock" match="%(adms/datatypename)"/>
    <admst:text select="whileblock/adms[datatypename!='block']" format="}\n"/>
  </admst:template>

  <!--
   =================================================================-
   forloop
   output for   loop
   =================================================================-
  -->
  <admst:template match="forloop">
    <admst:text format="for ("/>
    <admst:text format="%(printTerm(initial/lhs))=%(printTerm(initial/rhs));"/>
    <admst:text format="%(printTerm(condition));"/>
    <admst:text format="%(printTerm(update/lhs))=%(printTerm(update/rhs)) )"/>
    <admst:text select="forblock/adms[datatypename!='block']" format="{\n"/>
    <admst:apply-templates select="forblock" match="%(adms/datatypename)"/>
    <admst:text select="forblock/adms[datatypename!='block']" format="}\n"/>
  </admst:template>
  <!--
   =================================================================-
   case
   output "case" statement
   =================================================================-
  -->
  <admst:template match="case">
    <admst:variable name="casecondition" path="case/tree"/>
    <admst:variable name="havedefault" select="no"/>
    <admst:if test="[count(caseitem[defaultcase='yes']) >0]">
      <admst:variable name="havedefault" select="yes"/>
    </admst:if>

    <admst:for-each select="caseitem[defaultcase='no']">
      <admst:text format="if ( "/>
      <admst:join select="condition" separator="||">
	<admst:apply-templates select="." match="%(datatypename)">
	  <admst:text format="%(printTerm($casecondition)) == (%(returned('returnedExpression')/value))"/>
	</admst:apply-templates>
      </admst:join>
      <admst:text format=")\n"/>
      <admst:apply-templates select="code" match="%(datatypename)" required="yes"/>
      <admst:text format="else\n"/>
    </admst:for-each>
    <admst:text select="[$havedefault='no']" format="{\n // no default\n}\n"/>
    <admst:for-each select="caseitem[defaultcase='yes']">
      <admst-apply-templates select="code" match="%(datatypename)" required="yes"/>
    </admst:for-each>
  </admst:template>


  <!--
   =================================================================-
   formatted_range
   Given a variable node, print out its range in a nicely formatted
   way, with open or closed bounds indicated.
   This is for pretty printing such as for HTML, not code generation.
   =================================================================-
  -->
  <admst:template match="formatted_range">
    <admst:choose>
      <admst:when test="[nilled(range)]">
        <admst:text format="No Range Specified"/>
      </admst:when>
      <admst:when test="[name!='pnp' and name!='npn']">
        <admst:apply-templates select="range" match="formatted_range2"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="Positive range"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>

  <!--
   =================================================================-
   formatted_range2
   the actual guts of formatted range, but this one takes a single
   range node of the tree, not a variable (which can have multiple
   ranges
   =================================================================-
  -->
<admst:template match="formatted_range2">
  <admst:choose>
    <admst:when test="infexpr[hasspecialnumber='YES']">
      <admst:text format=" ] %(infexpr) "/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[infboundtype='range_bound_include']">
          <admst:text format="[ "/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="] "/>
        </admst:otherwise>
      </admst:choose>
      <admst:apply-templates select="infexpr" match="printTerm"/>
      <admst:text format=", "/>
    </admst:otherwise>
  </admst:choose>
  <admst:choose>
    <admst:when test="supexpr[hasspecialnumber='YES']">
      <admst:text format=" %(supexpr) ["/>
    </admst:when>
    <admst:otherwise>
      <admst:apply-templates select="supexpr" match="printTerm"/>
      <admst:choose>
	<admst:when test="[supboundtype='range_bound_include']">
	  <admst:text format=" ]"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format=" ["/>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
</admst:template>

  <!--
   =================================================================-
   rangeCondition
   Given a range, generate the C++ condition that checks if it's
   exceeded/violated
   =================================================================-
  -->

<admst:template match="rangeCondition">
  <admst:choose>
    <admst:when test="[infexpr/hasspecialnumber='YES' and supexpr/hasspecialnumber='YES']">
      <admst:return name="doNothing" value="yes"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="returnCondition" select="("/>
      <!-- Lower bound -->
      <admst:if test="infexpr[hasspecialnumber!='YES']">
        <admst:variable name="returnCondition" select="$returnCondition%(../name) &gt;"/>
        <admst:if test="[infboundtype='range_bound_include']">
          <admst:variable name="returnCondition" select="$returnCondition="/>
        </admst:if>
        <admst:variable name="returnCondition" select="$returnCondition%(processTerm(infexpr)/[name='returnedExpression']/value)"/>
        <admst:if test="supexpr[hasspecialnumber!='YES']">
          <admst:variable name="returnCondition" select="$returnCondition &amp;&amp; "/>
        </admst:if>
      </admst:if>

      <!-- upper bound -->
      <admst:if test="supexpr[hasspecialnumber!='YES']">
        <admst:variable name="returnCondition" select="$returnCondition%(../name) &lt;"/>
        <admst:if test="[supboundtype='range_bound_include']">
          <admst:variable name="returnCondition" select="$returnCondition="/>
        </admst:if>
        <admst:variable name="returnCondition" select="$returnCondition%(processTerm(supexpr)/[name='returnedExpression']/value) "/>
      </admst:if>
      <admst:variable name="returnCondition" select="$returnCondition)"/>

      <!-- now decide whether this is an include condition or exclude: -->
      <admst:if test="[type='include']">
        <admst:variable name="returnCondition" select="!($returnCondition)"/>
      </admst:if>
      <admst:return name="doNothing" value="no"/>
      <admst:return name="returnCondition" value="$returnCondition"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

  <!--
   =================================================================-
   check_range
   Given a variable node, generate code to check the variable against
   the range.

   The range of the variable is assumed non-nilled, so the caller
   must check first before calling this.
   =================================================================-
  -->

<admst:template match="check_range">
  <admst:choose>
    <!-- first special case: both upper and lower are special, meaning that
         there really is no range to bother checking -->
    <admst:when test="[range/infexpr/hasspecialnumber='YES' and range/supexpr/hasspecialnumber='YES']">
      <!-- do nothing -->
    </admst:when>
    <admst:otherwise>
      <!-- we have a range to check -->
      <admst:text format="  if ( "/>
      <admst:text format="("/>
      <!-- there may be several ranges specified, some included, some excluded.
           gotta be careful -->
      <admst:join select="range[infexpr/hasspecialnumber!='YES' or supexpr/hasspecialnumber!='YES']" separator=" || ">
        <admst:apply-templates select="." match="rangeCondition">
          <admst:text format="%(returned('returnCondition')/value)"/>
        </admst:apply-templates>
      </admst:join>
      <admst:text format=") )\n  {\n    UserError0(*this) &lt;&lt; &quot;$nameSpace: Parameter %(name) value &quot; &lt;&lt; %(name) &lt;&lt; &quot; "/>
      <admst:join select="range" separator=" or ">
        <admst:text select="[type='include']" format="out of range"/>
        <admst:text select="[type='exclude']" format="in excluded range"/>
        <admst:text format=" %(formatted_range2(.))"/>
      </admst:join>
      <admst:text format="&quot;;\n  }\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- map binary operators onto C++ symbols -->
<admst:template match="bname">
  <admst:choose>
    <admst:when test="[name='bw_equr']">
      <admst:return name="bname" value="^~"/>
    </admst:when>
    <admst:when test="[name='bw_equl']">
      <admst:return name="bname" value="~^"/>
    </admst:when>
    <admst:when test="[name='bw_xor']">
      <admst:return name="bname" value="^"/>
    </admst:when>
    <admst:when test="[name='bw_or']">
      <admst:return name="bname" value="|"/>
    </admst:when>
    <admst:when test="[name='bw_and']">
      <admst:return name="bname" value="&amp;"/>
    </admst:when>
    <admst:when test="[name='or']">
      <admst:return name="bname" value="||"/>
    </admst:when>
    <admst:when test="[name='and']">
      <admst:return name="bname" value="&amp;&amp;"/>
    </admst:when>
    <admst:when test="[name='equ']">
      <admst:return name="bname" value="=="/>
    </admst:when>
    <admst:when test="[name='notequ']">
      <admst:return name="bname" value="!="/>
    </admst:when>
    <admst:when test="[name='lt']">
      <admst:return name="bname" value="&lt;"/>
    </admst:when>
    <admst:when test="[name='lt_equ']">
      <admst:return name="bname" value="&lt;="/>
    </admst:when>
    <admst:when test="[name='gt']">
      <admst:return name="bname" value="&gt;"/>
    </admst:when>
    <admst:when test="[name='gt_equ']">
      <admst:return name="bname" value="&gt;="/>
    </admst:when>
    <admst:when test="[name='shiftr']">
      <admst:return name="bname" value="&gt;&gt;"/>
    </admst:when>
    <admst:when test="[name='shiftl']">
      <admst:return name="bname" value="&lt;&lt;"/>
    </admst:when>
    <admst:when test="[name='multmod']">
      <admst:return name="bname" value="%"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="variable type %(name) unknown\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="funcname">
  <admst:choose>
    <admst:when test="[name='abs']">
      <admst:variable name="expression" select="fabs"/>
    </admst:when>
    <admst:when test="[name='\$shrinkl']">
      <admst:variable name="expression" select="shrinkl"/>
    </admst:when>
    <admst:when test="[name='\$shrinka']">
      <admst:variable name="expression" select="shrinka"/>
    </admst:when>
    <admst:when test="[name='log']">
      <admst:variable name="expression" select="(1.0/log(10.0))*log"/>
    </admst:when>
    <admst:when test="[name='ln']">
      <admst:variable name="expression" select="log"/>
    </admst:when>
    <admst:when test="[name='limexp']">
      <admst:choose>
        <admst:when test="[$globalMustUseTemplate='no']">
          <admst:variable name="expression" select="limexp"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="expression" select="limexp&lt;AdmsFadType&gt;"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='\$limexp']">
      <admst:choose>
        <admst:when test="[$globalMustUseTemplate='no']">
          <admst:variable name="expression" select="limexp"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="expression" select="limexp&lt;AdmsFadType&gt;"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[$globalMustUseTemplate='no' or class!='analog']">
          <admst:choose>
            <admst:when test="[class='analog']">
              <admst:choose>
                <admst:when test="[$globalCurrentScope='model']">
                  <admst:variable name="expression" select="analogFunctions.%(name)"/>
                </admst:when>
                <admst:when test="[$globalCurrentScope='instance']">
                  <admst:variable name="expression" select="model_.analogFunctions.%(name)"/>
                </admst:when>
                <admst:when test="[$globalCurrentScope='AF']">
                  <admst:variable name="expression" select="%(name)"/>
                </admst:when>
              </admst:choose>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="expression" select="%(name)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[class='analog']">
              <!-- analog functions are in their own class, and the model
                   class has an instance of that. -->
              <admst:choose>
                <!-- if we're in the AF class, these functions are accessible
                     just by their names -->
                <admst:when test="[$globalCurrentScope='AF']">
                  <admst:variable name="expression" select="%(name)&lt;AdmsFadType&gt;"/>
                </admst:when>
                <admst:when test="[$globalCurrentScope='model']">
                  <admst:variable name="expression" select="analogFunctions.%(name)&lt;AdmsFadType&gt;"/>
                </admst:when>
                <!-- when we're in instance class, have to reference through the
                     model -->
                <admst:when test="[$globalCurrentScope='instance']">
                  <admst:variable name="expression" select="model_.analogFunctions.%(name)&lt;AdmsFadType&gt;"/>
                </admst:when>
              </admst:choose>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="expression" select="%(name)&lt;AdmsFadType&gt;"/>
            </admst:otherwise>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
  <admst:return name="fname" value="$expression"/>
</admst:template>

<!-- callfunction: handle $strobe -->
<admst:template match="callfunction">
  <admst:choose>
    <admst:when test="function[name='\$strobe']">
      <admst:text format="std::cerr "/>
      <admst:for-each select="function/arguments">
      <admst:text format=" &lt;&lt; %(printTerm(.))"/>
      </admst:for-each>
      <admst:text format=" &lt;&lt;  std::endl; \n"/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="function/name"/>
      <admst:text format="%s: not supported by this interface\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

</admst>
