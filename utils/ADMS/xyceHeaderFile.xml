<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">


  <!--
      Filename:      $RCSfile: xyceHeaderFile.xml,v $
      Purpose:       Generate the .h file for a Xyce implementation of a 
                     verilog model.
      Special Notes: You must include "xyceBasicTemplates.xml" to use this 
                     script
      Creator:       Tom Russo, SNL, Electrical and Microsystems Modeling
      Creation Date: 13 May 2008

      Revision Information:
      ====================-

      Revision Number: $Revision: 1.43.2.2 $
      Revision Date:   $Date: 2013/10/03 17:48:20 $
      Current Owner:   $Author: tvrusso $
    -->
<admst:for-each select="/module">
  <admst:variable name="thisModule" select="%(.)"/>
  <!-- Set up some useful variables: the N_DEV_(foo) class, and its
       related Instance and Model classes -->
  <admst:apply-templates select="." match="xyceClassBaseName">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="classname" select="%s"/>
  </admst:apply-templates>

  <admst:apply-templates select="." match="xyceDeviceNamespace">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="nameSpace" select="%s"/>
  </admst:apply-templates>
  
  <admst:apply-templates select="." match="xyceModelClassName">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="modelName" select="%s"/>
  </admst:apply-templates>
  
  <admst:apply-templates select="." match="xyceInstanceClassName">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="instanceName" select="%s"/>
  </admst:apply-templates>
  
  <admst:apply-templates select="." match="collectLimiters"/>  
  <admst:apply-templates select="." match="collectCollapsibles"/>  
  <admst:apply-templates select="." match="collectExtraUnknowns"/>  

  <admst:open file="$classname.h">
// -*-c++-*-
//-----------------------------------------------------------------------------
// Copyright Notice
//
//   Copyright 2002 Sandia Corporation. Under the terms
//   of Contract DE-AC04-94AL85000 with Sandia Corporation, the U.S.
//   Government retains certain rights in this software.
//
//    Xyce(TM) Parallel Electrical Simulator
//    Copyright (C) 2002-2013  Sandia Corporation
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Filename       : \$RCSfile\$
//
// Purpose        :
//
// Special Notes  : Generated from verilog file %(/filename) with ADMS 
//                  interface for %(/simulator/package_string)
//                  DO NOT EDIT THIS FILE DIRECTLY!  It may be overwritten!
//
// Creator        : %(/simulator/fullname)
//
// Creation Date  : %(/simulator/currentdate)
//
// Revision Information:
// ---------------------
//
// Revision Number: \$Revision\$
//
// Revision Date  : \$Date\$
//
// Current Owner  : \$Author\$
//-----------------------------------------------------------------------------

  <admst:apply-templates select="." match="xyceGuardSymbol">
    <admst:value-of select="returned('symbolname')/value"/>
    <admst:variable name="guardSymbol" select="%s"/>
  </admst:apply-templates>
  <admst:text format="#ifndef $guardSymbol\n#define $guardSymbol\n"/>
// ----------   Xyce Includes   ----------
#include &lt;Sacado.hpp&gt;
#include &lt;N_DEV_DeviceBlock.h&gt;
#include &lt;N_DEV_DeviceInstance.h&gt;
#include &lt;N_DEV_DeviceModel.h&gt;

#include &lt;N_DEV_Param.h&gt;

namespace Xyce {
namespace Device {

<admst:text format="namespace %($nameSpace) {"/>

// ---------- Forward Declarations ----------

  <admst:text format="class Model;"/>

  <!-- this GLOBAL VARIABLE (ugh) used in templates to figure out how to access
     certain class members (e.g. how to get at model variables from an instance
     -->
  <admst:variable name="globalCurrentScope" select="instance"/>

//-----------------------------------------------------------------------------

  <admst:text format="// Class         : Instance\n"/>
//
// Purpose       : This class represents a single instance  of the
//                 device.  It mainly contains indices and pointers into
//                 the matrix equation (see the resistor instance class for
//                 more details).
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------

  <admst:text format="class Instance : public DeviceInstance"/>
{
  friend class ParametricData&lt;Instance&gt;;
  friend class Model;

// This typedef is for our automatic differentiation:
  typedef Sacado::Fad::SFad&lt;double,%(xyceNumberProbes(.))&gt; AdmsFadType;

  public:
    static ParametricData&lt;Instance&gt; &amp;getParametricData();

    virtual const ParametricData&lt;void> &amp;getMyParametricData() const
    {
      return getParametricData();
    }


  <admst:text format="    Instance(InstanceBlock &amp; IB,
                        Model &amp; Miter,
                        MatrixLoadData &amp; mlData1,
                        SolverState &amp;ss1,
                        ExternData  &amp;ed1,
                        DeviceOptions &amp; do1);\n"/>
     // destructor

    <admst:text format="    ~Instance();"/>

private:

    <admst:text format="  Instance(const Instance &amp;);\n"/>
    <admst:text format="  Instance &amp;operator=(const Instance &amp;);"/>

public:
    void registerLIDs( const vector&lt;int&gt; &amp; intLIDVecRef,
                       const vector&lt;int&gt; &amp; extLIDVecRef );
    void registerStateLIDs( const vector&lt;int&gt; &amp; staLIDVecRef );
    void setupPointers();

    map&lt;int,string&gt; &amp; getIntNameMap ();

    const vector&lt; vector&lt;int&gt; &gt; &amp; jacobianStamp() const;
    void registerJacLIDs( const vector&lt; vector&lt;int&gt; &gt; &amp; jacLIDVec );

    bool processParams (string param = "");
    bool updateTemperature ( const double &amp; temp = -999.0 );
    bool updateIntermediateVars ();
    bool updatePrimaryState ();
    bool updateSecondaryState ();

    // load functions, residual:
    bool loadDAEQVector ();
    bool loadDAEFVector ();

    // load functions, Jacobian:
    bool loadDAEdQdx ();
    bool loadDAEdFdx ();

  <admst:if test="[count(node[#collapsible='yes'])>0]">
   void collapseNodes();
  </admst:if>

  private:
    // Limited exponential --- NOT what verilog LRM says, but what qucs,
    // ng-spice, and zspice do.

    template &lt;typename T&gt;
      T limexp(T &amp;x)
      {
        if ((x) &lt; 80.0)
         return (exp(x));
        else
         return (exp(80.0)*(x-79.0));
      }


  public:
    // iterator reference to the %(name) model which owns this instance.
    // Getters and setters
    Model &amp;getModel()
    {
      return model_;
    }

  private:

    Model &amp; model_;   //&lt; Owning Model

    <admst:apply-templates select="." match="xyceDeclareInstanceVariables"/>
    <admst:apply-templates select="." match="xyceDeclareNodeLIDVariables"/>
    <admst:apply-templates select="." match="xyceDeclareBranchLIDVariables"/>
    <admst:apply-templates select="." match="xyceDeclareJacobianOffsets"/>
    <admst:apply-templates select="." match="xyceDeclareNodeConstants"/>
    <admst:apply-templates select="." match="xyceDeclareBranchConstants"/>
    <admst:apply-templates select="." match="xyceDeclareProbeConstants"/>
    <admst:apply-templates select="." match="xyceDeclareLimitedProbeStateLIDs"/>
    <admst:apply-templates select="." match="declareCollapsibleBools"/>
    <admst:apply-templates select="." match="xyceDeclareFadArrays"/>

    <admst:if test="[count(@limitedProbes)>0]">
    // This array stores the differences between original and limited variables.
    vector&lt;double&gt; probeDiffs;
    // These store the Jdxp's for F and Q, respectively
    vector&lt;double&gt; Jdxp_static;
    vector&lt;double&gt; Jdxp_dynamic;
    </admst:if>

    // this is what we'll use when any model uses \$temperature.  We'll
    // set it in updateTemperature, and initialize it to whatever
    // is in devOptions when the instance is constructed.
    double admsTemperature;

    // vt at \$temperature;
    double adms_vt_nom;


    // This one is for the annoying bogus "XyceADMSInstTemp" parameter
    // that we need so we can set it from the device manager when there's no
    // "TEMP" parameter to use
    double admsInstTemp;

    // thermal voltage at kelvin temperature temp)
    inline double adms_vt(double temp) {return(CONSTKoverQ*temp);};

    <admst:choose>
      <admst:when test="[count(node[#collapsible='yes'])=0]">
    static vector&lt; vector&lt;int&gt; &gt; jacStamp;
    static vector&lt;int&gt; jacMap;
    static vector&lt; vector&lt;int&gt; &gt; jacMap2;
      </admst:when>
      <admst:otherwise>
    vector&lt; vector&lt;int&gt; &gt; jacStamp;
    vector&lt;int&gt; jacMap;
    vector&lt; vector&lt;int&gt; &gt; jacMap2;
      </admst:otherwise>
    </admst:choose>
    };


<admst:if test="[exists(analogfunction)]">
  <!-- this GLOBAL VARIABLE (ugh) used in templates to figure out how to access
     certain class members (e.g. how to get at model variables from an instance
     -->
  <admst:variable name="globalCurrentScope" select="AF"/>
// Class AnalogFunctions

class AnalogFunctions
{
  public:
    <admst:variable name="globalMustUseTemplate" select="no"/>
    <admst:variable name="globalMustForceScalar" select="no"/>
    <admst:for-each select="analogfunction">

      // Analog Function %(name)

      <admst:apply-templates select="." match="xyceTemplatedAnalogFunctionDeclaration"/>
    </admst:for-each>
};


</admst:if>

  <!-- this GLOBAL VARIABLE (ugh) used in templates to figure out how to access
     certain class members (e.g. how to get at model variables from an instance
     -->
  <admst:variable name="globalCurrentScope" select="model"/>
//-----------------------------------------------------------------------------

    <admst:text format="// Class         : Model\n"/>
// Purpose       :
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------

    <admst:text format="class Model : public DeviceModel"/>
{
  typedef std::vector&lt;Instance *&gt; InstanceVector;

  friend class ParametricData&lt;Model&gt;;
  friend class Instance;

  typedef Sacado::Fad::SFad&lt;double,%(xyceNumberProbes(.))&gt; AdmsFadType;

  public:
    static ParametricData&lt;Model&gt; &amp;getParametricData();

    virtual const ParametricData&lt;void&gt; &amp;getMyParametricData() const
    {
      return getParametricData();
    }


    <admst:text format="    Model(const ModelBlock &amp;MB,
                         SolverState &amp; ss1,
                         DeviceOptions &amp; do1);\n"/>
    <admst:text format="    ~Model();"/>

private:

    <admst:text format="    Model();\n"/>
    <admst:text format="    Model(const Model &amp;);\n"/>
    <admst:text format="    Model &amp;operator=(const Model &amp;);"/>

public:
    virtual std::ostream &amp;printOutInstances(std::ostream &amp;os) const;
    bool processParams (string param = "");
    bool processInstanceParams (string param = "");

  private:
    <admst:if test="[exists(analogfunction)]">
      AnalogFunctions analogFunctions;
    </admst:if>

  public:
    InstanceVector &amp;getInstanceVector()
    {
      return instanceContainer;
    }

    const InstanceVector &amp;getInstanceVector() const
    {
      return instanceContainer;
    }

  private:
    vector&lt;Instance*&gt; instanceContainer;

  private:

    // This one is for the annoying bogus "XyceADMSInstTemp" parameter
    // that we need so we can set it from the device manager when there's no
    // "TEMP" model parameter to use
    double admsModTemp;

    <admst:apply-templates select="." match="xyceDeclareModelVariables"/>
};


<admst:text format="} // namespace %($nameSpace)"/>
} // namespace Device
} // namespace Xyce


<admst:text format="typedef Xyce::Device::%($nameSpace)::Instance %($instanceName);\n"/>
<admst:text format="typedef Xyce::Device::%($nameSpace)::Model %($modelName);\n\n"/>

<admst:text format="#endif //$guardSymbol\n"/>
  </admst:open>

    
</admst:for-each>
</admst>
