//======================================================================================
//======================================================================================
// Filename: PSP103_module.include
//======================================================================================
//======================================================================================
//
//  (c) Copyright 2009, All Rights Reserved, NXP Semiconductors
//
//
//  Version: 103.1, May 2009
//
//======================================================================================
//======================================================================================
//
// Further information can be found in the file readme.txt
//

    //  Node definitions
    inout      D, G, S, B;
    electrical D;
    electrical G;
    electrical S;
    electrical B;

`ifdef useNOInodes
    // Extra internal nodes for correlated drain and gate noise
    electrical NOI;
    electrical NOI2;

    // Extra branches for correlated drain and gate noise
    branch (NOI) NOII;
    branch (NOI) NOIR;
    branch (NOI) NOIC;
`endif // useNOInodes

    // Internal nodes for gate and bulk resistors
    electrical GP;
    electrical SI;
    electrical DI;
    electrical BI;
    electrical BP;
    electrical BS;
    electrical BD;

`ifdef NQSmodel
    // Internal nodes for spline collocation
    electrical INT1;
    electrical INT2;
    electrical INT3;
    electrical INT4;
    electrical INT5;
    electrical INT6;
    electrical INT7;
    electrical INT8;
    electrical INT9;

    branch(INT1) SPLINE1;
    branch(INT2) SPLINE2;
    branch(INT3) SPLINE3;
    branch(INT4) SPLINE4;
    branch(INT5) SPLINE5;
    branch(INT6) SPLINE6;
    branch(INT7) SPLINE7;
    branch(INT8) SPLINE8;
    branch(INT9) SPLINE9;

    branch(INT1) RES1;
    branch(INT2) RES2;
    branch(INT3) RES3;
    branch(INT4) RES4;
    branch(INT5) RES5;
    branch(INT6) RES6;
    branch(INT7) RES7;
    branch(INT8) RES8;
    branch(INT9) RES9;

`endif // NQSmodel

    //////////////////////////
    //
    //  Model parameters
    //
    //////////////////////////

    //  Special model parameters, some are also simulator global variables
    parameter real    LEVEL    =  103                             `P(info="Model level" unit="");
    parameter real    TYPE     =  1.0      `from(   -1.0,1.0    ) `P(info="Channel type parameter, +1=NMOS -1=PMOS" unit="");
    parameter real    TR       =  21.0     `from( -273.0,inf    ) `P(info="nominal (reference) temperature" unit="C" xyceUnit="U_DEGC");

    //  Switch parameters that turn models or effects on or off
`ifdef NQSmodel
    parameter real    SWNQS    =  0.0      `from(    0.0,9.0    ) `P(info="Flag for NQS, 0=off, 1, 2, 3, 5, or 9=number of collocation points" unit="");
`endif // NQSmodel
    parameter real    SWGEO    =  1.0      `from(    0.0,2.0    ) `P(info="Flag for geometrical model, 0=local, 1=global, 2=binning" unit="");
    parameter real    SWIGATE  =  0.0      `from(    0.0,1.0    ) `P(info="Flag for gate current, 0=turn off IG" unit="");
    parameter real    SWIMPACT =  0.0      `from(    0.0,1.0    ) `P(info="Flag for impact ionization current, 0=turn off II" unit="");
    parameter real    SWGIDL   =  0.0      `from(    0.0,1.0    ) `P(info="Flag for GIDL current, 0=turn off IGIDL" unit="");
    parameter real    SWJUNCAP =  0.0      `from(    0.0,3.0    ) `P(info="Flag for juncap, 0=turn off juncap" unit="");
    parameter real    SWJUNASYM=  0.0                             `P(info="Flag for asymmetric junctions; 0=symmetric, 1=asymmetric" unit="");
    parameter real    SWNUD    =  0.0      `from(    0.0,2.0    ) `P(info="Flag for NUD-effect; 0=off, 1=on, 2=on+CV-correction" unit="");
    parameter real    SWDELVTAC=  0.0      `from(    0.0,1.0    ) `P(info="Flag for separate capacitance calculation; 0=off, 1=on" unit="");
    parameter real    QMC      =  1.0      `from(    0.0,inf    ) `P(info="Quantum-mechanical correction factor" unit="");

    ///////////////////////////////////////////////////
    // PSP local model parameters
    ///////////////////////////////////////////////////

    //  Process parameters
    parameter real    VFB      = -1.0                             `P(info="Flat band voltage at TR" unit="V" xyceUnit="U_VOLT");
    parameter real    STVFB    =  5.0e-4                          `P(info="Temperature dependence of VFB" unit="V/K" xyceUnit="U_VKM1");
    parameter real    TOX      =  2.0e-09  `from(  1e-10,inf    ) `P(info="Gate oxide thickness" unit="m" xyceUnit="U_METER");
    parameter real    EPSROX   =  3.9      `from(    1.0,inf    ) `P(info="Relative permittivity of gate dielectric" unit="");
    parameter real    NEFF     =  5.0e+23  `from(   1e20,1e26   ) `P(info="Effective substrate doping" unit="m^-3" xyceUnit="U_METERM3");
    parameter real    FACNEFFAC=  1.0      `from(    0.0,inf    ) `P(info="Pre-factor for effective substrate doping in separate charge calculation" unit="");
    parameter real    GFACNUD  =  1.0      `from(   0.01,inf    ) `P(info="Bodyfactor change due to NUD-effect" unit="");
    parameter real    VSBNUD   =  0.0      `from(    0.0,inf    ) `P(info="Lower Vsb value for NUD-effect" unit="V" xyceUnit="U_VOLT");
    parameter real    DVSBNUD  =  1.0      `from(    0.1,inf    ) `P(info="Vsb-range for NUD-effect" unit="V" xyceUnit="U_VOLT");
    parameter real    VNSUB    =  0.0                             `P(info="Effective doping bias-dependence parameter" unit="V" xyceUnit="U_VOLT");
    parameter real    NSLP     =  0.05     `from(   1e-3,inf    ) `P(info="Effective doping bias-dependence parameter" unit="V" xyceUnit="U_VOLT");
    parameter real    DNSUB    =  0.0      `from(    0.0,1.0    ) `P(info="Effective doping bias-dependence parameter" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    DPHIB    =  0.0                             `P(info="Offset parameter for PHIB" unit="V" xyceUnit="U_VOLT");
    parameter real    DELVTAC  =  0.0                             `P(info="Offset parameter for PHIB in separate charge calculation" unit="V" xyceUnit="U_VOLT");
    parameter real    NP       =  1.0e+26  `from(    0.0,inf    ) `P(info="Gate poly-silicon doping" unit="m^-3" xyceUnit="U_METERM3");
    parameter real    CT       =  0.0      `from(    0.0,inf    ) `P(info="Interface states factor" unit="");
    parameter real    TOXOV    =  2.0e-09  `from(  1e-10,inf    ) `P(info="Overlap oxide thickness" unit="m" xyceUnit="U_METER");
    parameter real    TOXOVD   =  2.0e-09  `from(  1e-10,inf    ) `P(info="Overlap oxide thickness for drain side" unit="m" xyceUnit="U_METER");
    parameter real    NOV      =  5.0e+25  `from(   1e20,1e27   ) `P(info="Effective doping of overlap region" unit="m^-3" xyceUnit="U_METERM3");
    parameter real    NOVD     =  5.0e+25  `from(   1e20,1e27   ) `P(info="Effective doping of overlap region for drain side" unit="m^-3" xyceUnit="U_METERM3");

    //  DIBL parameters
    parameter real    CF       =  0.0      `from(    0.0,inf    ) `P(info="DIBL-parameter" unit="");
    parameter real    CFB      =  0.0      `from(    0.0,1.0    ) `P(info="Back bias dependence of CF" unit="V^-1" xyceUnit="U_VOLTM1");

    //  Mobility parameters
    parameter real    BETN     =  7e-2     `from(    0.0,inf    ) `P(info="Channel aspect ratio times zero-field mobility" unit="m^2/V/s" xyceUnit="U_M2VM1SM1");
    parameter real    STBET    =  1.0                             `P(info="Temperature dependence of BETN" unit="");
    parameter real    MUE      =  0.5      `from(    0.0,inf    ) `P(info="Mobility reduction coefficient at TR" unit="m/V" xyceUnit="U_MVM1");
    parameter real    STMUE    =  0.0                             `P(info="Temperature dependence of MUE" unit="");
    parameter real    THEMU    =  1.5      `from(    0.0,inf    ) `P(info="Mobility reduction exponent at TR" unit="");
    parameter real    STTHEMU  =  1.5                             `P(info="Temperature dependence of THEMU" unit="");
    parameter real    CS       =  0.0      `from(    0.0,inf    ) `P(info="Coulomb scattering parameter at TR" unit="");
    parameter real    STCS     =  0.0                             `P(info="Temperature dependence of CS" unit="");
    parameter real    XCOR     =  0.0      `from(    0.0,inf    ) `P(info="Non-universality factor" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    STXCOR   =  0.0                             `P(info="Temperature dependence of XCOR" unit="");
    parameter real    FETA     =  1.0      `from(    0.0,inf    ) `P(info="Effective field parameter" unit="");

    //  Series-resistance parameters (for resistance modeling as part of intrinsic mobility reduction)
    parameter real    RS       =  30       `from(    0.0,inf    ) `P(info="Series resistance at TR" unit="Ohm" xyceUnit="U_OHM");
    parameter real    STRS     =  1.0                             `P(info="Temperature dependence of RS" unit="");
    parameter real    RSB      =  0.0      `from(   -0.5,1.0    ) `P(info="Back-bias dependence of series resistance" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    RSG      =  0.0      `from(   -0.5,inf    ) `P(info="Gate-bias dependence of series resistance" unit="V^-1" xyceUnit="U_VOLTM1");

    //  Velocity saturation parameters
    parameter real    THESAT   =  1.0      `from(    0.0,inf    ) `P(info="Velocity saturation parameter at TR" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    STTHESAT =  1.0                             `P(info="Temperature dependence of THESAT" unit="");
    parameter real    THESATB  =  0.0      `from(   -0.5,1.0    ) `P(info="Back-bias dependence of velocity saturation" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    THESATG  =  0.0      `from(   -0.5,inf    ) `P(info="Gate-bias dependence of velocity saturation" unit="V^-1" xyceUnit="U_VOLTM1");

    //  Saturation voltage parameters
    parameter real    AX       =  3.0      `from(    2.0,inf    ) `P(info="Linear/saturation transition factor" unit="");

    //  Channel length modulation (CLM) parameters
    parameter real    ALP      =  0.01     `from(    0.0,inf    ) `P(info="CLM pre-factor" unit="");
    parameter real    ALP1     =  0.00     `from(    0.0,inf    ) `P(info="CLM enhancement factor above threshold" unit="V" xyceUnit="U_VOLT");
    parameter real    ALP2     =  0.00     `from(    0.0,inf    ) `P(info="CLM enhancement factor below threshold" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    VP       =  0.05     `from(  1e-10,inf    ) `P(info="CLM logarithm dependence factor" unit="V" xyceUnit="U_VOLT");

    //  Impact ionization (II) parameters
    parameter real    A1       =  1.0      `from(   0.0,inf     ) `P(info="Impact-ionization pre-factor" unit="");
    parameter real    A2       = 10.0      `from(   0.0,inf     ) `P(info="Impact-ionization exponent at TR" unit="V" xyceUnit="U_VOLT");
    parameter real    STA2     =  0.0                             `P(info="Temperature dependence of A2" unit="V" xyceUnit="U_VOLT");
    parameter real    A3       =  1.0      `from(   0.0,inf     ) `P(info="Saturation-voltage dependence of impact-ionization" unit="");
    parameter real    A4       =  0.0      `from(   0.0,inf     ) `P(info="Back-bias dependence of impact-ionization" unit="V^-0.5" xyceUnit="U_VOLTMH");

    //  Gate current parameters
    parameter real    GCO      =  0.0      `from( -10.0,10.0    ) `P(info="Gate tunneling energy adjustment" unit="");
    parameter real    IGINV    =  0.0      `from(   0.0,inf     ) `P(info="Gate channel current pre-factor" unit="A" xyceUnit="U_AMP");
    parameter real    IGOV     =  0.0      `from(   0.0,inf     ) `P(info="Gate overlap current pre-factor" unit="A" xyceUnit="U_AMP");
    parameter real    IGOVD    =  0.0      `from(   0.0,inf     ) `P(info="Gate overlap current pre-factor for drain side" unit="A" xyceUnit="U_AMP");
    parameter real    STIG     =  2.0                             `P(info="Temperature dependence of IGINV and IGOV" unit="");
    parameter real    GC2      =  0.375    `from(   0.0,10.0    ) `P(info="Gate current slope factor" unit="");
    parameter real    GC3      =  0.063    `from(  -2.0,2.0     ) `P(info="Gate current curvature factor" unit="");
    parameter real    CHIB     =  3.1      `from(   1.0,inf     ) `P(info="Tunneling barrier height" unit="V" xyceUnit="U_VOLT");

    //  Gate Induced Drain/Source Leakage (GIDL) parameters
    parameter real    AGIDL    =  0.0      `from(   0.0,inf     ) `P(info="GIDL pre-factor" unit="A/V^3" xyceUnit="U_AMPVM3");
    parameter real    AGIDLD   =  0.0      `from(   0.0,inf     ) `P(info="GIDL pre-factor for drain side" unit="A/V^3" xyceUnit="U_AMPVM3");
    parameter real    BGIDL    = 41.0      `from(   0.0,inf     ) `P(info="GIDL probability factor at TR" unit="V" xyceUnit="U_VOLT");
    parameter real    BGIDLD   = 41.0      `from(   0.0,inf     ) `P(info="GIDL probability factor at TR for drain side" unit="V" xyceUnit="U_VOLT");
    parameter real    STBGIDL  =  0.0                             `P(info="Temperature dependence of BGIDL" unit="V/K" xyceUnit="U_VKM1");
    parameter real    STBGIDLD =  0.0                             `P(info="Temperature dependence of BGIDL for drain side" unit="V/K" xyceUnit="U_VKM1");
    parameter real    CGIDL    =  0.0                             `P(info="Back-bias dependence of GIDL" unit="");
    parameter real    CGIDLD   =  0.0                             `P(info="Back-bias dependence of GIDL for drain side" unit="");

    //  Charge model parameters
    parameter real    COX      =  1.0e-14  `from(    0.0,inf    ) `P(info="Oxide capacitance for intrinsic channel" unit="F" xyceUnit="U_FARAD");
    parameter real    CGOV     =  1.0e-15  `from(    0.0,inf    ) `P(info="Oxide capacitance for gate-drain/source overlap" unit="F" xyceUnit="U_FARAD");
    parameter real    CGOVD    =  1.0e-15  `from(    0.0,inf    ) `P(info="Oxide capacitance for gate-drain overlap" unit="F" xyceUnit="U_FARAD");
    parameter real    CGBOV    =  0.0      `from(    0.0,inf    ) `P(info="Oxide capacitance for gate-bulk overlap" unit="F" xyceUnit="U_FARAD");
    parameter real    CFR      =  0.0      `from(    0.0,inf    ) `P(info="Outer fringe capacitance" unit="F" xyceUnit="U_FARAD");
    parameter real    CFRD     =  0.0      `from(    0.0,inf    ) `P(info="Outer fringe capacitance for drain side" unit="F" xyceUnit="U_FARAD");

    //  Noise parameters
    parameter real    FNT      =  1.0      `from(    0.0,inf    ) `P(info="Thermal noise coefficient" unit="");
    parameter real    NFA      =  8.0e+22  `from(    0.0,inf    ) `P(info="First coefficient of flicker noise" unit="V^-1/m^4");
    parameter real    NFB      =  3.0e+07  `from(    0.0,inf    ) `P(info="Second coefficient of flicker noise" unit="V^-1/m^2");
    parameter real    NFC      =  0.0      `from(    0.0,inf    ) `P(info="Third coefficient of flicker noise" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    EF       =  1.0      `from(    0.0,inf    ) `P(info="Flicker noise frequency exponent" unit="");

`ifdef NQSmodel

    //  NQS parameters
    parameter real    MUNQS    =  1.0      `from(    0.0,inf    ) `P(info="Relative mobility for NQS modelling");
`endif // NQSmodel

    // Parasitic resistance parameters
    parameter real    RG       =  0.0      `from(    0.0,inf    ) `P(info="Gate resistance" unit="Ohm" xyceUnit="U_OHM");
    parameter real    RSE      =  0.0      `from(    0.0,inf    ) `P(info="External source resistance" unit="Ohm" xyceUnit="U_OHM");
    parameter real    RDE      =  0.0      `from(    0.0,inf    ) `P(info="External drain resistance" unit="Ohm" xyceUnit="U_OHM");
    parameter real    RBULK    =  0.0      `from(    0.0,inf    ) `P(info="Bulk resistance between node BP and BI" unit="Ohm" xyceUnit="U_OHM");
    parameter real    RWELL    =  0.0      `from(    0.0,inf    ) `P(info="Well resistance between node BI and B" unit="Ohm" xyceUnit="U_OHM");
    parameter real    RJUNS    =  0.0      `from(    0.0,inf    ) `P(info="Source-side bulk resistance between node BI and BS" unit="Ohm" xyceUnit="U_OHM");
    parameter real    RJUND    =  0.0      `from(    0.0,inf    ) `P(info="Drain-side bulk resistance between node BI and BD" unit="Ohm" xyceUnit="U_OHM");

    ///////////////////////////////////////////////////
    // PSP global model parameters (binning)
    ///////////////////////////////////////////////////

    `include "PSP103_binpars.include"

    ///////////////////////////////////////////////////
    // PSP global model parameters
    ///////////////////////////////////////////////////

    // Process Parameters
    parameter real    LVARO    =  0.0                             `P(info="Geom. independent difference between actual and programmed gate length" unit="m" xyceUnit="U_METER");
    parameter real    LVARL    =  0.0                             `P(info="Length dependence of LVAR" unit="");
    parameter real    LVARW    =  0.0                             `P(info="Width dependence of LVAR" unit="");
    parameter real    LAP      =  0.0                             `P(info="Effective channel length reduction per side" unit="m" xyceUnit="U_METER");
    parameter real    WVARO    =  0.0                             `P(info="Geom. independent difference between actual and programmed field-oxide opening" unit="m" xyceUnit="U_METER");
    parameter real    WVARL    =  0.0                             `P(info="Length dependence of WVAR" unit="");
    parameter real    WVARW    =  0.0                             `P(info="Width dependence of WVAR" unit="");
    parameter real    WOT      =  0.0                             `P(info="Effective channel width reduction per side" unit="m" xyceUnit="U_METER");
    parameter real    DLQ      =  0.0                             `P(info="Effective channel length reduction for CV" unit="m" xyceUnit="U_METER");
    parameter real    DWQ      =  0.0                             `P(info="Effective channel width reduction for CV" unit="m" xyceUnit="U_METER");
    parameter real    VFBO     = -1.0                             `P(info="Geometry-independent flat-band voltage at TR" unit="V" xyceUnit="U_VOLT");
    parameter real    VFBL     =  0.0                             `P(info="Length dependence of flat-band voltage" unit="V" xyceUnit="U_VOLT");
    parameter real    VFBW     =  0.0                             `P(info="Width dependence of flat-band voltage" unit="V" xyceUnit="U_VOLT");
    parameter real    VFBLW    =  0.0                             `P(info="Area dependence of flat-band voltage" unit="V" xyceUnit="U_VOLT");
    parameter real    STVFBO   =  5e-4                            `P(info="Geometry-independent temperature dependence of VFB" unit="V/K" xyceUnit="U_VKM1");
    parameter real    STVFBL   =  0.0                             `P(info="Length dependence of temperature dependence of VFB" unit="V/K" xyceUnit="U_VKM1");
    parameter real    STVFBW   =  0.0                             `P(info="Width dependence of temperature dependence of VFB" unit="V/K" xyceUnit="U_VKM1");
    parameter real    STVFBLW  =  0.0                             `P(info="Area dependence of temperature dependence of VFB" unit="V/K" xyceUnit="U_VKM1");
    parameter real    TOXO     =  2e-9     `from(  1e-10,inf    ) `P(info="Gate oxide thickness" unit="m" xyceUnit="U_METER");
    parameter real    EPSROXO  =  3.9      `from(    1.0,inf    ) `P(info="Relative permittivity of gate dielectric" unit="");
    parameter real    NSUBO    =  3e23     `from(   1e20,inf    ) `P(info="Geometry independent substrate doping" unit="m^-3" xyceUnit="U_METERM3");
    parameter real    NSUBW    =  0.0                             `P(info="Width dependence of background doping NSUBO due to segregation" unit="");
    parameter real    WSEG     =  1e-8     `from(  1e-10,inf    ) `P(info="Char. length of segregation of background doping NSUBO" unit="m" xyceUnit="U_METER");
    parameter real    NPCK     =  1e24     `from(    0.0,inf    ) `P(info="Pocket doping level" unit="m^-3" xyceUnit="U_METERM3");
    parameter real    NPCKW    =  0.0                             `P(info="Width dependence of pocket doping NPCK due to segregation" unit="");
    parameter real    WSEGP    =  1e-8     `from(  1e-10,inf    ) `P(info="Char. length of segregation of pocket doping NPCK" unit="m" xyceUnit="U_METER");
    parameter real    LPCK     =  1e-8     `from(  1e-10,inf    ) `P(info="Char. length of lateral doping profile" unit="m" xyceUnit="U_METER");
    parameter real    LPCKW    =  0.0                             `P(info="Width dependence of char. length of lateral doping profile" unit="");
    parameter real    FOL1     =  0.0                             `P(info="First length dependence coefficient for short channel body effect" unit="");
    parameter real    FOL2     =  0.0                             `P(info="Second length dependence coefficient for short channel body effect" unit="");
    parameter real    FACNEFFACO= 1.0                             `P(info="Geom. independent pre-factor for effective substrate doping in separate charge calculation" unit="");
    parameter real    FACNEFFACL= 0.0                             `P(info="Length dependence of FACNEFFAC" unit="");
    parameter real    FACNEFFACW= 0.0                             `P(info="Width dependence of FACNEFFAC" unit="");
    parameter real    FACNEFFACLW=0.0                             `P(info="Area dependence of FACNEFFAC" unit="");
    parameter real    GFACNUDO =  1.0                             `P(info="Geom. independent bodyfactor change due to NUD-effect" unit="");
    parameter real    GFACNUDL =  0.0                             `P(info="Length dependence of GFACNUD" unit="");
    parameter real    GFACNUDLEXP = 1.0                           `P(info="Exponent for length dependence of GFACNUD" unit="");
    parameter real    GFACNUDW =  0.0                             `P(info="Width dependence of GFACNUD" unit="");
    parameter real    GFACNUDLW=  0.0                             `P(info="Area dependence of GFACNUD" unit="");
    parameter real    VSBNUDO  =  0.0                             `P(info="Lower Vsb value for NUD-effect" unit="V" xyceUnit="U_VOLT");
    parameter real    DVSBNUDO =  1.0                             `P(info="Vsb range for NUD-effect" unit="V" xyceUnit="U_VOLT");
    parameter real    VNSUBO   =  0.0                             `P(info="Effective doping bias-dependence parameter" unit="V" xyceUnit="U_VOLT");
    parameter real    NSLPO    =  0.05                            `P(info="Effective doping bias-dependence parameter" unit="V" xyceUnit="U_VOLT");
    parameter real    DNSUBO   =  0.0                             `P(info="Effective doping bias-dependence parameter" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    DPHIBO   =  0.0                             `P(info="Geometry independent offset of PHIB" unit="V" xyceUnit="U_VOLT");
    parameter real    DPHIBL   =  0.0                             `P(info="Length dependence offset of PHIB" unit="V" xyceUnit="U_VOLT");
    parameter real    DPHIBLEXP=  1.0                             `P(info="Exponent for length dependence of offset of PHIB" unit="");
    parameter real    DPHIBW   =  0.0                             `P(info="Width dependence of offset of PHIB" unit="V" xyceUnit="U_VOLT");
    parameter real    DPHIBLW  =  0.0                             `P(info="Area dependence of offset of PHIB" unit="V" xyceUnit="U_VOLT");
    parameter real    DELVTACO =  0.0                             `P(info="Geom. independent offset parameter for PHIB in separate charge calculation" unit="V" xyceUnit="U_VOLT");
    parameter real    DELVTACL =  0.0                             `P(info="Length dependence of DELVTAC" unit="V" xyceUnit="U_VOLT");
    parameter real    DELVTACLEXP= 1.0                            `P(info="Exponent for length dependence of offset of DELVTAC" unit="");
    parameter real    DELVTACW =  0.0                             `P(info="Width dependence of DELVTAC" unit="V" xyceUnit="U_VOLT");
    parameter real    DELVTACLW=  0.0                             `P(info="Area dependence of DELVTAC" unit="V" xyceUnit="U_VOLT");
    parameter real    NPO      =  1e26                            `P(info="Geometry-independent gate poly-silicon doping" unit="m^-3" xyceUnit="U_METERM3");
    parameter real    NPL      =  0.0                             `P(info="Length dependence of gate poly-silicon doping" unit="");
    parameter real    CTO      =  0.0                             `P(info="Geometry-independent interface states factor" unit="");
    parameter real    CTL      =  0.0                             `P(info="Length dependence of interface states factor" unit="");
    parameter real    CTLEXP   =  1.0                             `P(info="Exponent for length dependence of interface states factor" unit="");
    parameter real    CTW      =  0.0                             `P(info="Width dependence of interface states factor" unit="");
    parameter real    CTLW     =  0.0                             `P(info="Area dependence of interface states factor" unit="");
    parameter real    TOXOVO   =  2e-9     `from(  1e-10,inf    ) `P(info="Overlap oxide thickness" unit="m" xyceUnit="U_METER");
    parameter real    TOXOVDO  =  2e-9     `from(  1e-10,inf    ) `P(info="Overlap oxide thickness for drain side" unit="m" xyceUnit="U_METER");
    parameter real    LOV      =  0        `from(    0.0,inf    ) `P(info="Overlap length for gate/drain and gate/source overlap capacitance" unit="m" xyceUnit="U_METER");
    parameter real    LOVD     =  0        `from(    0.0,inf    ) `P(info="Overlap length for gate/drain overlap capacitance" unit="m" xyceUnit="U_METER");
    parameter real    NOVO     =  5e25                            `P(info="Effective doping of overlap region" unit="m^-3" xyceUnit="U_METERM3");
    parameter real    NOVDO    =  5e25                            `P(info="Effective doping of overlap region for drain side" unit="m^-3" xyceUnit="U_METERM3");

    // DIBL Parameters
    parameter real    CFL      =  0.0                             `P(info="Length dependence of DIBL-parameter" unit="");
    parameter real    CFLEXP   =  2.0                             `P(info="Exponent for length dependence of CF" unit="");
    parameter real    CFW      =  0.0                             `P(info="Width dependence of CF" unit="");
    parameter real    CFBO     =  0.0                             `P(info="Back-bias dependence of CF" unit="V^-1" xyceUnit="U_VOLTM1");

    // Mobility Parameters
    parameter real    UO       =  5e-2                            `P(info="Zero-field mobility at TR" unit="m^2/V/s" xyceUnit="U_M2VM1SM1");
    parameter real    FBET1    =  0.0                             `P(info="Relative mobility decrease due to first lateral profile" unit="");
    parameter real    FBET1W   =  0.0                             `P(info="Width dependence of relative mobility decrease due to first lateral profile" unit="");
    parameter real    LP1      =  1e-8     `from(  1e-10,inf    ) `P(info="Mobility-related characteristic length of first lateral profile" unit="m" xyceUnit="U_METER");
    parameter real    LP1W     =  0.0                             `P(info="Width dependence of mobility-related characteristic length of first lateral profile" unit="");
    parameter real    FBET2    =  0.0                             `P(info="Relative mobility decrease due to second lateral profile" unit="");
    parameter real    LP2      =  1e-8     `from(  1e-10,inf    ) `P(info="Mobility-related characteristic length of second lateral profile" unit="m" xyceUnit="U_METER");
    parameter real    BETW1    =  0.0                             `P(info="First higher-order width scaling coefficient of BETN" unit="");
    parameter real    BETW2    =  0.0                             `P(info="Second higher-order width scaling coefficient of BETN" unit="");
    parameter real    WBET     =  1e-9     `from(  1e-10,inf    ) `P(info="Characteristic width for width scaling of BETN" unit="m" xyceUnit="U_METER");
    parameter real    STBETO   =  1.0                             `P(info="Geometry independent temperature dependence of BETN" unit="");
    parameter real    STBETL   =  0.0                             `P(info="Length dependence of temperature dependence of BETN" unit="");
    parameter real    STBETW   =  0.0                             `P(info="Width dependence of temperature dependence of BETN" unit="");
    parameter real    STBETLW  =  0.0                             `P(info="Area dependence of temperature dependence of BETN" unit="");
    parameter real    MUEO     =  0.5                             `P(info="Geometry independent mobility reduction coefficient at TR" unit="m/V" xyceUnit="U_MVM1");
    parameter real    MUEW     =  0.0                             `P(info="Width dependence of mobility reduction coefficient at TR" unit="");
    parameter real    STMUEO   =  0.0                             `P(info="Temperature dependence of MUE" unit="");
    parameter real    THEMUO   =  1.5                             `P(info="Mobility reduction exponent at TR" unit="");
    parameter real    STTHEMUO =  1.5                             `P(info="Temperature dependence of THEMU" unit="");
    parameter real    CSO      =  0.0                             `P(info="Geometry independent coulomb scattering parameter at TR" unit="");
    parameter real    CSL      =  0.0                             `P(info="Length dependence of CS" unit="");
    parameter real    CSLEXP   =  1.0                             `P(info="Exponent for length dependence of CS" unit="");
    parameter real    CSW      =  0.0                             `P(info="Width dependence of CS" unit="");
    parameter real    CSLW     =  0.0                             `P(info="Area dependence of CS" unit="");
    parameter real    STCSO    =  0.0                             `P(info="Temperature dependence of CS" unit="");
    parameter real    XCORO    =  0.0                             `P(info="Geometry independent non-universality parameter" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    XCORL    =  0.0                             `P(info="Length dependence of non-universality parameter" unit="");
    parameter real    XCORW    =  0.0                             `P(info="Width dependence of non-universality parameter" unit="");
    parameter real    XCORLW   =  0.0                             `P(info="Area dependence of non-universality parameter" unit="");
    parameter real    STXCORO  =  0.0                             `P(info="Temperature dependence of XCOR" unit="");
    parameter real    FETAO    =  1.0                             `P(info="Effective field parameter" unit="");

    // Series Resistance
    parameter real    RSW1     = 50.0                             `P(info="Source/drain series resistance for 1 um wide channel at TR" unit="Ohm" xyceUnit="U_OHM");
    parameter real    RSW2     =  0.0                             `P(info="Higher-order width scaling of RS" unit="");
    parameter real    STRSO    =  1.0                             `P(info="Temperature dependence of RS" unit="");
    parameter real    RSBO     =  0.0                             `P(info="Back-bias dependence of series resistance" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    RSGO     =  0.0                             `P(info="Gate-bias dependence of series resistance" unit="V^-1" xyceUnit="U_VOLTM1");

    // Velocity Saturation
    parameter real    THESATO  =  0.0                             `P(info="Geometry independent velocity saturation parameter at TR" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    THESATL  =  0.05                            `P(info="Length dependence of THESAT" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    THESATLEXP= 1.0                             `P(info="Exponent for length dependence of THESAT" unit="");
    parameter real    THESATW  =  0.0                             `P(info="Width dependence of velocity saturation parameter" unit="");
    parameter real    THESATLW =  0.0                             `P(info="Area dependence of velocity saturation parameter" unit="");
    parameter real    STTHESATO=  1.0                             `P(info="Geometry independent temperature dependence of THESAT" unit="");
    parameter real    STTHESATL=  0.0                             `P(info="Length dependence of temperature dependence of THESAT" unit="");
    parameter real    STTHESATW=  0.0                             `P(info="Width dependence of temperature dependence of THESAT" unit="");
    parameter real    STTHESATLW= 0.0                             `P(info="Area dependence of temperature dependence of THESAT" unit="");
    parameter real    THESATBO =  0.0                             `P(info="Back-bias dependence of velocity saturation" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    THESATGO =  0.0                             `P(info="Gate-bias dependence of velocity saturation" unit="V^-1" xyceUnit="U_VOLTM1");

    // Saturation Voltage
    parameter real    AXO      =  18                              `P(info="Geometry independent linear/saturation transition factor" unit="");
    parameter real    AXL      =  0.4      `from(    0.0,inf    ) `P(info="Length dependence of AX" unit="");

    // Channel Length Modulation
    parameter real    ALPL     =  5e-4                            `P(info="Length dependence of ALP" unit="");
    parameter real    ALPLEXP  =  1.0                             `P(info="Exponent for length dependence of ALP" unit="");
    parameter real    ALPW     =  0.0                             `P(info="Width dependence of ALP" unit="");
    parameter real    ALP1L1   =  0.0                             `P(info="Length dependence of CLM enhancement factor above threshold" unit="V" xyceUnit="U_VOLT");
    parameter real    ALP1LEXP =  0.5                             `P(info="Exponent for length dependence of ALP1" unit="");
    parameter real    ALP1L2   =  0.0      `from(    0.0,inf    ) `P(info="Second order length dependence of ALP1" unit="");
    parameter real    ALP1W    =  0.0                             `P(info="Width dependence of ALP1" unit="");
    parameter real    ALP2L1   =  0.0                             `P(info="Length dependence of CLM enhancement factor below threshold" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    ALP2LEXP =  0.5                             `P(info="Exponent for length dependence of ALP2" unit="");
    parameter real    ALP2L2   =  0.0      `from(    0.0,inf    ) `P(info="Second order length dependence of ALP2" unit="");
    parameter real    ALP2W    =  0.0                             `P(info="Width dependence of ALP2" unit="");
    parameter real    VPO      =  0.05                            `P(info="CLM logarithmic dependence parameter" unit="V" xyceUnit="U_VOLT");

    // Weak-avalanche parameters
    parameter real    A1O      =  1.0                             `P(info="Geometry independent impact-ionization pre-factor" unit="");
    parameter real    A1L      =  0.0                             `P(info="Length dependence of A1" unit="");
    parameter real    A1W      =  0.0                             `P(info="Width dependence of A1" unit="");
    parameter real    A2O      =  10                              `P(info="Impact-ionization exponent at TR" unit="V" xyceUnit="U_VOLT");
    parameter real    STA2O    =  0.0                             `P(info="Temperature dependence of A2" unit="V" xyceUnit="U_VOLT");
    parameter real    A3O      =  1.0                             `P(info="Geometry independent saturation-voltage dependence of II" unit="");
    parameter real    A3L      =  0.0                             `P(info="Length dependence of A3" unit="");
    parameter real    A3W      =  0.0                             `P(info="Width dependence of A3" unit="");
    parameter real    A4O      =  0.0                             `P(info="Geometry independent back-bias dependence of II" unit="V^-0.5" xyceUnit="U_VOLTMH");
    parameter real    A4L      =  0.0                             `P(info="Length dependence of A4" unit="");
    parameter real    A4W      =  0.0                             `P(info="Width dependence of A4" unit="");

    // Gate current parameters
    parameter real    GCOO     =  0.0                             `P(info="Gate tunneling energy adjustment" unit="");
    parameter real    IGINVLW  =  0.0                             `P(info="Gate channel current pre-factor for 1 um**2 channel area" unit="A" xyceUnit="U_AMP");
    parameter real    IGOVW    =  0.0                             `P(info="Gate overlap current pre-factor for 1 um wide channel" unit="A" xyceUnit="U_AMP");
    parameter real    IGOVDW   =  0.0                             `P(info="Gate overlap current pre-factor for 1 um wide channel for drain side" unit="A" xyceUnit="U_AMP");
    parameter real    STIGO    =  2.0                             `P(info="Temperature dependence of IGINV and IGOV" unit="");
    parameter real    GC2O     =  0.375                           `P(info="Gate current slope factor" unit="");
    parameter real    GC3O     =  0.063                           `P(info="Gate current curvature factor" unit="");
    parameter real    CHIBO    =  3.1                             `P(info="Tunneling barrier height" unit="V" xyceUnit="U_VOLT");

    // Gate-induced drain leakage parameters
    parameter real    AGIDLW   =  0.0                             `P(info="Width dependence of GIDL pre-factor" unit="A/V^3" xyceUnit="U_AMPVM3");
    parameter real    AGIDLDW  =  0.0                             `P(info="Width dependence of GIDL pre-factor for drain side" unit="A/V^3" xyceUnit="U_AMPVM3");
    parameter real    BGIDLO   =  41                              `P(info="GIDL probability factor at TR" unit="V" xyceUnit="U_VOLT");
    parameter real    BGIDLDO  =  41                              `P(info="GIDL probability factor at TR for drain side" unit="V" xyceUnit="U_VOLT");
    parameter real    STBGIDLO =  0.0                             `P(info="Temperature dependence of BGIDL" unit="V/K" xyceUnit="U_VKM1");
    parameter real    STBGIDLDO=  0.0                             `P(info="Temperature dependence of BGIDL for drain side" unit="V/K" xyceUnit="U_VKM1");
    parameter real    CGIDLO   =  0.0                             `P(info="Back-bias dependence of GIDL" unit="");
    parameter real    CGIDLDO  =  0.0                             `P(info="Back-bias dependence of GIDL for drain side" unit="");

    // Charge Model Parameters
    parameter real    CGBOVL   =  0.0                             `P(info="Oxide capacitance for gate-bulk overlap for 1 um long channel" unit="F" xyceUnit="U_FARAD");
    parameter real    CFRW     =  0.0                             `P(info="Outer fringe capacitance for 1 um wide channel" unit="F" xyceUnit="U_FARAD");
    parameter real    CFRDW    =  0.0                             `P(info="Outer fringe capacitance for 1 um wide channel for drain side" unit="F" xyceUnit="U_FARAD");

    // Noise Model Parameters
    parameter real    FNTO     =  1.0                             `P(info="Thermal noise coefficient" unit="");
    parameter real    NFALW    =  8e22                            `P(info="First coefficient of flicker noise for 1 um**2 channel area" unit="V^-1/m^4");
    parameter real    NFBLW    =  3e7                             `P(info="Second coefficient of flicker noise for 1 um**2 channel area" unit="V^-1/m^2");
    parameter real    NFCLW    =  0.0                             `P(info="Third coefficient of flicker noise for 1 um**2 channel area" unit="V^-1" xyceUnit="U_VOLTM1");
    parameter real    EFO      =  1.0                             `P(info="Flicker noise frequency exponent" unit="");
    parameter real    LINTNOI  =  0.0                             `P(info="Length offset for flicker noise" unit="m" xyceUnit="U_METER");
    parameter real    ALPNOI   =  2.0                             `P(info="Exponent for length offset for flicker noise" unit="");

    // Well proximity effect Parameters
    parameter real    KVTHOWEO =  0                               `P(info="Geometrical independent threshold shift parameter" unit="");
    parameter real    KVTHOWEL =  0                               `P(info="Length dependent threshold shift parameter" unit="");
    parameter real    KVTHOWEW =  0                               `P(info="Width dependent threshold shift parameter" unit="");
    parameter real    KVTHOWELW=  0                               `P(info="Area dependent threshold shift parameter" unit="");
    parameter real    KUOWEO   =  0                               `P(info="Geometrical independent mobility degradation factor" unit="");
    parameter real    KUOWEL   =  0                               `P(info="Length dependent mobility degradation factor" unit="");
    parameter real    KUOWEW   =  0                               `P(info="Width dependent mobility degradation factor" unit="");
    parameter real    KUOWELW  =  0                               `P(info="Area dependent mobility degradation factor" unit="");

    ///////////////////////////////////////////////////
    // Parameters that occur in both global and binning model
    ///////////////////////////////////////////////////

`ifdef NQSmodel
    parameter real    MUNQSO   =  1.0                             `P(info="Relative mobility for NQS modelling");
`endif // NQSmodel

    // Parasitic resistance parameters
    parameter real    RGO      =  0.0                             `P(info="Gate resistance" unit="Ohm" xyceUnit="U_OHM");
    parameter real    RINT     =  0.0      `from(    0.0,inf    ) `P(info="Contact resistance between silicide and ploy" unit="Ohm m^2" xyceUnit="U_OHMM2");
    parameter real    RVPOLY   =  0.0      `from(    0.0,inf    ) `P(info="Vertical poly resistance" unit="Ohm m^2" xyceUnit="U_OHMM2");
    parameter real    RSHG     =  0.0      `from(    0.0,inf    ) `P(info="Gate electrode diffusion sheet resistance" unit="Ohm/Sqr" xyceUnit="U_OSQM1");
    parameter real    DLSIL    =  0.0                             `P(info="Silicide extension over the physical gate length" unit="m" xyceUnit="U_METER");
    parameter real    RSH      =  0.0                             `P(info="Sheet resistance of source diffusion" unit="Ohm/sq"  xyceUnit="U_OSQM1");
    parameter real    RSHD     =  0.0                             `P(info="Sheet resistance of drain diffusion" unit="Ohm/sq"  xyceUnit="U_OSQM1");
    parameter real    RBULKO   =  0.0                             `P(info="Bulk resistance between node BP and BI" unit="Ohm" xyceUnit="U_OHM");
    parameter real    RWELLO   =  0.0                             `P(info="Well resistance between node BI and B" unit="Ohm" xyceUnit="U_OHM");
    parameter real    RJUNSO   =  0.0                             `P(info="Source-side bulk resistance between node BI and BS" unit="Ohm" xyceUnit="U_OHM");
    parameter real    RJUNDO   =  0.0                             `P(info="Drain-side bulk resistance between node BI and BD" unit="Ohm" xyceUnit="U_OHM");

    // Stress Model Parameters
    parameter real    SAREF    =  1.0e-6   `from(   1e-9,inf    ) `P(info="Reference distance between OD-edge and poly from one side" unit="m" xyceUnit="U_METER");
    parameter real    SBREF    =  1.0e-6   `from(   1e-9,inf    ) `P(info="Reference distance between OD-edge and poly from other side" unit="m" xyceUnit="U_METER");
    parameter real    WLOD     =  0                               `P(info="Width parameter" unit="m" xyceUnit="U_METER");
    parameter real    KUO      =  0                               `P(info="Mobility degradation/enhancement coefficient" unit="m" xyceUnit="U_METER");
    parameter real    KVSAT    =  0        `from(   -1.0,1.0    ) `P(info="Saturation velocity degradation/enhancement coefficient" unit="m" xyceUnit="U_METER");
    parameter real    TKUO     =  0                               `P(info="Temperature dependence of KUO" unit="");
    parameter real    LKUO     =  0                               `P(info="Length dependence of KUO" unit="m^LLODKUO");
    parameter real    WKUO     =  0                               `P(info="Width dependence of KUO" unit="m^WLODKUO");
    parameter real    PKUO     =  0                               `P(info="Cross-term dependence of KUO" unit="m^(LLODKUO+WLODKUO)");
    parameter real    LLODKUO  =  0        `from(    0.0,inf    ) `P(info="Length parameter for UO stress effect" unit="");
    parameter real    WLODKUO  =  0        `from(    0.0,inf    ) `P(info="Width parameter for UO stress effect" unit="");
    parameter real    KVTHO    =  0                               `P(info="Threshold shift parameter" unit="Vm" xyceUnit="U_VM");
    parameter real    LKVTHO   =  0                               `P(info="Length dependence of KVTHO" unit="m^LLODVTH");
    parameter real    WKVTHO   =  0                               `P(info="Width dependence of KVTHO" unit="m^WLODVTH");
    parameter real    PKVTHO   =  0                               `P(info="Cross-term dependence of KVTHO" unit="m^(LLODVTH+WLODVTH)");
    parameter real    LLODVTH  =  0        `from(    0.0,inf    ) `P(info="Length parameter for VTH-stress effect" unit="");
    parameter real    WLODVTH  =  0        `from(    0.0,inf    ) `P(info="Width parameter for VTH-stress effect" unit="");
    parameter real    STETAO   =  0                               `P(info="eta0 shift factor related to VTHO change" unit="m" xyceUnit="U_METER");
    parameter real    LODETAO  =  1.0      `from(    0.0,inf    ) `P(info="eta0 shift modification factor for stress effect" unit="");

    // Well proximity effect Parameters
    parameter real    SCREF    =  1.0e-6   `from(    0.0,inf    ) `P(info="Distance between OD-edge and well edge of a reference device" unit="m" xyceUnit="U_METER");
    parameter real    WEB      =  0                               `P(info="Coefficient for SCB" unit="");
    parameter real    WEC      =  0                               `P(info="Coefficient for SCC" unit="");

    ///////////////////////////////////////////////////
    // JUNCAP Parameters
    ///////////////////////////////////////////////////

    `include "JUNCAP200_parlist.include"

    //  Other parameters
    parameter real    DTA      =  0.0                             `P(info="Temperature offset w.r.t. ambient temperature" unit="K" xyceUnit="U_DEGK");

    ///////////////////////////////////////////////////
    // Instance parameters
    ///////////////////////////////////////////////////

    // Instance parameters for global and binning models only
    parameter real    L        =  10e-6    `from(   1e-9,inf    ) `P(type="instance" info="Design length" unit="m" xyceUnit="U_METER");
    parameter real    W        =  10e-6    `from(   1e-9,inf    ) `P(type="instance" info="Design width" unit="m" xyceUnit="U_METER");
    parameter real    SA       =  0.0                             `P(type="instance" info="Distance between OD-edge and poly from one side" unit="m" xyceUnit="U_METER");
    parameter real    SB       =  0.0                             `P(type="instance" info="Distance between OD-edge and poly from other side" unit="m" xyceUnit="U_METER");
    parameter real    SD       =  0.0                             `P(type="instance" info="Distance between neighbouring fingers" unit="m" xyceUnit="U_METER");
    parameter real    SCA      =  0.0      `from(    0.0,inf    ) `P(type="instance" info="Integral of the first distribution function for scattered well dopants" unit="");
    parameter real    SCB      =  0.0      `from(    0.0,inf    ) `P(type="instance" info="Integral of the second distribution function for scattered well dopants" unit="");
    parameter real    SCC      =  0.0      `from(    0.0,inf    ) `P(type="instance" info="Integral of the third distribution function for scattered well dopants" unit="");
    parameter real    SC       =  0.0                             `P(type="instance" info="Distance between OD-edge and nearest well edge" unit="m" xyceUnit="U_METER");
    parameter real    NF       =  1.0      `from(    1.0,inf    ) `P(type="instance" info="Number of fingers" unit="");
    parameter real    NGCON    =  1.0      `from(    1.0,2.0    ) `P(type="instance" info="Number of gate contacts" unit="");
    parameter real    XGW      =  1.0E-7                          `P(type="instance" info="Distance from the gate contact to the channel edge" unit="m" xyceUnit="U_METER");
    parameter real    NRS      =  0.0                             `P(type="instance" info="Number of squares of source diffusion" unit="");
    parameter real    NRD      =  0.0                             `P(type="instance" info="Number of squares of drain diffusion" unit="");

    // Instance parameters for local model only
    parameter real    JW         = 1E-6    `from(`LG_cliplow,inf) `P(type="instance" info="Gate-edge length of source/drain junction" unit="m" xyceUnit="U_METER");

    // Instance parameters for global, binning, and local models
    parameter real    DELVTO   =  0.0                             `P(type="instance" info="Threshold voltage shift parameter" unit="V" xyceUnit="U_VOLT");
    parameter real    FACTUO   =  1.0      `from(    0.0,inf    ) `P(type="instance" info="Zero-field mobility pre-factor" unit="");
    parameter real    ABSOURCE = 1E-12     `from(`AB_cliplow,inf) `P(type="instance" info="Bottom area of source junction" unit="m^2");
    parameter real    LSSOURCE = 1E-6      `from(`LS_cliplow,inf) `P(type="instance" info="STI-edge length of source junction" unit="m" xyceUnit="U_METER");
    parameter real    LGSOURCE = 1E-6      `from(`LG_cliplow,inf) `P(type="instance" info="Gate-edge length of source junction" unit="m" xyceUnit="U_METER");
    parameter real    ABDRAIN  = 1E-12     `from(`AB_cliplow,inf) `P(type="instance" info="Bottom area of drain junction" unit="m^2");
    parameter real    LSDRAIN  = 1E-6      `from(`LS_cliplow,inf) `P(type="instance" info="STI-edge length of drain junction" unit="m" xyceUnit="U_METER");
    parameter real    LGDRAIN  = 1E-6      `from(`LG_cliplow,inf) `P(type="instance" info="Gate-edge length of drain junction" unit="m" xyceUnit="U_METER");
    parameter real    AS       = 1E-12     `from(`AB_cliplow,inf) `P(type="instance" info="Bottom area of source junction" unit="m^2");
    parameter real    PS       = 1E-6      `from(`LS_cliplow,inf) `P(type="instance" info="Perimeter of source junction" unit="m" xyceUnit="U_METER");
    parameter real    AD       = 1E-12     `from(`AB_cliplow,inf) `P(type="instance" info="Bottom area of drain junction" unit="m^2");
    parameter real    PD       = 1E-6      `from(`LS_cliplow,inf) `P(type="instance" info="Perimeter of drain junction" unit="m" xyceUnit="U_METER");
    parameter real    MULT     =  1.0      `from(    0.0,inf    ) `P(type="instance" info="Number of devices in parallel" unit="");

    //////////////////////////
    //
    //  Variables
    //
    //////////////////////////

    // Variables for geometrical scaling rules
    real L_i, W_i, L_f, L_slif, W_f, SA_i, SB_i, SD_i, SC_i;
    real LEN, WEN, iL, iW, delLPS, delWOD, LE, WE, iLE, iWE, Lcv, Wcv, LEcv, WEcv;

    // Auxiliary variables for binning-rules
    real iLEWE, iiLE, iiWE, iiLEWE, iiiLEWE;
    real iLEcv, iiLEcv, iiWEcv, iiLEWEcv, iiiLEWEcv;
    real iLcv, iiLcv, iiWcv, iiLWcv, iiiLWcv;

    // Intermediate variables used for geometry-scaling
    real NSUBO_i, WSEG_i, NPCK_i, WSEGP_i, LPCK_i, LOV_i, LOVD_i;
    real LP1_i, LP2_i, WBET_i, AXL_i, ALP1L2_i, ALP2L2_i;
    real NSUB, AA, BB, NSUB0e, NPCKe, LPCKe;
    real FBET1e, LP1e, GPE, GWE, tmpx;
    real TOXO_i, TOXOVO_i, TOXOVDO_i, EPSROXO_i, XGW_i;
    real Lnoi, Lred;

    // List of local parameters
    real VFB_p, STVFB_p, TOX_p, EPSROX_p, NEFF_p, FACNEFFAC_p, GFACNUD_p, VSBNUD_p, DVSBNUD_p, VNSUB_p, NSLP_p, DNSUB_p, DPHIB_p, DELVTAC_p, NP_p, CT_p;
    real TOXOV_p, TOXOVD_p, NOV_p, NOVD_p, CF_p, CFB_p;
    real BETN_p, STBET_p, MUE_p, STMUE_p, THEMU_p, STTHEMU_p, CS_p, STCS_p, XCOR_p, STXCOR_p, FETA_p;
    real RS_p, STRS_p, RSB_p, RSG_p;
    real THESAT_p, STTHESAT_p, THESATB_p, THESATG_p;
    real AX_p;
    real ALP_p, ALP1_p, ALP2_p, VP_p;
    real A1_p, A2_p, STA2_p, A3_p, A4_p;
    real GCO_p, IGINV_p, IGOV_p, IGOVD_p, STIG_p, GC2_p, GC3_p, CHIB_p;
    real AGIDL_p, BGIDL_p, STBGIDL_p, CGIDL_p;
    real AGIDLD_p, BGIDLD_p, CGIDLD_p, STBGIDLD_p;
    real COX_p, CGOV_p, CGBOV_p, CGOVD_p, CFR_p, CFRD_p;
    real FNT_p, NFA_p, NFB_p, NFC_p, EF_p;
    real RG_p, RSE_p, RDE_p, RBULK_p, RWELL_p, RJUNS_p, RJUND_p;
`ifdef NQSmodel
    real MUNQS_p;
`endif // NQSmodel

    real NF_i, invNF;
    real RINT_i, RVPOLY_i, RSHG_i, RSH_i, RSHD_i, NGCON_i, XGWE;

    // Variables for stress-model
    real SAREF_i, SBREF_i, KVSAT_i, LLODKUO_i, WLODKUO_i, LLODVTH_i, WLODVTH_i, LODETAO_i;
    real Invsa, Invsb, Invsaref, Invsbref, Kstressu0, rhobeta, rhobetaref, Kstressvth0;
    real temp0, temp00, templ, tempw, Lx, Wx;
    real loop, tmpa, tmpb;

    // Variables for well proximity effect model
    real SCA_i, SCB_i, SCC_i, SCREF_i, WEB_i, WEC_i, KVTHOWE, KUOWE;

    real ABS_i, LSS_i, LGS_i, ABD_i, LSD_i, LGD_i;

    // Scaled and clipped local parameters
    
    real FACTUO_i, DELVTO_i, VFB_i, STVFB_i, TOX_i, EPSROX_i, NEFF_i, NEFFAC_i, FACNEFFAC_i, GFACNUD_i, VSBNUD_i, DVSBNUD_i, DELVTAC_i;
    real VNSUB_i, NSLP_i, DNSUB_i, NP_i, QMC_i, CT_i, TOXOV_i, TOXOVD_i, NOV_i, NOVD_i;
    real CF_i, CFB_i, DPHIB_i;
    real BETN_i, STBET_i, MUE_i, STMUE_i, THEMU_i, STTHEMU_i, CS_i, STCS_i, XCOR_i, STXCOR_i, FETA_i;
    real RS_i, THER_i, STRS_i, RSB_i, RSG_i;
    real THESAT_i, STTHESAT_i, THESATB_i, THESATG_i;
    real AX_i, ALP_i, ALP1_i, ALP2_i, VP_i;
    real A1_i, A2_i, STA2_i, A3_i, A4_i;
    real GCO_i, IGINV_i, IGOV_i, IGOVD_i, STIG_i, GC2_i, GC3_i, CHIB_i;
    real AGIDL_i, BGIDL_i, STBGIDL_i, CGIDL_i;
    real AGIDLD_i, BGIDLD_i, STBGIDLD_i, CGIDLD_i;
    real COX_i, CGOV_i, CGOVD_i, CGBOV_i, CFR_i, CFRD_i;
    real FNT_i, NFA_i, NFB_i, NFC_i, EF_i;
    real TR_i, MULT_i;

    // Variables used in electrical equations
    real temp, temp1, temp2, tempM;
    real help;
    real jwcorr, jww;

    real TKR, TKD, TKD_sq, dT, rT, rTn;
    real EPSOX, EPSSI;
    real BET_i, phit, inv_phit, Eg, phibFac, CoxPrime, tox_sq;
    real delVg, CoxovPrime, GOV, GOV2;
    real np, kp, qq, qb0, dphibq, qlim2;
    real E_eff0, eta_mu, eta_mu1, BCH, BOV, inv_CHIB, GCQ, Dch, Dov;
    real tf_bet, tf_mue, tf_cs, tf_xcor, tf_ther, tf_thesat, tf_ig;
    real xi_ov, inv_xi_ov, x_mrg_ov, x1, inv_xg1, Vdsat_lim;
    real nt, Cox_over_q;

    real CoxovPrime_d, GOV_s, GOV_d, GOV2_s, GOV2_d;
    real BOV_d, xi_ov_s, xi_ov_d, inv_xi_ov_s, inv_xi_ov_d, x_mrg_ov_s, x_mrg_ov_d, inv_xg1_s, inv_xg1_d;

    real phix2, phit1, inv_phit1, alpha_b;
    real inv_VP, inv_AX, Sfl_prefac;

    real sigVds, Vgs, Vgd, Vds, Vsb;
    real Vgb, Vgb1, Vgbstar, Vdb, Vdbstar, Vdsx;
    real us, us1, us21, Vmb, usnew, Vmbnew, Vsbnud;
    real VgsPrime, VgdPrime, VsbPrime, VdbPrime;
    real mutau, nu;

    real xg_dc, qeff1_dc, Voxm_dc, alpha_dc, dps_dc, qim_dc, qim1_dc, GdL_dc, H_dc, phib_dc, sqrt_phib_dc;
    real G_0_dc, aphi_dc, bphi_dc, phix_dc, phix1_dc, eta_p_dc, Gvsat_dc, Vsbstar_dc, Gmob_dL_dc, x_m_dc, Gf_dc;
    real FdL_dc, Gvsatinv_dc, x_ds_dc, Vdsat_dc, Udse_dc;
    real xg_ac, qeff1_ac, Voxm_ac, alpha_ac, dps_ac, qim_ac, qim1_ac, GdL_ac, H_ac, phib_ac, sqrt_phib_ac;
    real G_0_ac, aphi_ac, bphi_ac, phix_ac, phix1_ac, eta_p_ac, Gvsat_ac, Vsbstar_ac, Gmob_dL_ac, x_m_ac, Gf_ac;
`ifdef NQSmodel
    real xgm_dc, margin_dc, thesat1_dc;
    real xgm_ac, margin_ac, thesat1_ac;
`endif // NQSmodel

    real SP_OV_yg, SP_OV_z, SP_OV_eta, SP_OV_a, SP_OV_c;
    real SP_OV_tau, SP_OV_D0, SP_OV_y0, SP_OV_xi, SP_OV_temp;
    real SP_OV_p, SP_OV_q, SP_OV_w, SP_OV_Afac, SP_OV_xbar;
    real SP_OV_x0, SP_OV_u;

    real xs_ov, xd_ov, Vovs, Vovd, psi_t, xgs_ov, xgd_ov;
    real zg, delVsat, TP, Dsi, Dgate, u0, u0_div_H, x, xsq, inv_x, ex, inv_ex, Ag, Bg, Sg, Vm;
    real QCLM, COX_qm, Fj, Fj2;
    real N1, Nm1, Delta_N1, Sfl;
    real H0, t1, t2, sqt2, r, lc, lcinv2, g_ideal, CGeff, mid, mig, migid, c_igid, sqid, sqig;
    real shot_igs, shot_igd, shot_iavl;
    real shot_igcsx, shot_igcdx, shot_igsov, shot_igdov;

    real Ids, Iimpact, mavl, Igdov, Igsov, Igc0, igc, igcd_h;
    real Igidl, Igisl, Vtovd, Vtovs;
    real Igc, Igcd, Igcs, Igb;
    real Idse, Igbe, Igidle, Igisle, Iimpacte;
    real Igcse, Igcde, Igsove, Igdove;
    real QI, QD, QB, QG, Qg, Qd, Qb, Qs, Qgs_ov, Qgd_ov;
    real Qfgs, Qfgd, Qgb_ov;

    real arg1, arg2max, arg2mina;

    real RG_i, RSE_i, RDE_i, RBULK_i, RWELL_i, RJUNS_i, RJUND_i;
    real Vrg, Vrs, Vrd, Vrbulk, Vrwell, Vrjund, Vrjuns;
    real ggate, gsource, gdrain, gbulk, gwell, gjund, gjuns, nt0;
    real rgatenoise, rsourcenoise, rdrainnoise, rbulknoise, rwellnoise, rjundnoise, rjunsnoise;


    integer CHNL_TYPE, SWGEO_i, SWIGATE_i, SWIMPACT_i, SWGIDL_i, SWJUNCAP_i, SWJUNASYM_i, SWNUD_i, SWDELVTAC_i;

`ifdef NQSmodel
    // Variables used in NQS-calculations
    integer SWNQS_i;
    real MUNQS_i;
    real Qp1_0, Qp2_0, Qp3_0, Qp4_0, Qp5_0, Qp6_0, Qp7_0, Qp8_0, Qp9_0;
    real fk1, fk2, fk3, fk4, fk5, fk6, fk7, fk8, fk9;

    real phi_p1, phi_p2, phi_p3;
    real phi_p4, phi_p5, phi_p6;
    real phi_p7, phi_p8, phi_p9;

    real Qp1, Qp2, Qp3;
    real Qp4, Qp5, Qp6;
    real Qp7, Qp8, Qp9;
    real Qp0, QpN;

    real QG_NQS, QS_NQS, QD_NQS;
    real pd, Gp, Gp2, a_factrp, marginp, x_sp, x_dp, zsat_nqs;

    real dfQi, fQi, dQis, dQis_1, d2Qis, dQbs, dQy, d2Qy, dpsy2;
    real ym, inorm, Tnorm, Qb_tmp, QbSIGN;
    real r_nqs, vnorm, vnorm_inv;
    real NQS_xg1, NQS_yg, NQS_z, NQS_eta, NQS_a, NQS_c, NQS_tau, NQS_D0, NQS_xi, NQS_p;
    real NQS_q, NQS_temp, NQS_A_fac, NQS_xbar, NQS_w, NQS_x0, NQS_u, NQS_y0;
    real xphi, fk0, thesat2, Fvsat;
    real temp3, temp4, temp5, temp6, temp7, temp8, temp9;
`endif // NQSmodel

    // JUNCAP2 variables
    `include "JUNCAP200_varlist1.include"
    `define JUNCAP_SourceSide
    `include "JUNCAP200_varlist2.include"
    `undef JUNCAP_SourceSide
    `include "JUNCAP200_varlist2.include"
    real jnoisex_s, jnoisex_d, JW_i;
    real Vjun_s, Vjun_d;



    /////////////////////////////////////////////////////////////////////////////
    //
    // Variables for operating point info
    //
    /////////////////////////////////////////////////////////////////////////////

    real id_op, is, ig, ib, P_D, facvsb, facvsb0, sig1k;

    `OPdef(ctype,"Flag for channel type", "")
    `OPdef(sdint,"Flag for source-drain interchange", "")

    `OPdef(ise  ,"Total source current", "A")
    `OPdef(ige  ,"Total gate current", "A")  
    `OPdef(ide  ,"Total drain current", "A") 
    `OPdef(ibe  ,"Total bulk current", "A")  
    `OPdef(ids  ,"Drain current, excl. avalanche, tunnel, GISL, GIDL, and junction currents", "A")
    `OPdef(idb  ,"Drain to bulk current", "A")
    `OPdef(isb  ,"Source to bulk current", "A")
    `OPdef(igs  ,"Gate-source tunneling current", "A")
    `OPdef(igd  ,"Gate-drain tunneling current", "A")
    `OPdef(igb  ,"Gate-bulk tunneling current", "A")
    `OPdef(igcs ,"Gate-channel tunneling current (source component)", "A")
    `OPdef(igcd ,"Gate-channel tunneling current (drain component)", "A")
    `OPdef(iavl ,"Substrate current due to weak avelanche", "A")
    `OPdef(igisl,"Gate-induced source leakage current", "A")
    `OPdef(igidl,"Gate-induced drain leakage current", "A")

    `OPdef(ijs   ,"Total source junction current", "A")
    `OPdef(ijsbot,"Source junction current (bottom component)", "A")
    `OPdef(ijsgat,"Source junction current (gate-edge component)", "A")
    `OPdef(ijssti,"Source junction current (STI-edge component)", "A")
    `OPdef(ijd   ,"Total drain junction current", "A")
    `OPdef(ijdbot,"Drain junction current (bottom component)", "A")
    `OPdef(ijdgat,"Drain junction current (gate-edge component)", "A")
    `OPdef(ijdsti,"Drain junction current (STI-edge component)", "A")

    `OPdef(vds ,"Drain-source voltage", "V")
    `OPdef(vgs ,"Gate-source voltage", "V")
    `OPdef(vsb ,"Source-bulk voltage", "V")
    `OPdef(vto ,"Zero-bias threshold voltage", "V")
    `OPdef(vts ,"Threshold voltage including back bias effects", "V")
    `OPdef(vth ,"Threshold voltage including back bias and drain bias effects", "V")
    `OPdef(vgt ,"Effective gate drive voltage including back bias and drain bias effects", "V")
    `OPdef(vdss,"Drain saturation voltage at actual bias", "V")
    `OPdef(vsat,"Saturation limit", "")
    
`ifdef OPderiv
    `OPdef(gm ,"Transconductance", "1/Ohm")
    `OPdef(gmb,"Substrate transconductance", "1/Ohm")
    `OPdef(gds,"Output conductance", "1/Ohm")
    `OPdef(gjs,"Source junction conductance", "1/Ohm")
    `OPdef(gjd,"Drain junction conductance", "1/Ohm")
  
    `OPdef(cdd  ,"Drain capacitance", "F")
    `OPdef(cdg  ,"Drain-gate capacitance", "F")
    `OPdef(cds  ,"Drain-source capacitance", "F")
    `OPdef(cdb  ,"Drain-bulk capacitance", "F")
    `OPdef(cgd  ,"Gate-drain capacitance", "F")
    `OPdef(cgg  ,"Gate capacitance", "F")
    `OPdef(cgs  ,"Gate-source capacitance", "F")
    `OPdef(cgb  ,"Gate-bulk capacitance", "F")
    `OPdef(csd  ,"Source-drain capacitance", "F")
    `OPdef(csg  ,"Source-gate capacitance", "F")
    `OPdef(css  ,"Source capacitance", "F")
    `OPdef(csb  ,"Source-bulk capacitance", "F")
    `OPdef(cbd  ,"Bulk-drain capacitance", "F")
    `OPdef(cbg  ,"Bulk-gate capacitance", "F")
    `OPdef(cbs  ,"Bulk-source capacitance", "F")
    `OPdef(cbb  ,"Bulk capacitance", "F")
    `OPdef(cgsol,"Total gate-source overlap capacitance", "F")
    `OPdef(cgdol,"Total gate-drain overlap capacitance", "F")

    `OPdef(cjs   ,"Total source junction capacitance", "F")
    `OPdef(cjsbot,"Source junction capacitance (bottom component)", "F")
    `OPdef(cjsgat,"Source junction capacitance (gate-edge component)", "F")
    `OPdef(cjssti,"Source junction capacitance (STI-edge component)", "F")
    `OPdef(cjd   ,"Total drain junction capacitance", "F")
    `OPdef(cjdbot,"Drain junction capacitance (bottom component)", "F")
    `OPdef(cjdgat,"Drain junction capacitance (gate-edge component)", "F")
    `OPdef(cjdsti,"Drain junction capacitance (STI-edge component)", "F")
`endif // OPderiv
    
    `OPdef(weff  ,"Effective channel width for geometrical models", "m")
    `OPdef(leff  ,"Effective channel length for geometrical models", "m")
`ifdef OPderiv
    `OPdef(u     ,"Transistor gain", "")
    `OPdef(rout  ,"Small-signal output resistance", "Ohm")
    `OPdef(vearly,"Equivalent Early voltage", "V")
    `OPdef(beff  ,"Gain factor", "A/V^2")
    `OPdef(fug   ,"Unity gain frequency at actual bias", "Hz")
    `OPdef(rg    ,"Gate resistance", "Ohm")
    
    `OPdef(sfl    ,"Flicker noise current density at 1 Hz", "")
    `OPdef(sqrtsff,"Input-referred RMS white noise voltage density at 1 kHz", "")
    `OPdef(sqrtsfw,"Input-referred RMS white noise voltage density", "")
    `OPdef(sid    ,"White noise current density", "")
    `OPdef(sig    ,"Induced gate noise current density at 1 Hz", "")
    `OPdef(cigid  ,"Imaginary part of correlation coefficient between Sig and Sid", "")
    `OPdef(fknee  ,"Cross-over frequency above which  white noise is dominant", "")
    `OPdef(sigs   ,"Gate-source current noise spectral density", "")
    `OPdef(sigd   ,"Gate-drain current noise spectral density", "")
    `OPdef(siavl  ,"Impact ionization current noise spectral density", "")
    `OPdef(ssi    ,"Total source junction current noise spectral density", "")
    `OPdef(sdi    ,"Total drain junction current noise specral density", "")
`endif // OPderiv

    // local parameters after scaling, T-scaling, and clipping
    `OPdef(lp_vfb      , "Local parameter VFB after T-scaling and clipping", "V")
    `OPdef(lp_stvfb    , "Local parameter STVFB after clipping", "V/K")
    `OPdef(lp_tox      , "Local parameter TOX after clipping", "m")
    `OPdef(lp_epsrox   , "Local parameter EPSROX after clipping", "")
    `OPdef(lp_neff     , "Local parameter NEFF after clipping", "m^-3")
    `OPdef(lp_facneffac, "Local parameter FACNEFFAC after clipping", "")
    `OPdef(lp_gfacnud  , "Local parameter GFACNUD after clipping", "")
    `OPdef(lp_vsbnud   , "Local parameter VSBNUD after clipping", "V")
    `OPdef(lp_dvsbnud  , "Local parameter DVSBNUD after clipping", "V")
    `OPdef(lp_vnsub    , "Local parameter VNSUB after clipping", "V")
    `OPdef(lp_nslp     , "Local parameter NSLP after clipping", "V")
    `OPdef(lp_dnsub    , "Local parameter DNSUB after clipping", "V^-1")
    `OPdef(lp_dphib    , "Local parameter DPHIB after clipping", "V")
    `OPdef(lp_delvtac  , "Local parameter DELVTAC after clipping", "V")
    `OPdef(lp_np       , "Local parameter NP after clipping", "m^-3")
    `OPdef(lp_ct       , "Local parameter CT after clipping", "")
    `OPdef(lp_toxov    , "Local parameter TOXOV after clipping", "m")
    `OPdef(lp_toxovd   , "Local parameter TOXOVD after clipping", "m")
    `OPdef(lp_nov      , "Local parameter NOV after clipping", "m^-3")
    `OPdef(lp_novd     , "Local parameter NOVD after clipping", "m^-3")
    `OPdef(lp_cf       , "Local parameter CF after clipping", "")
    `OPdef(lp_cfb      , "Local parameter CFB after clipping", "V^-1")
    `OPdef(lp_betn     , "Local parameter BETN after T-scaling and clipping", "m^2/(V s)")
    `OPdef(lp_stbet    , "Local parameter STBET after clipping", "")
    `OPdef(lp_mue      , "Local parameter MUE after T-scaling and clipping", "m/V")
    `OPdef(lp_stmue    , "Local parameter STMUE after clipping", "")
    `OPdef(lp_themu    , "Local parameter THEMU after T-scaling and clipping", "")
    `OPdef(lp_stthemu  , "Local parameter STTHEMU after clipping", "")
    `OPdef(lp_cs       , "Local parameter CS after T-scaling and clipping", "")
    `OPdef(lp_stcs     , "Local parameter STCS after clipping", "")
    `OPdef(lp_xcor     , "Local parameter XCOR after T-scaling and clipping", "V^-1")
    `OPdef(lp_stxcor   , "Local parameter STXCOR after clipping", "")
    `OPdef(lp_feta     , "Local parameter FETA after clipping", "")
    `OPdef(lp_rs       , "Local parameter RS after T-scaling and clipping", "Ohm")
    `OPdef(lp_strs     , "Local parameter STRS after clipping", "")
    `OPdef(lp_rsb      , "Local parameter RSB after clipping", "V^-1")
    `OPdef(lp_rsg      , "Local parameter RSG after clipping", "V^-1")
    `OPdef(lp_thesat   , "Local parameter THESAT after T-scaling and clipping", "V^-1")
    `OPdef(lp_stthesat , "Local parameter STTHESAT after clipping", "")
    `OPdef(lp_thesatb  , "Local parameter THESATB after clipping", "V^-1")
    `OPdef(lp_thesatg  , "Local parameter THESATG after clipping", "V^-1")
    `OPdef(lp_ax       , "Local parameter AX after clipping", "")
    `OPdef(lp_alp      , "Local parameter ALP after clipping", "")
    `OPdef(lp_alp1     , "Local parameter ALP1 after clipping", "V")
    `OPdef(lp_alp2     , "Local parameter ALP2 after clipping", "V^-1")
    `OPdef(lp_vp       , "Local parameter VP after clipping", "V")
    `OPdef(lp_a1       , "Local parameter A1 after clipping", "")
    `OPdef(lp_a2       , "Local parameter A2 after T-scaling and clipping", "V")
    `OPdef(lp_sta2     , "Local parameter STA2 after clipping", "")
    `OPdef(lp_a3       , "Local parameter A3 after clipping", "")
    `OPdef(lp_a4       , "Local parameter A4 after clipping", "1/sqrt(V)")
    `OPdef(lp_gco      , "Local parameter GCO after clipping", "")
    `OPdef(lp_iginv    , "Local parameter IGINV after T-scaling and clipping", "A")
    `OPdef(lp_igov     , "Local parameter IGOV after T-scaling and clipping", "A")
    `OPdef(lp_igovd    , "Local parameter IGOVD after T-scaling and clipping", "A")
    `OPdef(lp_stig     , "Local parameter STIG after clipping", "")
    `OPdef(lp_gc2      , "Local parameter GC2 after clipping", "")
    `OPdef(lp_gc3      , "Local parameter GC3 after clipping", "")
    `OPdef(lp_chib     , "Local parameter CHIB after clipping", "V")
    `OPdef(lp_agidl    , "Local parameter AGIDL after clipping", "A/V^3")
    `OPdef(lp_agidld   , "Local parameter AGIDLD after clipping", "A/V^3")
    `OPdef(lp_bgidl    , "Local parameter BGIDL after T-scaling and clipping", "V")
    `OPdef(lp_bgidld   , "Local parameter BGIDLD after T-scaling and clipping", "V")
    `OPdef(lp_stbgidl  , "Local parameter STBGIDL after clipping", "V/K")
    `OPdef(lp_stbgidld , "Local parameter STBGIDLD after clipping", "V/K")
    `OPdef(lp_cgidl    , "Local parameter CGIDL after clipping", "")
    `OPdef(lp_cgidld   , "Local parameter CGIDLD after clipping", "")
    `OPdef(lp_cox      , "Local parameter COX after clipping", "F")
    `OPdef(lp_cgov     , "Local parameter CGOV after clipping", "F")
    `OPdef(lp_cgovd    , "Local parameter CGOVD after clipping", "F")
    `OPdef(lp_cgbov    , "Local parameter CGBOV after clipping", "F")
    `OPdef(lp_cfr      , "Local parameter CFR after clipping", "F")
    `OPdef(lp_cfrd     , "Local parameter CFRD after clipping", "F")
    `OPdef(lp_fnt      , "Local parameter FNT after clipping", "")
    `OPdef(lp_nfa      , "Local parameter NFA after clipping", "1/(V m^4)")
    `OPdef(lp_nfb      , "Local parameter NFB after clipping", "1/(V m^2)")
    `OPdef(lp_nfc      , "Local parameter NFC after clipping", "V^-1")
    `OPdef(lp_ef       , "Local parameter EF after clipping", "")
    `OPdef(lp_rg       , "Local parameter RG after clipping", "Ohm")
    `OPdef(lp_rse      , "Local parameter RSE after clipping", "Ohm")
    `OPdef(lp_rde      , "Local parameter RDE after clipping", "Ohm")
    `OPdef(lp_rbulk    , "Local parameter RBULK after clipping", "Ohm")
    `OPdef(lp_rwell    , "Local parameter RWELL after clipping", "Ohm")
    `OPdef(lp_rjuns    , "Local parameter RJUNS after clipping", "Ohm")
    `OPdef(lp_rjund    , "Local parameter RJUND after clipping", "Ohm")
`ifdef NQSmodel
    `OPdef(lp_munqs    , "Local parameter MUNQS after clipping", "")
`endif // NQSmodel

    /////////////////////////////////////////////////////////////////////////////
    //
    //  Analog block with all calculations and contribs
    //
    /////////////////////////////////////////////////////////////////////////////

    analog begin

        begin : initial_model
            // Code independent of bias or instance parameters
            // This block needs to be evaluated only once

            // Clipping and rounding of switch parameters
            if (TYPE >= 0) begin
                CHNL_TYPE  = `NMOS;
            end else begin
                CHNL_TYPE  = `PMOS;
            end
            SWGEO_i     = floor(`CLIP_BOTH(SWGEO,     0.0, 2.0) + 0.5);
            SWIGATE_i   = floor(`CLIP_BOTH(SWIGATE,   0.0, 1.0) + 0.5);
            SWIMPACT_i  = floor(`CLIP_BOTH(SWIMPACT,  0.0, 1.0) + 0.5);
            SWGIDL_i    = floor(`CLIP_BOTH(SWGIDL,    0.0, 1.0) + 0.5);
            SWJUNCAP_i  = floor(`CLIP_BOTH(SWJUNCAP,  0.0, 3.0) + 0.5);
            SWJUNASYM_i = floor(`CLIP_BOTH(SWJUNASYM, 0.0, 1.0) + 0.5);
            SWNUD_i     = floor(`CLIP_BOTH(SWNUD,     0.0, 2.0) + 0.5);
            SWDELVTAC_i = floor(`CLIP_BOTH(SWDELVTAC, 0.0, 1.0) + 0.5);
            QMC_i       = `CLIP_LOW(QMC, 0.0);
`ifdef NQSmodel
            if (SWNQS < 0.5) begin
                SWNQS_i = 0;
            end else begin
                if (SWNQS < 1.5) begin
                    SWNQS_i = 1;
                end else begin
                    if (SWNQS < 2.5) begin
                        SWNQS_i = 2;
                    end else begin
                        if (SWNQS < 4.0) begin
                            SWNQS_i = 3;
                        end else begin
                            if (SWNQS < 7.0) begin
                                SWNQS_i = 5;
                            end else begin
                                SWNQS_i = 9;
                            end
                        end
                    end
                end
            end
`endif // NQSmodel

            // Clipping of global model parameters
            TOXO_i     = `CLIP_LOW(TOXO, 1e-10);
            EPSROXO_i  = `CLIP_LOW(EPSROXO, 1.0);
            NSUBO_i    = `CLIP_LOW(NSUBO, 1e20);
            WSEG_i     = `CLIP_LOW(WSEG, 1e-10);
            NPCK_i     = `CLIP_LOW(NPCK, 0.0);
            WSEGP_i    = `CLIP_LOW(WSEGP, 1e-10);
            LPCK_i     = `CLIP_LOW(LPCK, 1e-10);
            TOXOVO_i   = `CLIP_LOW(TOXOVO, 1e-10);
            TOXOVDO_i  = `CLIP_LOW(TOXOVDO, 1e-10);
            LOV_i      = `CLIP_LOW(LOV, 0.0);
            LOVD_i     = `CLIP_LOW(LOVD, 0.0);
            LP1_i      = `CLIP_LOW(LP1, 1e-10);
            LP2_i      = `CLIP_LOW(LP2, 1e-10);
            WBET_i     = `CLIP_LOW(WBET, 1e-10);
            AXL_i      = `CLIP_LOW(AXL, 0.0);
            ALP1L2_i   = `CLIP_LOW(ALP1L2, 0.0);
            ALP2L2_i   = `CLIP_LOW(ALP2L2, 0.0);

            SAREF_i    = `CLIP_LOW(SAREF, 1e-9);
            SBREF_i    = `CLIP_LOW(SBREF, 1e-9);
            KVSAT_i    = `CLIP_BOTH(KVSAT, -1.0, 1.0);
            LLODKUO_i  = `CLIP_LOW(LLODKUO, 0.0);
            WLODKUO_i  = `CLIP_LOW(WLODKUO, 0.0);
            LLODVTH_i  = `CLIP_LOW(LLODVTH, 0.0);
            WLODVTH_i  = `CLIP_LOW(WLODVTH, 0.0);
            LODETAO_i  = `CLIP_LOW(LODETAO, 0.0);
            SCREF_i    = `CLIP_LOW(SCREF, 0.0);
            WEB_i      =  WEB;
            WEC_i      =  WEC;
            RSHG_i     = `CLIP_LOW(RSHG, 0.0);
            RSH_i      = `CLIP_LOW(RSH, 0.0);
            RSHD_i     = `CLIP_LOW(RSHD, 0.0);
            RINT_i     = `CLIP_LOW(RINT, 0.0);
            RVPOLY_i   = `CLIP_LOW(RVPOLY, 0.0);

            // 4.1 Internal parameters (including temperature scaling)
            // (only internal parameters independent on instance parameters
            //  are calculated in this section)

            // Transistor temperature
            TR_i       =  `CLIP_LOW(TR, -273);
            TKR        =  `KELVINCONVERSION + TR_i;
            TKD        =  $temperature + DTA;
            TKD_sq     =  TKD * TKD;
            dT         =  TKD - TKR;
            rT         =  TKD / TKR;
            rTn        =  TKR / TKD;
            phit       =  TKD * `KBOL / `QELE;
            inv_phit   =  1.0 / phit;

            // Local process parameters
            Eg         =  1.179 - 9.025e-5 * TKD - 3.05e-7 * TKD_sq;
            phibFac    =  (1.045 + 4.5e-4 * TKD) * (0.523 + 1.4e-3 * TKD - 1.48e-6 * TKD_sq) * TKD_sq / 9.0E4;
            phibFac    =  `MAX(phibFac, 1.0E-3);
            EPSSI      =  `EPSO * `EPSRSI;

`ifdef NQSmodel
            inorm      =  1.0e-12;
            r_nqs      =  1.0e+3;
            vnorm      =  10.0;
            vnorm_inv  =  1.0 / vnorm;

`endif // NQSmodel

            nt0        =  4 * `KBOL * TKD; // parameter for white noise of parasitic resistances

            // JUNCAP2
            `include "JUNCAP200_InitModel.include"

        end // initial_model

        begin : initial_instance
            // Code independent of bias, but dependent on instance parameters,
            //   (including code dependent on parameters which could IN PRINCIPLE be scaled)
            // This block needs to be evaluated only once for each instance

            NF_i       = 1.0;
            invNF      = 1.0;
            LE         = 0.0;
            WE         = 0.0;
            L_i        = L;
            W_i        = W;
            SA_i       = SA;
            SB_i       = SB;
            SD_i       = SD;
            SC_i       = SC;
            XGW_i      = XGW;
            ABSOURCE_i = ABSOURCE;
            LSSOURCE_i = LSSOURCE;
            LGSOURCE_i = LGSOURCE;
            ABDRAIN_i  = ABDRAIN;
            LSDRAIN_i  = LSDRAIN;
            LGDRAIN_i  = LGDRAIN;
            AS_i       = AS;
            PS_i       = PS;
            AD_i       = AD;
            PD_i       = PD;
            JW_i       = JW;
            if ((SWGEO_i == 1) || (SWGEO_i == 2)) begin

                ///////////////////////////////////////////
                //  GEOMETRICAL PARAMETERSCALING
                ///////////////////////////////////////////

                // Clipping of the instance parameters
                NF_i       = `CLIP_LOW(NF, 1.0);
                NF_i       = floor(NF_i + 0.5); // round to nearest integer
                invNF      = 1.0 / NF_i;
                L_i        = `CLIP_LOW(L_i, 1e-9);
                W_i        = `CLIP_LOW(W_i * invNF, 1e-9);
                SCA_i      = `CLIP_LOW(SCA, 0.0);
                SCB_i      = `CLIP_LOW(SCB, 0.0);
                SCC_i      = `CLIP_LOW(SCC, 0.0);
                NGCON_i    = (NGCON < 1.5) ? 1.0 : 2.0;

                // 3.2 Transistor geometry
                LEN        = 1e-6;
                WEN        = 1e-6;
                iL         = LEN / L_i;
                iW         = WEN / W_i;
                if (SWGEO_i == 2) begin
                    delLPS     = LVARO * (1.0 + LVARL * iL);
                    delWOD     = WVARO * (1.0 + WVARW * iW);
                end else begin
                    delLPS     = LVARO * (1.0 + LVARL * iL) * (1.0 + LVARW * iW);
                    delWOD     = WVARO * (1.0 + WVARL * iL) * (1.0 + WVARW * iW);
                end
                LE         = `CLIP_LOW(L_i + delLPS - 2.0 * LAP, 1e-9);
                WE         = `CLIP_LOW(W_i + delWOD - 2.0 * WOT, 1e-9);
                LEcv       = `CLIP_LOW(L_i + delLPS - 2.0 * LAP + DLQ, 1e-9);
                WEcv       = `CLIP_LOW(W_i + delWOD - 2.0 * WOT + DWQ, 1e-9);
                Lcv        = `CLIP_LOW(L_i + delLPS + DLQ, 1e-9);
                Wcv        = `CLIP_LOW(W_i + delWOD + DWQ, 1e-9);
                iLE        = LEN / LE;
                iWE        = WEN / WE;

                // Geometry for multi-finger devices
                L_f        = `CLIP_LOW(L_i + delLPS, 1e-9);
                L_slif     = `CLIP_LOW(L_f + DLSIL, 1e-9);
                W_f        = `CLIP_LOW(W_i + delWOD, 1e-9);
                XGWE       = `CLIP_LOW(XGW_i - 0.5 * delWOD, 1e-9);
            end

            if (SWGEO_i == 0) begin
                VFB_p        = VFB;
                STVFB_p      = STVFB;
                TOX_p        = TOX;
                EPSROX_p     = EPSROX;
                NEFF_p       = NEFF;
                FACNEFFAC_p  = FACNEFFAC;
                GFACNUD_p    = GFACNUD;
                VSBNUD_p     = VSBNUD;
                DVSBNUD_p    = DVSBNUD;
                VNSUB_p      = VNSUB;
                NSLP_p       = NSLP;
                DNSUB_p      = DNSUB;
                DPHIB_p      = DPHIB;
                DELVTAC_p    = DELVTAC;
                NP_p         = NP;
                CT_p         = CT;
                TOXOV_p      = TOXOV;
                TOXOVD_p     = TOXOVD;
                NOV_p        = NOV;
                NOVD_p       = NOVD;
                CF_p         = CF;
                CFB_p        = CFB;
                BETN_p       = BETN;
                STBET_p      = STBET;
                MUE_p        = MUE;
                STMUE_p      = STMUE;
                THEMU_p      = THEMU;
                STTHEMU_p    = STTHEMU;
                CS_p         = CS;
                STCS_p       = STCS;
                XCOR_p       = XCOR;
                STXCOR_p     = STXCOR;
                FETA_p       = FETA;
                RS_p         = RS;
                STRS_p       = STRS;
                RSB_p        = RSB;
                RSG_p        = RSG;
                THESAT_p     = THESAT;
                STTHESAT_p   = STTHESAT;
                THESATB_p    = THESATB;
                THESATG_p    = THESATG;
                AX_p         = AX;
                ALP_p        = ALP;
                ALP1_p       = ALP1;
                ALP2_p       = ALP2;
                VP_p         = VP;
                A1_p         = A1;
                A2_p         = A2;
                STA2_p       = STA2;
                A3_p         = A3;
                A4_p         = A4;
                GCO_p        = GCO;
                IGINV_p      = IGINV;
                IGOV_p       = IGOV;
                IGOVD_p      = IGOVD;
                STIG_p       = STIG;
                GC2_p        = GC2;
                GC3_p        = GC3;
                CHIB_p       = CHIB;
                AGIDL_p      = AGIDL;
                AGIDLD_p     = AGIDLD;
                BGIDL_p      = BGIDL;
                BGIDLD_p     = BGIDLD;
                STBGIDL_p    = STBGIDL;
                STBGIDLD_p   = STBGIDLD;
                CGIDL_p      = CGIDL;
                CGIDLD_p     = CGIDLD;
                COX_p        = COX;
                CGOV_p       = CGOV;
                CGOVD_p      = CGOVD;
                CGBOV_p      = CGBOV;
                CFR_p        = CFR;
                CFRD_p       = CFRD;
                FNT_p        = FNT;
                NFA_p        = NFA;
                NFB_p        = NFB;
                NFC_p        = NFC;
                EF_p         = EF;
                RG_p         = RG;   
                RSE_p        = RSE;  
                RDE_p        = RDE;  
                RWELL_p      = RWELL;
                RBULK_p      = RBULK;
                RJUNS_p      = RJUNS;
                RJUND_p      = RJUND;
`ifdef NQSmodel
                MUNQS_p      = MUNQS;
`endif // NQSmodel
            end

            if (SWGEO_i == 1) begin
                // 3.2 Geometry scaling with physical scaling rules

                // Process parameters
                VFB_p      = VFBO + VFBL * iLE + VFBW * iWE + VFBLW * iLE * iWE;
                STVFB_p    = STVFBO + STVFBL * iLE + STVFBW * iWE + STVFBLW * iLE * iWE;
                TOX_p      = TOXO;
                EPSROX_p   = EPSROXO;
                
                NSUB0e     = NSUBO_i * `MAX(( 1.0 + NSUBW * iWE * ln( 1.0 + WE / WSEG_i )), 1.0E-03);
                NPCKe      = NPCK_i * `MAX(( 1.0 + NPCKW * iWE * ln( 1.0 + WE / WSEGP_i )), 1.0E-03);
                LPCKe      = LPCK_i * `MAX(( 1.0 + LPCKW * iWE * ln( 1.0 + WE / WSEGP_i )), 1.0E-03);
                if (LE > (2 * LPCKe)) begin
                    AA         = 7.5e10;
                    BB         = sqrt(NSUB0e + 0.5 * NPCKe) - sqrt(NSUB0e);
                    NSUB       = sqrt(NSUB0e) + AA * ln(1 + 2 * LPCKe / LE * (exp(BB / AA) - 1));
                    NSUB       = NSUB * NSUB;
                end else begin
                    if (LE >= LPCKe) begin
                           NSUB       = NSUB0e + NPCKe * LPCKe / LE;
                    end else begin // LE < LPCK
                           NSUB       = NSUB0e + NPCKe * (2 - LE / LPCKe);
                    end
                end
                NEFF_p     = NSUB * (1 - FOL1 * iLE - FOL2 * iLE * iLE);
                
                FACNEFFAC_p= FACNEFFACO + FACNEFFACL * iLE + FACNEFFACW * iWE + FACNEFFACLW * iLE * iWE;
                GFACNUD_p  = GFACNUDO + GFACNUDL * pow(iLE, GFACNUDLEXP) + GFACNUDW * iWE + GFACNUDLW * iLE * iWE;
                VSBNUD_p   = VSBNUDO;
                DVSBNUD_p  = DVSBNUDO;
                VNSUB_p    = VNSUBO;
                NSLP_p     = NSLPO;
                DNSUB_p    = DNSUBO;
                DPHIB_p    = DPHIBO + DPHIBL * pow(iLE, DPHIBLEXP) + DPHIBW * iWE + DPHIBLW * iLE * iWE;
                DELVTAC_p  = DELVTACO + DELVTACL * pow(iLE, DELVTACLEXP) + DELVTACW * iWE + DELVTACLW * iLE * iWE;
                NP_p       = NPO * `MAX(1e-6, (1.0 + NPL * iLE));
                CT_p       = (CTO + CTL * pow(iLE, CTLEXP)) * (1.0 + CTW * iWE) * (1.0 + CTLW * iLE * iWE);
                TOXOV_p    = TOXOVO;
                TOXOVD_p   = TOXOVDO;
                NOV_p      = NOVO;
                NOVD_p     = NOVDO;

                // DIBL parameters
                CF_p       = CFL * pow(iLE, CFLEXP) * (1.0 + CFW * iWE);
                CFB_p      = CFBO;

                // Mobility parameters
                FBET1e     = FBET1 * (1.0 + FBET1W * iWE);
                LP1e       = LP1_i * `MAX(1.0 + LP1W * iWE, 1.0E-03);
                GPE        = 1.0 + FBET1e * LP1e / LE * (1.0 - exp(-LE / LP1e)) + FBET2 * LP2_i / LE * (1.0 - exp(-LE / LP2_i));
                GPE        = `MAX(GPE, 1e-15);
                GWE        = 1.0 + BETW1 * iWE + BETW2 * iWE * ln(1.0 + WE / WBET_i);
                BETN_p     = UO * WE / (GPE * LE) * GWE;
                
                STBET_p    = STBETO + STBETL * iLE + STBETW * iWE + STBETLW * iLE * iWE;
                MUE_p      = MUEO * (1.0 + MUEW * iWE);
                STMUE_p    = STMUEO;
                THEMU_p    = THEMUO;
                STTHEMU_p  = STTHEMUO;
                CS_p       = (CSO + CSL * pow(iLE, CSLEXP)) * (1.0 + CSW * iWE) * (1.0 + CSLW * iLE * iWE);
                STCS_p     = STCSO;
                XCOR_p     = XCORO * (1.0 + XCORL * iLE) * (1.0 + XCORW * iWE) * (1.0 + XCORLW * iLE * iWE);
                STXCOR_p   = STXCORO;
                FETA_p     = FETAO;

                // Series resistance
                RS_p       = RSW1 * iWE * (1.0 + RSW2 * iWE);
                STRS_p     = STRSO;
                RSB_p      = RSBO;
                RSG_p      = RSGO;

                // Velocity saturation
                THESAT_p   = (THESATO + THESATL* GWE / GPE * pow(iLE, THESATLEXP)) * (1.0 + THESATW * iWE) * (1.0 + THESATLW * iLE * iWE);
                STTHESAT_p = STTHESATO + STTHESATL * iLE + STTHESATW * iWE + STTHESATLW * iLE * iWE;
                THESATB_p  = THESATBO;
                THESATG_p  = THESATGO;

                // Saturation voltage
                AX_p       = AXO / (1.0 + AXL_i * iLE);

                // Channel length modulation
                ALP_p      = ALPL * pow(iLE, ALPLEXP) * (1.0 + ALPW * iWE);
                tmpx       = pow(iLE, ALP1LEXP);
                ALP1_p     = ALP1L1 * tmpx * (1.0 + ALP1W * iWE) / (1.0 + ALP1L2_i * iLE * tmpx);
                tmpx       = pow(iLE, ALP2LEXP);
                ALP2_p     = ALP2L1 * tmpx * (1.0 + ALP2W * iWE) / (1.0 + ALP2L2_i * iLE * tmpx);
                VP_p       = VPO;

                // Impact ionization
                A1_p       = A1O * (1.0 + A1L * iLE) * (1.0 + A1W * iWE);
                A2_p       = A2O;
                STA2_p     = STA2O;
                A3_p       = A3O * (1.0 + A3L * iLE) * (1.0 + A3W * iWE);
                A4_p       = A4O * (1.0 + A4L * iLE) * (1.0 + A4W * iWE);

                // Gate current
                GCO_p      = GCOO;
                IGINV_p    = IGINVLW / (iWE * iLE);
                IGOV_p     = IGOVW * LOV_i / (LEN * iWE);
                IGOVD_p    = IGOVDW * LOVD_i / (LEN * iWE);
                STIG_p     = STIGO;
                GC2_p      = GC2O;
                GC3_p      = GC3O;
                CHIB_p     = CHIBO;

                // GIDL
                AGIDL_p    = AGIDLW * LOV_i / (LEN * iWE);
                AGIDLD_p   = AGIDLDW * LOVD_i / (LEN * iWE);
                BGIDL_p    = BGIDLO;
                BGIDLD_p   = BGIDLDO;
                STBGIDL_p  = STBGIDLO;
                STBGIDLD_p = STBGIDLDO;
                CGIDL_p    = CGIDLO;
                CGIDLD_p   = CGIDLDO;

                // Charge model parameters
                COX_p      = `EPSO * EPSROXO_i * WEcv * LEcv / TOXO_i;
                CGOV_p     = `EPSO * EPSROXO_i * WEcv * LOV_i / TOXOVO_i;
                CGOVD_p    = `EPSO * EPSROXO_i * WEcv * LOVD_i / TOXOVDO_i;
                CGBOV_p    = CGBOVL * Lcv / LEN;
                CFR_p      = CFRW * Wcv / WEN;
                CFRD_p     = CFRDW * Wcv / WEN;

                // Noise model parameters
                temp0      = 1.0 - 2.0 * LINTNOI * iLE / LEN;
                Lnoi       = `MAX(temp0, 1.0e-3);
                Lred       = 1.0 / pow(Lnoi, ALPNOI);

                FNT_p      = FNTO;
                NFA_p      = Lred * iWE * iLE * NFALW;
                NFB_p      = Lred * iWE * iLE * NFBLW;
                NFC_p      = Lred * iWE * iLE * NFCLW;
                EF_p       = EFO;

                // Well proximity effect parameters
                KVTHOWE    = KVTHOWEO + KVTHOWEL * iLE + KVTHOWEW * iWE + KVTHOWELW * iLE * iWE;
                KUOWE      = KUOWEO + KUOWEL * iLE + KUOWEW * iWE + KUOWELW * iLE * iWE;
            end

            if (SWGEO_i == 2) begin
                // 3.3 Geometry scaling with binning scaling rules
                `include "PSP103_binning.include"
            end

            if ((SWGEO_i == 1) || (SWGEO_i == 2)) begin
                // Parasitic resistance parameters
                RG_p       = RSHG_i * (`oneThird * W_f / NGCON_i + XGWE) / (NGCON_i * L_slif)
                             + (RINT_i + RVPOLY_i) / (W_f * L_f) + NF_i * RGO;
                if (SWJUNASYM == 0) begin
                    RSHD_i     = RSH_i;
                end
                RSE_p      = NRS * RSH_i;
                RDE_p      = NRD * RSHD_i;
                RWELL_p    = NF_i * RWELLO;
                RBULK_p    = NF_i * RBULKO;
                RJUNS_p    = NF_i * RJUNSO;
                RJUND_p    = NF_i * RJUNDO;

`ifdef NQSmodel
                MUNQS_p    = MUNQSO;
`endif // NQSModel

                ///////////////////////////////////////////
                //  STRESSMODEL
                ///////////////////////////////////////////

                // 3.4 Stress equations
                tmpa     = 0.0;
                tmpb     = 0.0;
                loop     = 0.0;
                if ((SA_i > 0.0) && (SB_i > 0.0) && ((NF_i == 1.0) || ((NF_i > 1.0) && (SD_i > 0.0)))) begin
                    // Auxiliary variables

                    // Note: some verilog-A compilers will (unnecesarily) cause the while-loop
                    // below to be executed at every bias step; this has a negative impact on
                    // the simulation speed of PSP.
                    while (loop < (NF_i - 0.5)) begin
                        tmpa    = tmpa + 1.0 / (SA_i + 0.5 * L_i + loop * (SD_i + L_i));
                        tmpb    = tmpb + 1.0 / (SB_i + 0.5 * L_i + loop * (SD_i + L_i));
                        loop    = loop + 1.0;
                    end
                    Invsa      = tmpa * invNF;
                    Invsb      = tmpb * invNF;
                    Invsaref   = 1.0 / (SAREF_i + 0.5 * L_i);
                    Invsbref   = 1.0 / (SBREF_i + 0.5 * L_i);
                    Lx         = `MAX(L_i + delLPS, 1e-9);
                    Wx         = `MAX(W_i + delWOD + WLOD, 1e-9);
                    templ      =  1.0 / pow(Lx, LLODKUO_i);
                    tempw      =  1.0 / pow(Wx, WLODKUO_i);
                    Kstressu0  = (1.0 + LKUO * templ + WKUO * tempw + PKUO * templ * tempw) * (1.0 + TKUO * (rT - 1.0));
                    rhobeta    = KUO * (Invsa + Invsb) / Kstressu0;
                    rhobetaref = KUO * (Invsaref + Invsbref) / Kstressu0;
                    templ      = 1.0 / pow(Lx, LLODVTH_i);
                    tempw      = 1.0 / pow(Wx, WLODVTH_i);
                    Kstressvth0= 1.0 + LKVTHO * templ + WKVTHO * tempw + PKVTHO * templ * tempw;
                    temp0      = Invsa + Invsb - Invsaref - Invsbref;

                    //  Parameter adaptations
                    BETN_p     = BETN_p * (1.0 + rhobeta) / (1.0 + rhobetaref);
                    THESAT_p   = THESAT_p * (1.0 + rhobeta) * (1.0 + KVSAT_i * rhobetaref) / ((1.0 + rhobetaref) * (1.0  + KVSAT_i * rhobeta));
                    VFB_p      = VFB_p + KVTHO * temp0 / Kstressvth0;
                    CF_p       = CF_p + STETAO * temp0 / pow(Kstressvth0, LODETAO_i);
                end

                ///////////////////////////////////////////
                //  WELL PROXIMITY EFFECT MODEL
                ///////////////////////////////////////////

                // 3.5 Well proximity effect equations
                if ((SCA_i > 0.0) || (SCB_i > 0.0) || (SCC_i > 0.0) || (SC_i > 0.0)) begin
                    if ((SCA_i == 0.0) && (SCB_i == 0.0) && (SCC_i == 0.0)) begin
                        temp0      = SC_i + W_i;
                        temp00     = 1.0 / SCREF_i;
                        SCA_i      = SCREF_i * SCREF_i / (SC_i * temp0);
                        SCB_i      = ((0.1 * SC_i + 0.01 * SCREF_i) * exp(-10.0 * SC_i * temp00)
                                     - (0.1 * temp0 + 0.01 * SCREF_i) * exp(-10.0 * temp0 * temp00)) / W_i;
                        SCC_i      = ((0.05 * SC_i + 0.0025 * SCREF_i) * exp(-20.0 * SC_i * temp00)
                                     - (0.05 * temp0 + 0.0025 * SCREF_i) * exp(-20.0 * temp0 * temp00)) / W_i;
                    end

                    // Parameter adaptations
                    temp0     = SCA_i + WEB_i * SCB_i + WEC_i * SCC_i;
                    VFB_p     = VFB_p + KVTHOWE * temp0;
                    BETN_p    = BETN_p * (1.0 + KUOWE * temp0);
                end

                /////////////////////////////////////////////
                //  END OF SCALINGRULES AND STRESS/WPE MODELS
                /////////////////////////////////////////////
            end

            // 4.1 Internal parameters (including temperature scaling)

            // Clipping of the local model parameters
            VFB_i      =  VFB_p;
            STVFB_i    =  STVFB_p;
            TOX_i      = `CLIP_LOW(TOX_p, 1e-10);
            EPSROX_i   = `CLIP_LOW(EPSROX_p, 1.0);
            NEFF_i     = `CLIP_BOTH(NEFF_p,  1e20,  1e26);
            FACNEFFAC_i= `CLIP_LOW(FACNEFFAC_p, 0.0);
            GFACNUD_i  = `CLIP_LOW(GFACNUD_p, 0.01);
            VSBNUD_i   = `CLIP_LOW(VSBNUD_p, 0.0);
            DVSBNUD_i  = `CLIP_LOW(DVSBNUD_p, 0.1);
            VNSUB_i    =  VNSUB_p;
            NSLP_i     = `CLIP_LOW(NSLP_p, 1e-3);
            DNSUB_i    = `CLIP_BOTH(DNSUB_p, 0.0, 1.0);
            DPHIB_i    =  DPHIB_p;
            DELVTAC_i  =  DELVTAC_p;
            NP_i       = `CLIP_LOW(NP_p, 0.0);
            CT_i       = `CLIP_LOW(CT_p, 0.0);
            TOXOV_i    = `CLIP_LOW(TOXOV_p, 1e-10);
            TOXOVD_i   = `CLIP_LOW(TOXOVD_p, 1e-10);
            NOV_i      = `CLIP_BOTH(NOV_p, 1e20, 1e27);
            NOVD_i     = `CLIP_BOTH(NOVD_p, 1e20, 1e27);
            CF_i       = `CLIP_LOW(CF_p, 0.0);
            CFB_i      = `CLIP_BOTH(CFB_p, 0.0, 1.0);
            BETN_i     = `CLIP_LOW(BETN_p, 0.0);
            STBET_i    =  STBET_p;
            MUE_i      = `CLIP_LOW(MUE_p, 0.0);
            STMUE_i    =  STMUE_p;
            THEMU_i    = `CLIP_LOW(THEMU_p, 0.0);
            STTHEMU_i  =  STTHEMU_p;
            CS_i       = `CLIP_LOW(CS_p,  0.0);
            STCS_i     =  STCS_p;
            XCOR_i     = `CLIP_LOW(XCOR_p, 0.0);
            STXCOR_i   =  STXCOR_p;
            FETA_i     = `CLIP_LOW(FETA_p, 0.0);
            RS_i       = `CLIP_LOW(RS_p, 0.0);
            STRS_i     =  STRS_p;
            RSB_i      = `CLIP_BOTH(RSB_p, -0.5, 1.0);
            RSG_i      = `CLIP_LOW(RSG_p, -0.5);
            THESAT_i   = `CLIP_LOW(THESAT_p, 0.0);
            STTHESAT_i =  STTHESAT_p;
            THESATB_i  = `CLIP_BOTH(THESATB_p, -0.5, 1.0);
            THESATG_i  = `CLIP_LOW(THESATG_p, -0.5);
            AX_i       = `CLIP_LOW(AX_p, 2.0);
            ALP_i      = `CLIP_LOW(ALP_p, 0.0);
            ALP1_i     = `CLIP_LOW(ALP1_p, 0.0);
            ALP2_i     = `CLIP_LOW(ALP2_p, 0.0);
            VP_i       = `CLIP_LOW(VP_p, 1.0e-10);
            A1_i       = `CLIP_LOW(A1_p, 0.0);
            A2_i       = `CLIP_LOW(A2_p, 0.0);
            STA2_i     =  STA2_p;
            A3_i       = `CLIP_LOW(A3_p, 0.0);
            A4_i       = `CLIP_LOW(A4_p, 0.0);
            GCO_i      = `CLIP_BOTH(GCO_p, -10.0, 10.0);
            IGINV_i    = `CLIP_LOW(IGINV_p, 0.0);
            IGOV_i     = `CLIP_LOW(IGOV_p, 0.0);
            IGOVD_i    = `CLIP_LOW(IGOVD_p, 0.0);
            STIG_i     =  STIG_p;
            GC2_i      = `CLIP_BOTH(GC2_p, 0.0, 10.0);
            GC3_i      = `CLIP_BOTH(GC3_p, -10.0, 10.0);
            CHIB_i     = `CLIP_LOW(CHIB_p, 1.0);
            AGIDL_i    = `CLIP_LOW(AGIDL_p, 0.0);
            AGIDLD_i   = `CLIP_LOW(AGIDLD_p, 0.0);
            BGIDL_i    = `CLIP_LOW(BGIDL_p, 0.0);
            BGIDLD_i   = `CLIP_LOW(BGIDLD_p, 0.0);
            STBGIDL_i  =  STBGIDL_p;
            STBGIDLD_i =  STBGIDLD_p;
            CGIDL_i    =  CGIDL_p;
            CGIDLD_i   =  CGIDLD_p;
            COX_i      = `CLIP_LOW(COX_p, 0.0);
            CGOV_i     = `CLIP_LOW(CGOV_p, 0.0);
            CGOVD_i    = `CLIP_LOW(CGOVD_p, 0.0);
            CGBOV_i    = `CLIP_LOW(CGBOV_p, 0.0);
            CFR_i      = `CLIP_LOW(CFR_p, 0.0);
            CFRD_i     = `CLIP_LOW(CFRD_p, 0.0);
            FNT_i      = `CLIP_LOW(FNT_p, 0.0);
            NFA_i      = `CLIP_LOW(NFA_p, 0.0);
            NFB_i      = `CLIP_LOW(NFB_p, 0.0);
            NFC_i      = `CLIP_LOW(NFC_p, 0.0);
            EF_i       = `CLIP_LOW(EF_p,  0.0);
            RG_i       = `CLIP_LOW(RG_p, 0.0);
            RSE_i      = `CLIP_LOW(RSE_p, 0.0);
            RDE_i      = `CLIP_LOW(RDE_p, 0.0);
            RBULK_i    = `CLIP_LOW(RBULK_p, 0.0);
            RJUNS_i    = `CLIP_LOW(RJUNS_p, 0.0);
            RJUND_i    = `CLIP_LOW(RJUND_p, 0.0);
            RWELL_i    = `CLIP_LOW(RWELL_p, 0.0);
            MULT_i     = `CLIP_LOW(MULT * NF_i, 0.0); // Note: NF_i is set to 1 for local model


            FACTUO_i   = `CLIP_LOW(FACTUO, 0.0);
            DELVTO_i   =  DELVTO;

`ifdef NQSmodel
            MUNQS_i    = `CLIP_LOW(MUNQS_p, 0.0);
`endif // NQSmodel

            // ignore drain-side values in case of symmetric junctions
            if (SWJUNASYM_i == 0) begin
                TOXOVD_i    =  TOXOV_i;
                NOVD_i      =  NOV_i;
                AGIDLD_i    =  AGIDL_i;
                BGIDLD_i    =  BGIDL_i;
                STBGIDLD_i  =  STBGIDL_i;
                CGIDLD_i    =  CGIDL_i;
                IGOVD_i     =  IGOV_i;
                CGOVD_i     =  CGOV_i;
                CFRD_i      =  CFR_i;
            end

            // Local process parameters
            EPSOX      =  `EPSO * EPSROX_i;
            phit1      =  phit * (1.0 + CT_i * rTn);
            inv_phit1  =  1.0 / phit1;

            VFB_i      =  VFB_i + STVFB_i * dT + DELVTO_i;
            phib_dc    =  Eg + DPHIB_i + 2.0 * phit * ln(NEFF_i * pow(phibFac, -0.75) * 4.0e-26);
            phib_dc    =  `MAX(phib_dc, 5.0E-2);
            CoxPrime   =  EPSOX / TOX_i;
            tox_sq     =  TOX_i * TOX_i;
            G_0_dc     =  sqrt(2.0 * `QELE * NEFF_i * EPSSI * inv_phit) / CoxPrime;

            // Poly-silicon depletion
            kp         =  0.0;
            if (NP_i > 0.0) begin
                arg2max    =  8.0e7 / tox_sq;
                np         = `MAX(NP_i, arg2max);
                np         = `MAX(5.0e24, np);
                kp         =  2.0 * CoxPrime * CoxPrime * phit / (`QELE * np * EPSSI);
            end

            // QM corrections
            qlim2      =  100.0 * phit * phit;
            qq         =  0.0;
            if (QMC_i > 0.0) begin
                qq         =  0.4 * `QMN * QMC_i * pow(CoxPrime, `twoThirds);
                if (CHNL_TYPE==`PMOS) begin
                    qq         =  `QMP / `QMN * qq;
                end
                qb0        =  sqrt(phit * G_0_dc * G_0_dc * phib_dc);
                dphibq     =  0.75 * qq * pow(qb0, `twoThirds);
                phib_dc       =  phib_dc + dphibq;
                G_0_dc        =  G_0_dc * (1.0 + 2.0 * `twoThirds * dphibq / qb0);
            end
            sqrt_phib_dc =  sqrt(phib_dc);
            phix_dc      =  0.95 * phib_dc;
            aphi_dc      =  0.0025 * phib_dc * phib_dc;
            bphi_dc      =  aphi_dc;
            phix2        =  0.5 * sqrt(bphi_dc);
            phix1_dc     =  `MINA(phix_dc - phix2, 0, aphi_dc);
            us1          =  sqrt(VSBNUD_i + phib_dc) - sqrt_phib_dc;
            us21         =  sqrt(VSBNUD_i + DVSBNUD_i + phib_dc) - sqrt_phib_dc - us1;

            // Gate overlap
            CoxovPrime   =  EPSOX / TOXOV_i;
            CoxovPrime_d =  EPSOX / TOXOVD_i;
            GOV_s        =  sqrt(2.0 * `QELE * NOV_i * EPSSI * inv_phit) / CoxovPrime;
            GOV_d        =  sqrt(2.0 * `QELE * NOVD_i * EPSSI * inv_phit) / CoxovPrime_d;
            GOV2_s       =  GOV_s * GOV_s;
            GOV2_d       =  GOV_d * GOV_d;
            xi_ov_s      =  1.0 + GOV_s * `invSqrt2;
            xi_ov_d      =  1.0 + GOV_d * `invSqrt2;
            inv_xi_ov_s  =  1.0 / xi_ov_s;
            inv_xi_ov_d  =  1.0 / xi_ov_d;
            x_mrg_ov_s   =  1.0e-5 * xi_ov_s;
            x_mrg_ov_d   =  1.0e-5 * xi_ov_d;

            // Mobility parameters
            tf_bet     =  pow(rTn, STBET_i);
            BETN_i     =  BETN_i * tf_bet;
            BET_i      =  FACTUO_i * BETN_i * CoxPrime;
            THEMU_i    =  THEMU_i * pow(rTn, STTHEMU_i);
            tf_mue     =  pow(rTn, STMUE_i);
            MUE_i      =  MUE_i * tf_mue;
            tf_cs      =  pow(rTn, STCS_i);
            CS_i       =  CS_i * tf_cs;
            tf_xcor    =  pow(rTn, STXCOR_i);
            XCOR_i     =  XCOR_i * tf_xcor;
            E_eff0     =  1.0e-8 * CoxPrime / EPSSI;
            eta_mu     =  0.5 * FETA_i;
            eta_mu1    =  0.5;
            if (CHNL_TYPE == `PMOS) begin
                eta_mu     =  `oneThird * FETA_i;
                eta_mu1    =  `oneThird;
            end

            // Series resistance
            tf_ther    =  pow(rTn, STRS_i);
            RS_i       =  RS_i * tf_ther;
            THER_i     =  2 * BET_i * RS_i;

            // Velocity saturation
            tf_thesat  =  pow(rTn, STTHESAT_i);
            THESAT_i   =  THESAT_i * tf_thesat;
            Vdsat_lim  =  3.912023005 * phit1;

            inv_AX     =  1.0 / AX_i;
            inv_VP     =  1.0 / VP_i;

            // Impact ionization
            A2_i       =  A2_i * pow(rT, STA2_i);

            // Gate current
            tf_ig      =  pow(rT, STIG_i);
            IGINV_i    =  IGINV_i * tf_ig;
            IGOV_i     =  IGOV_i * tf_ig;
            IGOVD_i    =  IGOVD_i * tf_ig;
            inv_CHIB   =  1.0 / CHIB_i;
            tempM      =  4.0 * `oneThird * sqrt(2 * `QELE * `MELE * CHIB_i) / `HBAR;
            BCH        =  tempM * TOX_i;
            BOV        =  tempM * TOXOV_i;
            BOV_d      =  tempM * TOXOVD_i;
            GCQ        =  0;
            if (GC3_i < 0) begin
                GCQ        =  -0.495 * GC2_i / GC3_i;
            end
            alpha_b    =  0.5 * (phib_dc + Eg);
            Dch        =  GCO_i * phit1;
            Dov        =  GCO_i * phit;

            // GIDL
            AGIDL_i    =  AGIDL_i * 4e-18 / (TOXOV_i * TOXOV_i);
            AGIDLD_i   =  AGIDLD_i * 4e-18 / (TOXOVD_i * TOXOVD_i);
            tempM      = `MAX(1.0 + STBGIDL_i * dT, 0);
            BGIDL_i    =  BGIDL_i * tempM * TOXOV_i * 5e8;
            tempM      = `MAX(1.0 + STBGIDLD_i * dT, 0);
            BGIDLD_i   =  BGIDLD_i * tempM * TOXOVD_i * 5e8;

            // Noise
            nt         =  FNT_i * 4 * `KBOL * TKD;
            Cox_over_q =  CoxPrime / `QELE;
            Sfl_prefac =  phit * phit * BET_i / Cox_over_q;

            // Additional internal parameters
            x1         =  1.25;
            inv_xg1_s  =  1.0 / (x1 + GOV_s * 7.324648775608221e-1); // =  1.0/(x1+GOV*sqrt(exp(-x1)+x1-1));
            inv_xg1_d  =  1.0 / (x1 + GOV_d * 7.324648775608221e-1);

            // Additional variables for separate surface potential calculation for CV
            NEFFAC_i   =  FACNEFFAC_i * NEFF_i;
            NEFFAC_i   =  `CLIP_BOTH(NEFFAC_i, 1e20, 1e26);
            phib_ac    =  Eg + DPHIB_i + DELVTAC_i + 2.0 * phit * ln(NEFFAC_i * pow(phibFac, -0.75) * 4.0e-26);
            phib_ac    =  `MAX(phib_ac, 5.0E-2);
            G_0_ac     =  sqrt(2.0 * `QELE * NEFFAC_i * EPSSI * inv_phit) / CoxPrime;

            if (QMC_i > 0.0) begin
                qb0        =  sqrt(phit * G_0_ac * G_0_ac * phib_ac);
                dphibq     =  0.75 * qq * pow(qb0, `twoThirds);
                phib_ac    =  phib_ac + dphibq;
                G_0_ac     =  G_0_ac * (1.0 + 2.0 * `twoThirds * dphibq / qb0);
            end

            sqrt_phib_ac = sqrt(phib_ac);
            phix_ac    =  0.95 * phib_ac;
            aphi_ac    =  0.0025 * phib_ac * phib_ac;
            bphi_ac    =  aphi_ac;
            phix2      =  0.5 * sqrt(bphi_ac);
            phix1_ac   =  `MINA(phix_ac - phix2, 0, aphi_ac);

            // Conductance of parasitic resistance
            if (RG_i > 0.0) begin
                ggate  =  1.0 / RG_i;
            end else begin
                ggate  =  0.0;
            end
            if (RSE_i > 0.0) begin
                gsource  =  1.0 / RSE_i;
            end else begin
                gsource  =  0.0;
            end
            if (RDE_i > 0.0) begin
                gdrain  =  1.0 / RDE_i;
            end else begin
                gdrain  =  0.0;
            end
            if (RBULK_i > 0.0) begin
                gbulk  =  1.0 / RBULK_i;
            end else begin
                gbulk  =  0.0;
            end
            if (RJUNS_i > 0.0) begin
                gjuns  =  1.0 / RJUNS_i;
            end else begin
                gjuns  =  0.0;
            end
            if (RJUND_i > 0.0) begin
                gjund  =  1.0 / RJUND_i;
            end else begin
                gjund  =  0.0;
            end
            if (RWELL_i > 0.0) begin
                gwell  =  1.0 / RWELL_i;
            end else begin
                gwell  =  0.0;
            end

            // JUNCAP instance parameters
            ABS_i      = 0.0;
            LSS_i      = 0.0;
            LGS_i      = 0.0;
            ABD_i      = 0.0;
            LSD_i      = 0.0;
            LGD_i      = 0.0;
            jwcorr     = 0.0;
            jww        = WE;
            if (SWGEO_i == 0) begin
                jww    = `CLIP_LOW(JW_i, `LG_cliplow);
            end
            if (SWJUNCAP_i == 3) begin
                jwcorr = 1.0;
            end
            ABS_i = ABSOURCE_i * invNF;
            LSS_i = LSSOURCE_i * invNF;
            LGS_i = LGSOURCE_i * invNF;
            ABD_i = ABDRAIN_i * invNF;
            LSD_i = LSDRAIN_i * invNF;
            LGD_i = LGDRAIN_i * invNF;
            if ((SWJUNCAP_i == 2) || (SWJUNCAP_i == 3)) begin
                ABS_i = AS_i * invNF;
                LSS_i = PS_i * invNF - jwcorr * jww;
                LGS_i = jww;
                ABD_i = AD_i * invNF;
                LSD_i = PD_i * invNF - jwcorr * jww;
                LGD_i = jww;
            end
            if ((SWJUNCAP_i == 1) || (SWJUNCAP_i == 2) || (SWJUNCAP_i == 3)) begin
                ABSOURCE_i = `CLIP_LOW(ABS_i, `AB_cliplow);
                LSSOURCE_i = `CLIP_LOW(LSS_i, `LS_cliplow);
                LGSOURCE_i = `CLIP_LOW(LGS_i, `LG_cliplow);
                ABDRAIN_i  = `CLIP_LOW(ABD_i, `AB_cliplow);
                LSDRAIN_i  = `CLIP_LOW(LSD_i, `LS_cliplow);
                LGDRAIN_i  = `CLIP_LOW(LGD_i, `LG_cliplow);
            end else begin
                ABSOURCE_i = 0.0;
                LSSOURCE_i = 0.0;
                LGSOURCE_i = 0.0;
                ABDRAIN_i  = 0.0;
                LSDRAIN_i  = 0.0;
                LGDRAIN_i  = 0.0;
            end

            // Initialization of JUNCAP (global) variables; required for some verilog-A compilers
            vbimin_s   = 0.0;
            vbimin_d   = 0.0;
            vfmin_s    = 0.0;
            vfmin_d    = 0.0;
            vch_s      = 0.0;
            vch_d      = 0.0;
            vbbtlim_s  = 0.0;
            vbbtlim_d  = 0.0;
            VMAX_s     = 0.0;
            VMAX_d     = 0.0;
            exp_VMAX_over_phitd_s = 0.0;
            exp_VMAX_over_phitd_d = 0.0;
            vj         = 0.0;
            idmult     = 0.0;
            vjsrh      = 0.0;
            zinv       = 0.0;
            wdep       = 0.0;
            wsrh       = 0.0;
            asrh       = 0.0;
            vav        = 0.0;
            vbi_minus_vjsrh = 0.0;

            ISATFOR1_s = 0.0;
            ISATFOR1_d = 0.0;
            MFOR1_s    = 1.0;
            MFOR1_d    = 1.0;
            ISATFOR2_s = 0.0;
            ISATFOR2_d = 0.0;
            MFOR2_s    = 1.0;
            MFOR2_d    = 1.0;
            ISATREV_s  = 0.0;
            ISATREV_d  = 0.0;
            MREV_s     = 1.0;
            MREV_d     = 1.0;
            m0flag_s   = 0.0;
            m0flag_d   = 0.0;
            xhighf1_s  = 0.0;
            xhighf1_d  = 0.0;
            expxhf1_s  = 0.0;
            expxhf1_d  = 0.0;
            xhighf2_s  = 0.0;
            xhighf2_d  = 0.0;
            expxhf2_s  = 0.0;
            expxhf2_d  = 0.0;
            xhighr_s   = 0.0;
            xhighr_d   = 0.0;
            expxhr_s   = 0.0;
            expxhr_d   = 0.0;
            zflagbot_s = 1.0;
            zflagbot_d = 1.0;
            zflagsti_s = 1.0;
            zflagsti_d = 1.0;
            zflaggat_s = 1.0;
            zflaggat_d = 1.0;

            m0_rev     = 0.0;
            mcor_rev   = 0.0;
            I1_cor     = 0.0;
            I2_cor     = 0.0;
            I3_cor     = 0.0;
            I4_cor     = 0.0;
            I5_cor     = 0.0;
            tt0        = 0.0;
            tt1        = 0.0;
            tt2        = 0.0;
            zfrac      = 0.0;
            alphaje    = 0.0;
            tmpv       = 0.0;
            vjv        = 0.0;

            ijun_s     = 0.0;
            ijunbot_s  = 0.0;
            ijunsti_s  = 0.0;
            ijungat_s  = 0.0;
            qjun_s     = 0.0;
            qjunbot_s  = 0.0;
            qjunsti_s  = 0.0;
            qjungat_s  = 0.0;
            ijun_d     = 0.0;
            ijunbot_d  = 0.0;
            ijunsti_d  = 0.0;
            ijungat_d  = 0.0;
            qjun_d     = 0.0;
            qjunbot_d  = 0.0;
            qjunsti_d  = 0.0;
            qjungat_d  = 0.0;

            if (SWJUNCAP_i > 0) begin
                `SetJunModelParsToSource
                `JuncapInitInstance(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
                `SetJunModelParsToDrain
                `JuncapInitInstance(ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)

                if (SWJUNEXP_i == 1) begin : JUNCAPexpressInit
                    // The variables in the macro below are (re-)declared LOCALLY, to keep
                    // them separated from their globally declared counterparts. This trick
                    // allows one to use the "juncapcommon" macro both in the JUNCAP-express
                    // initialization and in the full-JUNCAP evaluation, while in the former
                    // the verilog-A compiler can still consider the variables as
                    // voltage-INdependent. This is essential to avoid recomputation of the
                    // JUNCAP-express initialization at each bias-step.
                    `LocalGlobalVars
                    // results computed here are not used elsewhere
                    real ijunbot, ijunsti, ijungat, qjunbot, qjunsti, qjungat;

                    // Initialization of (local) variables; required for some verilog-A compilers
                    ysq = 0.0;
                    terfc = 0.0;
                    erfcpos = 0.0;
                    h1 = 0.0;
                    h2 = 0.0;
                    h2d = 0.0;
                    h3 = 0.0;
                    h4 = 0.0;
                    h5 = 0.0;
                    idmult = 0.0;
                    vj = 0.0;
                    z = 0.0;
                    zinv = 0.0;
                    two_psistar = 0.0;
                    vjlim = 0.0;
                    vjsrh = 0.0;
                    vbbt = 0.0;
                    vav = 0.0;
                    tmp = 0.0;
                    id = 0.0;
                    isrh = 0.0;
                    vbi_minus_vjsrh = 0.0;
                    wsrhstep = 0.0;
                    dwsrh = 0.0;
                    wsrh = 0.0;
                    wdep = 0.0;
                    asrh = 0.0;
                    itat = 0.0;
                    btat = 0.0;
                    twoatatoverthreebtat = 0.0;
                    umaxbeforelimiting = 0.0;
                    umax = 0.0;
                    sqrtumax = 0.0;
                    umaxpoweronepointfive = 0.0;
                    wgamma = 0.0;
                    wtat = 0.0;
                    ktat = 0.0;
                    ltat = 0.0;
                    mtat = 0.0;
                    xerfc = 0.0;
                    erfctimesexpmtat = 0.0;
                    gammamax = 0.0;
                    ibbt = 0.0;
                    Fmaxr = 0.0;
                    fbreakdown = 0.0;
                    qjunbot = 0.0;
                    qjunsti = 0.0;
                    qjungat = 0.0;

                    // Computation of JUNCAP-express internal parameters
                    `SetJunModelParsToSource
                    `JuncapExpressInit1(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
                    `JuncapExpressInit2(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
                    `JuncapExpressInit3(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, ISATFOR1_s, MFOR1_s, ISATFOR2_s, MFOR2_s, ISATREV_s, MREV_s, m0flag_s)
                    `JuncapExpressInit4(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, zflagbot_s, zflagsti_s, zflaggat_s)
                    `JuncapExpressInit5(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, ISATFOR1_s, ISATFOR2_s, ISATREV_s, xhighf1_s, expxhf1_s, xhighf2_s, expxhf2_s, xhighr_s, expxhr_s)

                    `SetJunModelParsToDrain
                    `JuncapExpressInit1(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)
                    `JuncapExpressInit2(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)
                    `JuncapExpressInit3(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, ISATFOR1_d, MFOR1_d, ISATFOR2_d, MFOR2_d, ISATREV_d, MREV_d, m0flag_d)
                    `JuncapExpressInit4(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, zflagbot_d, zflagsti_d, zflaggat_d)
                    `JuncapExpressInit5(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, ISATFOR1_d, ISATFOR2_d, ISATREV_d, xhighf1_d, expxhf1_d, xhighf2_d, expxhf2_d, xhighr_d, expxhr_d)
                end // JUNCAPexpressInit

            end


        end // initial_instance

        /////////////////////////////////////////////////////////////////////////////
        //
        //      DC bias dependent quantities (calculations for current contribs)
        //
        /////////////////////////////////////////////////////////////////////////////

        begin : evaluateStatic
            QCLM       =  0.0;
            xs_ov      =  0.0;
            xd_ov      =  0.0;
            Vovs       =  0.0;
            Vovd       =  0.0;
            Iimpact    =  0.0;
            mavl       =  0.0;

`ifdef NQSmodel

            // Initialization of variables for NQS model
            pd         =  1.0;
            ym         =  0.0;
`endif // NQSmodel

            Vrg        =  V(G , GP);
            Vrs        =  V(S , SI);
            Vrd        =  V(D , DI);
            Vrjuns     =  V(BS, BI);
            Vrjund     =  V(BD, BI);
            Vrbulk     =  V(BP, BI);
            Vrwell     =  V(B , BI);

            if (CHNL_TYPE == `NMOS) begin
                Vgs        =  V(GP, SI);
                Vds        =  V(DI, SI);
                Vsb        =  V(SI, BP);
                Vjun_s     = -V(SI, BS);
                Vjun_d     = -V(DI, BD);
            end else begin
                Vgs        = -V(GP, SI);
                Vds        = -V(DI, SI);
                Vsb        = -V(SI, BP);
                Vjun_s     =  V(SI, BS);
                Vjun_d     =  V(DI, BD);
            end

            // Voltages NOT subject to S/D-interchange
            VgsPrime   = Vgs;
            VsbPrime   = Vsb;
            VdbPrime   = Vds + Vsb;
            VgdPrime   = Vgs - Vds;
            xgs_ov     = -VgsPrime * inv_phit;
            xgd_ov     = -VgdPrime * inv_phit;

            // Source-drain interchange
            sigVds     =  1.0;
            if (Vds < 0.0) begin
                sigVds     = -1.0;
                Vgs        =  Vgs - Vds;
                Vsb        =  Vsb + Vds;
                Vds        = -Vds;
            end

            Vgd        =  Vgs - Vds;
            Vdb        =  Vds + Vsb;
            Vdsx       =  sqrt(Vds * Vds + 0.01) - 0.1;

            begin : SPcalc_dc

                `SPcalcLocalVarDecl
                real FdL, qim1_1, r1, r2, s2, dL1;
                 
                // 4.2.1 Conditioning of terminal voltages
                temp       =  `MINA(Vdb, Vsb, bphi_dc) + phix_dc;
                Vsbstar_dc =  Vsb - `MINA(temp, 0, aphi_dc) + phix1_dc;

                // Adapt Vsb for NUD-effect
                if ((SWNUD_i != 0) && (GFACNUD_i != 1.0)) begin
                    Vmb        =  Vsbstar_dc + 0.5 * (Vds - Vdsx);
                    us         =  sqrt(Vmb + phib_dc) - sqrt_phib_dc;
                    temp       =  2 * (us - us1) / us21 - 1;
                    usnew      = us - 0.25 * (1 - GFACNUD_i) * us21 * (temp + sqrt(temp * temp + 0.4804530139182));
                    Vmbnew     = usnew * usnew + (2 * sqrt_phib_dc) * usnew;
                    Vsbnud     = Vmbnew - 0.5 * (Vds - Vdsx);
                end else begin
                    Vsbnud     = Vsbstar_dc;
                end

                phib        =  phib_dc;
                G_0         =  G_0_dc;
                sqrt_phib   =  sqrt_phib_dc;
                Vsbstar     =  Vsbnud;
                FdL         =  1.0;
                
                `include "PSP103_SPCalculation.include"

                if (xg > 0.0) begin
                    qim1_1      =  1.0 / qim1;
                    r1          =  qim * qim1_1;
                    r2          =  phit1 * (alpha * qim1_1);
                    s2          =  ln(1.0 + Vdsx * inv_VP);
                    dL1         =  dL + ALP1_i * (qim1_1 * r1 * s1) + ALP2_i * (qbm * r2 * r2 * s2);
                    FdL         =  (1.0 + dL1 + dL1 * dL1) * GdL;
                end // (xg > 0)

                xg_dc       = xg;
                qeff1_dc    = qeff1;
                Voxm_dc     = Voxm;
                alpha_dc    = alpha;
                dps_dc      = dps;
                qim_dc      = qim;
                qim1_dc     = qim1;
                GdL_dc      = GdL;
                FdL_dc      = FdL;
                H_dc        = H;
                eta_p_dc    = eta_p;
                Gvsat_dc    = Gvsat;
                Gvsatinv_dc = Gvsatinv;
                Gmob_dL_dc  = Gmob_dL;
                x_ds_dc     = x_ds;
                x_m_dc      = x_m;
                Gf_dc       = Gf;
                Vdsat_dc    = Vdsat;
                Udse_dc     = Udse;
`ifdef NQSmodel
                xgm_dc      = xgm;
                margin_dc   = margin;
                thesat1_dc  = thesat1;
`endif // NQSmodel
                
            end // SPcalc_dc

            if (xg_dc <= 0) begin
                Ids        =  0.0;
            end else begin
                // Drain-source current
                Ids        =  BET_i * (FdL_dc * qim1_dc * dps_dc * Gvsatinv_dc);

                // 4.2.11 Impact-Ionization
                if (SWIMPACT_i != 0) begin
                    delVsat       =  Vds - A3_i * dps_dc;
                    if (delVsat > 0) begin
                        temp2        =  A2_i * ((1.0 + A4_i * (sqrt(phib_dc + Vsbnud) - sqrt_phib_dc)) / (delVsat + 1e-30));
                        `expl_low(-temp2, temp)
                        mavl         =  A1_i * (delVsat * temp);
                        Iimpact      =  Ids * mavl;
                    end
                end
            end

            // 4.2.12 Surface potential in gate overlap regions
            if (((SWIGATE_i != 0) && ((IGOV_i > 0) || (IGOVD_i > 0))) || ((SWGIDL_i != 0) && ((AGIDL_i > 0) || (AGIDLD_i > 0))) || (CGOV_i > 0) || (CGOVD_i > 0)) begin
                `ChangeToSource
                `sp_ov(xs_ov, xgs_ov)
                `ChangeToDrain
                `sp_ov(xd_ov, xgd_ov)
                Vovs        = -phit * (xgs_ov + xs_ov);
                Vovd        = -phit * (xgd_ov + xd_ov);
            end

            // 4.2.13 Gate current
            Igsov      =  0.0;
            Igdov      =  0.0;
            Igc        =  0.0;
            Igb        =  0.0;
            Igcs       =  0.0;
            Igcd       =  0.0;
            if (SWIGATE_i != 0) begin
                if (IGOV_i > 0) begin

                    // Gate-source overlap component of gate current
                    arg2mina   =  Vovs + Dov;
                    psi_t      = `MINA(0.0, arg2mina, 0.01);
                    zg         =  sqrt(Vovs * Vovs + 1.0e-6) * inv_CHIB;
                    if (GC3_i < 0) begin
                        zg         = `MINA(zg, GCQ, 1.0e-6);
                    end
                    arg1       =  (3.0 + xs_ov + psi_t * inv_phit);
                    `expl(arg1, Dsi)
                    arg1       =  -VgsPrime * inv_phit;
                    `expl(arg1, temp)
                    Dgate      =  Dsi * temp;
                    temp       =  BOV * (-1.5 + zg * (GC2_i + GC3_i * zg));
                    if (temp > 0) begin
                        TP         = `P3(temp);
                    end else begin
                        `expl_low(temp, TP)
                    end
                    Igsov      =  IGOV_i * (TP * ln((1.0 + Dsi) / (1.0 + Dgate)));
                end

                if (IGOVD_i > 0) begin

                    // Gate-drain overlap component of gate current
                    arg2mina   =  Vovd + Dov;
                    psi_t      = `MINA(0.0, arg2mina, 0.01);
                    zg         =  sqrt(Vovd * Vovd + 1.0e-6) * inv_CHIB;
                    if (GC3_i < 0) begin
                        zg         = `MINA(zg, GCQ, 1.0e-6);
                    end
                    arg1       =  (3.0 + xd_ov + psi_t * inv_phit);
                    `expl(arg1, Dsi)
                    arg1       =  -VgdPrime * inv_phit;
                    `expl(arg1, temp)
                    Dgate      =  Dsi * temp;
                    temp       =  BOV_d * (-1.5 + zg * (GC2_i + GC3_i * zg));
                    if (temp > 0) begin
                        TP         = `P3(temp);
                    end else begin
                        `expl_low(temp, TP)
                    end
                    Igdov      =  IGOVD_i * (TP * ln((1.0 + Dsi) / (1.0 + Dgate)));
                end

                // Gate-channel component of gate current
                if (IGINV_i > 0) begin
                    if (xg_dc <= 0.0) begin
                        temp       =  pow(Vds / Vdsat_lim, AX_i);
                        Udse_dc    =  Vds * pow(1.0 + temp, -inv_AX) * inv_phit1;
                    end
                    `expl_low(x_ds_dc-Udse_dc, temp)
                    Vm         =  Vsbnud + phit1 * (0.5 * x_ds_dc - ln(0.5 * (1.0 + temp)));

                    arg2mina   =  Voxm_dc + Dch;
                    psi_t      = `MINA(0.0, arg2mina, 0.01);
                    zg         =  sqrt(Voxm_dc * Voxm_dc + 1.0e-6) * inv_CHIB;
                    if (GC3_i < 0) begin
                        zg     = `MINA(zg, GCQ, 1.0e-06);
                    end
                    arg1       =  (x_m_dc + (psi_t - alpha_b - Vm) * inv_phit1);
                    `expl(arg1,Dsi)
                    arg1       = -(Vgs + Vsbnud - Vm) * inv_phit1;
                    `expl(arg1,temp)
                    Dgate      =  Dsi * temp;
                    temp       = BCH * (-1.5 + zg * (GC2_i + GC3_i * zg));
                    if (temp > 0) begin
                        TP         = `P3(temp);
                    end else begin
                        `expl_low(temp, TP)
                    end
                    Igc0       =  IGINV_i * (TP * ln((1.0 + Dsi) / (1.0 + Dgate)));

                    // Source/drain partitioning of gate-channel current
                    if ((xg_dc <= 0) || ((GC2_i == 0) && (GC3_i == 0))) begin
                        igc        =  1.0;
                        igcd_h     =  0.5;
                    end else begin
                        temp       =  GC2_i + 2.0 * GC3_i * zg;
                        u0         =  CHIB_i / (temp * BCH);
                        x          =  0.5 * (dps_dc / u0);
                        u0_div_H   =  u0 / H_dc;
                        Bg         =  u0_div_H * (1.0 - u0_div_H) * 0.5;
                        Ag         =  0.5 - 3.0 * Bg;
                        if (x < 1.0e-3) begin
                            xsq        =  x * x;
                            igc        =  1.0 + xsq * (`oneSixth + u0_div_H * `oneThird + `oneSixth * (xsq * (0.05 + 0.2 * u0_div_H)));
                            igcd_h     =  0.5 * igc - `oneSixth * (x * (1.0 + xsq * (0.4 * (Bg + 0.25) + 0.0285714285714 * (xsq * (0.125 + Bg)))));
                        end else begin
                            inv_x      =  1.0 / x;
                            `expl(x, ex)
                            inv_ex     =  1.0 / ex;
                            temp       =  ex - inv_ex;
                            temp2      =  ex + inv_ex;
                            igc        =  0.5 * ((1.0 - u0_div_H) * temp * inv_x + u0_div_H * temp2);
                            igcd_h     =  0.5 * (igc - temp * (Bg - Ag * inv_x * inv_x) - Ag * temp2 * inv_x);
                        end
                    end
                    Sg         =  0.5 * (1.0 + xg_dc / sqrt(xg_dc * xg_dc + 1.0e-6));
                    Igc        =  Igc0 * igc * Sg;
                    Igcd       =  Igc0 * igcd_h * Sg;
                    Igcs       =  Igc - Igcd;
                    Igb        =  Igc0 * igc * (1.0 - Sg);
                end // (IGINV >0)
            end // (SWIGATE != 0)

            // 4.2.14 GIDL/GISL current
            Igidl        = 0.0;
            Igisl        = 0.0;
            if (SWGIDL_i != 0) begin

                // GIDL current computation
                if ((AGIDLD_i > 0) && (Vovd < 0)) begin
                    Vtovd        = sqrt(Vovd * Vovd + CGIDLD_i * CGIDLD_i * (VdbPrime * VdbPrime) + 1.0e-6);
                    temp = -BGIDLD_i / Vtovd;
                    `expl_low(temp, temp2)
                    Igidl        = -AGIDLD_i * (VdbPrime * Vovd * Vtovd * temp2);
                end

                // GISL current computation
                if ((AGIDL_i > 0) && (Vovs < 0)) begin
                    Vtovs        = sqrt(Vovs * Vovs + CGIDL_i * CGIDL_i * (VsbPrime * VsbPrime) + 1.0e-6);
                    temp = -BGIDL_i / Vtovs;
                    `expl_low(temp, temp2)
                    Igisl        = -AGIDL_i * (VsbPrime * Vovs * Vtovs * temp2);
                end
            end // (SWGIDL != 0)

        end // evaluateStatic


        /////////////////////////////////////////////////////////////////////////////
        //
        //      AC bias dependent quantities (calculations for charge contribs)
        //
        /////////////////////////////////////////////////////////////////////////////

        begin : evaluateDynamic

            begin : SPcalc_ac

                `SPcalcLocalVarDecl

                if ((SWNUD_i == 1) || (SWDELVTAC_i != 0)) begin

                    if (SWDELVTAC_i != 0) begin
                        // Conditioning of terminal voltages
                        temp       = `MINA(Vdb, Vsb, bphi_ac) + phix_ac;
                        Vsbstar_ac = Vsb - `MINA(temp, 0, aphi_ac) + phix1_ac;
                        Vsbstar    = Vsbstar_ac;
                        phib       = phib_ac;
                        G_0        = G_0_ac;
                        sqrt_phib  = sqrt_phib_ac;
                    end else begin
                        Vsbstar    = Vsbstar_dc;
                        phib      = phib_dc;
                        G_0       = G_0_dc;
                        sqrt_phib = sqrt_phib_dc;
                    end

                    `include "PSP103_SPCalculation.include"

                    xg_ac       = xg;
                    qeff1_ac    = qeff1;
                    Voxm_ac     = Voxm;
                    alpha_ac    = alpha;
                    dps_ac      = dps;
                    qim_ac      = qim;
                    qim1_ac     = qim1;
                    GdL_ac      = GdL;
                    H_ac        = H;
                    eta_p_ac    = eta_p;
                    Gvsat_ac    = Gvsat;
                    Gmob_dL_ac  = Gmob_dL;
                    x_m_ac      = x_m;
                    Gf_ac       = Gf;
`ifdef NQSmodel
                    xgm_ac      = xgm;
                    margin_ac   = margin;
                    thesat1_ac  = thesat1;
`endif // NQSmodel
                end else begin
                    xg_ac       = xg_dc;
                    qeff1_ac    = qeff1_dc;
                    Voxm_ac     = Voxm_dc;
                    alpha_ac    = alpha_dc;
                    dps_ac      = dps_dc;
                    qim_ac      = qim_dc;
                    qim1_ac     = qim1_dc;
                    GdL_ac      = GdL_dc;
                    H_ac        = H_dc;
                    eta_p_ac    = eta_p_dc;
                    Gvsat_ac    = Gvsat_dc;
                    Gmob_dL_ac  = Gmob_dL_dc;
                    x_m_ac      = x_m_dc;
                    Gf_ac       = Gf_dc;
`ifdef NQSmodel
                    xgm_ac      = xgm_dc;
                    margin_ac   = margin_dc;
                    thesat1_ac  = thesat1_dc;
`endif // NQSmodel
                end
            
            end // SPcalc_ac
            
            
            // 4.2.16 Quantum mechanical corrections
            Vgb        =  Vgs + Vsb;
            COX_qm     =  COX_i;
            if (qq > 0.0) begin
                COX_qm     =  COX_i / (1.0 + qq * pow(qeff1_ac * qeff1_ac + qlim2, -1.0 * `oneSixth));
            end

            // 4.2.17 Intrinsic charge model
            if (xg_ac <= 0.0) begin
                QG         =  Voxm_ac;
                QI         =  0.0;
                QD         =  0.0;
                QB         =  QG;
            end else begin
                Fj         =  0.5 * (dps_ac / H_ac);
                Fj2        =  Fj * Fj;
                QCLM       =  (1.0 - GdL_ac) * (qim_ac - 0.5 * (alpha_ac * dps_ac));
                QG         =  Voxm_ac + 0.5 * (eta_p_ac * dps_ac * (Fj * GdL_ac * `oneThird - 1.0 + GdL_ac));
                temp       =  alpha_ac * dps_ac * `oneSixth;
                QI         =  GdL_ac * (qim_ac + temp * Fj) + QCLM;
                QD         =  0.5 * (GdL_ac * GdL_ac * (qim_ac - temp * (1.0 - Fj - 0.2 * Fj2)) + QCLM * (1.0 + GdL_ac));
                QB         =  QG - QI;
            end
            Qg         =  QG * COX_qm;
            Qd         = -QD * COX_qm;
            Qb         = -QB * COX_qm;

            // 4.2.18 Extrinsic charge model
            Qgs_ov     =  CGOV_i * Vovs;
            Qgd_ov     =  CGOVD_i * Vovd;
            Qgb_ov     =  CGBOV_i * Vgb;

            // Outer fringe charge
            Qfgs       =  CFR_i * VgsPrime;
            Qfgd       =  CFRD_i * VgdPrime;
`ifdef NQSmodel

            // Variables for NQS model
            Gp         =  0.0;
            Gp2        =  0.0;
            a_factrp   =  0.0;
            marginp    =  0.0;
            if (SWNQS_i != 0) begin
                if (xg_ac <= 0.0) begin
                    ym         =  0.5;
                    pd         =  1.0;
                    Gp         =  Gf_ac;
                end else begin
                    ym         =  0.5 * ( 1.0 + 0.25 * (dps_ac / H_ac));
                    pd         =  xgm_ac / (xg_ac - x_m_ac);
                    Gp         =  Gf_ac / pd;
                end
                Gp2        =  Gp * Gp;
                a_factrp   =  1.0 + Gp * `invSqrt2;
                marginp    =  1e-5 * a_factrp;
            end
`endif // NQSmodel

        end // evaluateDynamic


        /////////////////////////////////////////////////////////////////////////////
        //
        //      JUNCAP2 contribs
        //
        /////////////////////////////////////////////////////////////////////////////

        begin : evaluateStaticDynamic

            if (SWJUNCAP_i > 0) begin
                if (SWJUNEXP_i == 1) begin
                    `JuncapExpressCurrent(Vjun_s, MFOR1_s, ISATFOR1_s, MFOR2_s, ISATFOR2_s, MREV_s, ISATREV_s, m0flag_s, xhighf1_s, expxhf1_s, xhighf2_s, expxhf2_s, xhighr_s, expxhr_s, ijun_s)
                    `JuncapExpressCurrent(Vjun_d, MFOR1_d, ISATFOR1_d, MFOR2_d, ISATFOR2_d, MREV_d, ISATREV_d, m0flag_d, xhighf1_d, expxhf1_d, xhighf2_d, expxhf2_d, xhighr_d, expxhr_d, ijun_d)
                    begin : evaluateDynamic
                        `SetJunModelParsToSource
                        `JuncapExpressCharge(Vjun_s, ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, vfmin_s, vch_s, zflagbot_s, zflagsti_s, zflaggat_s, qjunbot_s, qjunsti_s, qjungat_s)
                        `SetJunModelParsToDrain
                        `JuncapExpressCharge(Vjun_d, ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i,  vfmin_d, vch_d, zflagbot_d, zflagsti_d, zflaggat_d, qjunbot_d, qjunsti_d, qjungat_d)
                    end
                end else begin
                    `SetJunModelParsToSource
                    `juncapcommon(Vjun_s, ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s, ijunbot_s, qjunbot_s, ijunsti_s, qjunsti_s, ijungat_s, qjungat_s)
                    ijun_s = ABSOURCE_i * ijunbot_s + LSSOURCE_i * ijunsti_s + LGSOURCE_i * ijungat_s;
                    `SetJunModelParsToDrain
                    `juncapcommon(Vjun_d, ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i,  VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d, ijunbot_d, qjunbot_d, ijunsti_d, qjunsti_d, ijungat_d, qjungat_d)
                    ijun_d = ABDRAIN_i * ijunbot_d + LSDRAIN_i * ijunsti_d + LGDRAIN_i * ijungat_d;
                end
            end

`ifdef NQSmodel
            // Set initial conditions for NQS model
            `include "PSP103_InitNQS.include"

`endif // NQSmodel
        end // evaluateStaticDynamic


        /////////////////////////////////////////////////////////////////////////////
        //
        //      Current contribs
        //
        /////////////////////////////////////////////////////////////////////////////

        begin : loadStatic

            // 4.2.15 Total terminal currents

            // Intrinsic MOSFET current
            Idse       = MULT_i * Ids;

            // Gate (tunneling) current components
            Igbe       = MULT_i * Igb;
            Igcse      = MULT_i * Igcs;
            Igcde      = MULT_i * Igcd;
            Igsove     = MULT_i * Igsov;
            Igdove     = MULT_i * Igdov;

            // GIDL/GISL current
            Igidle     = MULT_i * Igidl;
            Igisle     = MULT_i * Igisl;

            // Impact ionization current
            Iimpacte   = MULT_i * Iimpact;

            // JUNCAP2
            ijun_s = MULT_i * ijun_s;
            ijun_d = MULT_i * ijun_d;

            // Convert back for NMOS-PMOS and Source-Drain interchange
            if (sigVds > 0) begin
                I(DI, BP)     <+  CHNL_TYPE * Iimpacte;
                I(DI, SI)     <+  CHNL_TYPE * Idse;
                I(GP, SI)     <+  CHNL_TYPE * Igcse;
                I(GP, DI)     <+  CHNL_TYPE * Igcde;
            end else begin
                I(SI, BP)     <+  CHNL_TYPE * Iimpacte;
                I(SI, DI)     <+  CHNL_TYPE * Idse;
                I(GP, DI)     <+  CHNL_TYPE * Igcse;
                I(GP, SI)     <+  CHNL_TYPE * Igcde;
            end
            I(GP, BP)    <+  CHNL_TYPE * Igbe;
            I(GP, SI)    <+  CHNL_TYPE * Igsove;
            I(GP, DI)    <+  CHNL_TYPE * Igdove;
            I(SI, BP)    <+  CHNL_TYPE * Igisle;
            I(DI, BP)    <+  CHNL_TYPE * Igidle;
            I(BS, SI)    <+  CHNL_TYPE * ijun_s;
            I(BD, DI)    <+  CHNL_TYPE * ijun_d;

            // Parasitic resistances (including noise)
            rgatenoise   = nt0 * MULT_i * ggate;
            rsourcenoise = nt0 * MULT_i * gsource;
            rdrainnoise  = nt0 * MULT_i * gdrain;
            rbulknoise   = nt0 * MULT_i * gbulk;
            rjunsnoise   = nt0 * MULT_i * gjuns;
            rjundnoise   = nt0 * MULT_i * gjund;
            rwellnoise   = nt0 * MULT_i * gwell;

            `CollapsableR(MULT_i * ggate,   RG_i,    rgatenoise,   G,  GP, "rgate")
            `CollapsableR(MULT_i * gsource, RSE_i,   rsourcenoise, S,  SI, "rsource")
            `CollapsableR(MULT_i * gdrain,  RDE_i,   rdrainnoise,  D,  DI, "rdrain")
            `CollapsableR(MULT_i * gbulk,   RBULK_i, rbulknoise,   BP, BI, "rbulk")
            `CollapsableR(MULT_i * gjuns,   RJUNS_i, rjunsnoise,   BS, BI, "rjuns")
            `CollapsableR(MULT_i * gjund,   RJUND_i, rjundnoise,   BD, BI, "rjund")
            `CollapsableR(MULT_i * gwell,   RWELL_i, rwellnoise,   B,  BI, "rwell")

            I(DI, SI)  <+  `GMIN * V(DI, SI);

        end // loadStatic

        /////////////////////////////////////////////////////////////////////////////
        //
        //      ddt() contribs from charges (Note: MULT is handled explicitly)
        //
        /////////////////////////////////////////////////////////////////////////////

`ifdef NQSmodel
        begin : loadStaticDynamic
            // Calculate NQS charge contributions
            `include "PSP103_ChargesNQS.include"
        end
`endif // NQSmodel

        begin : loadDynamic

            // 4.2.19 Total terminal charges

            // Intrinsic MOSFET charges
            Qg         =  MULT_i * Qg;
            Qb         =  MULT_i * Qb;
            Qd         =  MULT_i * Qd;
            Qs         =  -(Qg + Qb + Qd);

            // Total outerFringe + overlap for
            //    gate-source and gate-drain.
            Qfgs       =  MULT_i * (Qfgs + Qgs_ov);
            Qfgd       =  MULT_i * (Qfgd + Qgd_ov);

            // Gate-bulk overlap charge
            Qgb_ov     =  MULT_i * Qgb_ov;

            // JUNCAP2
            qjun_s = MULT_i * (ABSOURCE_i * qjunbot_s + LSSOURCE_i * qjunsti_s + LGSOURCE_i * qjungat_s);
            qjun_d = MULT_i * (ABDRAIN_i * qjunbot_d + LSDRAIN_i * qjunsti_d + LGDRAIN_i * qjungat_d);

            // Convert back (undo S-D interchange)
            if (sigVds < 0) begin
                temp       = Qd;    // Qd <--> Qs
                Qd         = Qs;
                Qs         = temp;
            end

            I(GP, SI)    <+  ddt(CHNL_TYPE * Qg);
            I(BP, SI)    <+  ddt(CHNL_TYPE * Qb);
            I(DI, SI)    <+  ddt(CHNL_TYPE * Qd);
            I(GP, SI)    <+  ddt(CHNL_TYPE * Qfgs);
            I(GP, DI)    <+  ddt(CHNL_TYPE * Qfgd);
            I(GP, BP)    <+  ddt(CHNL_TYPE * Qgb_ov);
            I(BS, SI)    <+  ddt(CHNL_TYPE * qjun_s);
            I(BD, DI)    <+  ddt(CHNL_TYPE * qjun_d);

        end // loadDynamic

`ifdef useNOInodes
        /////////////////////////////////////////////////////////////////////////////
        //
        //  Noise
        //
        /////////////////////////////////////////////////////////////////////////////

        begin : noise

            // 4.2.20 Noise variable calculation
            Sfl        =  0.0;
            mid        =  0.0;
            mig        =  0.0;
            migid      =  0.0;
            c_igid     =  0.0;
            CGeff      =  COX_qm * eta_p_ac;
            sqid       =  0.0;
            sqig       =  0.0;
            if ((xg_dc > 0.0) && (MULT_i > 0.0) && (BET_i > 0.0)) begin
                N1         =  Cox_over_q * alpha_dc * phit;
                Nm1        =  Cox_over_q * qim1_dc;
                Delta_N1   =  Cox_over_q * (alpha_dc * dps_dc);
                Sfl        =  (NFA_i - NFB_i * N1 + NFC_i * (N1 * N1)) * ln((Nm1 + 0.5 * Delta_N1) / (Nm1 - 0.5 * Delta_N1));
                Sfl        =  Sfl + (NFB_i + NFC_i * (Nm1 - 2.0 * N1)) * Delta_N1;
                Sfl        =  Sfl_prefac * Ids * Gvsatinv_dc * Sfl / N1;
                Sfl        =  `CLIP_LOW(Sfl, 0.0);

                H0         =  qim1_dc / alpha_dc;
                t1         =  qim_dc / qim1_dc;
                sqt2       =  0.5 * `oneSixth * (dps_dc / H0);
                t2         =  sqt2 * sqt2;
                r          =  H0 / H_dc - 1.0;
                lc         =  `CLIP_LOW(1.0 - 12 * (r * t2), 1e-20);
                lcinv2     =  1 / (lc * lc);
                g_ideal    =  BET_i * (FdL_dc * qim1_dc * Gvsatinv_dc);
                CGeff      =  Gvsat_ac * Gvsat_ac * COX_qm * eta_p_ac / (Gmob_dL_ac * Gmob_dL_ac);
                mid        =  t1 + 12 * t2 - 24 * ((1.0 + t1) * t2 * r);
                mid        =  `CLIP_LOW(mid, 1e-40);
                mid        =  g_ideal * lcinv2 * mid;
                mig        =  t1 / 12 - t2 * (t1 + 0.2 - 12 * t2) - 1.6 * (t2 * (t1 + 1.0 - 12 * t2) * r);
                mig        =  `CLIP_LOW(mig, 1e-40);
                mig        =  lcinv2 / g_ideal * mig;
                migid      =  lcinv2 * sqt2 * (1.0 - 12 * t2 - (t1 + 19.2 * t2 - 12 * (t1 * t2)) * r);
                sqid       =  sqrt(MULT_i * nt * mid);
                sqig       =  sqrt(MULT_i * nt / mig);
                if (sqid == 0) begin
                    c_igid     =  0.0;
                end else begin
                    c_igid     =  migid * sqig / sqid; // = migid / sqrt(mig * mid);
                end
                c_igid     =  `CLIP_BOTH(c_igid, 0.0, 1.0);
            end
            shot_igcsx  = 2.0 * `QELE * abs(Igcse);
            shot_igcdx  = 2.0 * `QELE * abs(Igcde);
            shot_igsov  = 2.0 * `QELE * abs(Igsove);
            shot_igdov  = 2.0 * `QELE * abs(Igdove);
            shot_iavl   = 2.0 * `QELE * ((mavl + 1) * abs(Iimpacte));
            // JUNCAP2
            jnoisex_s  = 2.0 * `QELE * abs(ijun_s);
            jnoisex_d  = 2.0 * `QELE * abs(ijun_d);
            if (sigVds > 0) begin
                shot_igs   =  shot_igcsx + shot_igsov;
                shot_igd   =  shot_igcdx + shot_igdov;
                jnoise_s   =  jnoisex_s;
                jnoise_d   =  jnoisex_d + shot_iavl;
            end else begin
                shot_igs   =  shot_igcdx + shot_igsov;
                shot_igd   =  shot_igcsx + shot_igdov;
                jnoise_s   =  jnoisex_s + shot_iavl;
                jnoise_d   =  jnoisex_d;
            end

            // Important note:
            // In Verilog-A, correlated noise sources can only be implemented by using two additional
            // internal nodes (NOI and NOI2). When implementing PSP in a circuit simlutor, it is
            // generally not necessary to retain these internal nodes and therefore (for execution
            // speed reasons) should be avoided.

            // Noise contribs
            I(NOI2)   <+  V(NOI2);
            I(NOI2)   <+  white_noise(c_igid, "igid");
            I(NOII)   <+  white_noise(sqig * sqig * (1.0 - c_igid), "igig");
            I(NOII)   <+  -sqig * V(NOI2);
            I(NOIR)   <+  V(NOIR);
            I(NOIC)   <+  ddt(mig * CGeff * V(NOIC));
            I(DI,SI)  <+  flicker_noise(MULT_i * Sfl, EF_i, "flicker");
            I(DI,SI)  <+  white_noise(sqid * sqid * (1.0 - c_igid), "idid");
            I(DI,SI)  <+  sqid * V(NOI2);
            I(GP,SI)  <+  ddt(0.5 * ((1.0 + sigVds) * mig * CGeff * V(NOIC)));
            I(GP,DI)  <+  ddt(0.5 * ((1.0 - sigVds) * mig * CGeff * V(NOIC)));
            I(GP,SI)  <+  white_noise(shot_igs, "igs");
            I(GP,DI)  <+  white_noise(shot_igd, "igd");
            // JUNCAP2
            I(BS,SI)  <+  white_noise(jnoise_s, "ibs");
            I(BD,DI)  <+  white_noise(jnoise_d, "ibd");
        end // noise
`endif // useNOInodes


`ifdef doOPinfo
        /////////////////////////////////////////////////////////////////////////////
        //
        // Operating point info
        //
        /////////////////////////////////////////////////////////////////////////////

        begin : OPinfo

            // The output variables defined below are currently not available in
            // Verilog-A, but only in the SiMKit-C-code which was generated from
            // this source. Similar functionality will be available in Verilog-A
            // from Verilog-A version 2.2 onwards. However, a different syntax is
            // to be used (see Verilog AMS language reference manual, version 2.2,
            // november 2004, Accellera).

            // Auxiliary variables
            id_op     = Idse + Iimpacte - Igcde;
            is        = -Idse - Igcse;
            ig        = Igcse + Igcde + Igsove + Igdove + Igbe;
            ib        = -Iimpacte - Igbe - Igidle - Igisle;

            P_D        = 1 + 0.25 * (Gf_dc * kp);
            facvsb0    = phib_dc + 2 * phit1;
            facvsb     = Vsbnud + facvsb0;
            sig1k      = 2 * `PI * 1000 * CGeff;
            sig1k      = sig1k * sig1k * mig;

            ////////////////////////////////////////////////////////////////////////////////////
            //
            // Actual operation point output variables
            //
            ////////////////////////////////////////////////////////////////////////////////////

            // Note: In this section (and ONLY in this section) `drain' always refers to
            //       the highest-potential end of the channel. Therefore, care has to be
            //       taken for derivatives w.r.t. terminal voltages when sigVds == -1.

            sdint      = sigVds;
            ctype      = CHNL_TYPE;

            if (sigVds < 0) begin
                // All variables in the actual model refering to junctions are
                // not subject to SD-interchange. In the OP-output variables,
                // SD-interchange is also done for the junctions, so that's
                // what is happening here. Similar precautions have to be taken
                // for those variables that are derivatives w.r.t. voltage branches
                ise        = is - Igdove + Igidle - ijun_d;
                ige        = ig;
                ide        = id_op - Igsove + Igisle - ijun_s;
                ibe        = ib + ijun_s + ijun_d;
                ids        = Idse;
                idb        = Iimpacte + Igisle - ijun_s;
                isb        = Igidle - ijun_d;
                igs        = Igcse + Igdove;
                igd        = Igcde + Igsove;
                igb        = Igbe;
                igcs       = MULT_i * Igcs;
                igcd       = MULT_i * Igcd;
                iavl       = Iimpacte;
                igisl      = Igidle;
                igidl      = Igisle;

                if (SWJUNEXP_i == 1) begin
                    ijsbot     = 0.0;
                    ijsgat     = 0.0;
                    ijssti     = 0.0;
                    ijdbot     = 0.0;
                    ijdgat     = 0.0;
                    ijdsti     = 0.0;
                end else begin
                    ijsbot     = MULT_i * ABDRAIN_i * ijunbot_d;
                    ijsgat     = MULT_i * LGDRAIN_i * ijungat_d;
                    ijssti     = MULT_i * LSDRAIN_i * ijunsti_d;
                    ijdbot     = MULT_i * ABSOURCE_i * ijunbot_s;
                    ijdgat     = MULT_i * LGSOURCE_i * ijungat_s;
                    ijdsti     = MULT_i * LSSOURCE_i * ijunsti_s;
                end
                ijs        = ijun_d;
                ijd        = ijun_s;

                vds        = Vds;
                vgs        = Vgs;
                vsb        = Vsb;
                vto        = VFB_i + P_D * facvsb0         + Gf_dc * sqrt(phit1 * facvsb0);
                vts        = VFB_i + P_D * facvsb - Vsbnud + Gf_dc * sqrt(phit1 * facvsb );
                vth        = vts - delVg;
                vgt        = vgs - vth;
                vdss       = Vdsat_dc;
                vsat       = Vds - vdss;

                temp       = Idse + Iimpacte + Igisle - Igcde - Igsove - ijun_s; // Total drain-current
`ifdef OPderiv
                gm         =  CHNL_TYPE * ddx(temp, V(GP));
                gmb        =  CHNL_TYPE * ddx(temp, V(BP));
                gds        =  CHNL_TYPE * ddx(temp, V(SI));

                gjs        =  ddx(ijun_d, V(BD));
                gjd        =  ddx(ijun_s, V(BS));

                css        =  CHNL_TYPE * ddx(Qd, V(DI));
                csg        = -CHNL_TYPE * ddx(Qd, V(GP));
                csb        = -CHNL_TYPE * ddx(Qd, V(BP));
                csd        =  css - csg - csb;
                cgs        = -CHNL_TYPE * ddx(Qg, V(DI));
                cgg        =  CHNL_TYPE * ddx(Qg, V(GP));
                cgb        = -CHNL_TYPE * ddx(Qg, V(BP));
                cgd        =  cgg - cgs - cgb;
                cds        = -CHNL_TYPE * ddx(Qs, V(DI));
                cdg        = -CHNL_TYPE * ddx(Qs, V(GP));
                cdb        = -CHNL_TYPE * ddx(Qs, V(BP));
                cdd        =  cdg + cds + cdb;
                cbs        = -CHNL_TYPE * ddx(Qb, V(DI));
                cbg        = -CHNL_TYPE * ddx(Qb, V(GP));
                cbb        =  CHNL_TYPE * ddx(Qb, V(BP));
                cbd        =  cbb - cbs - cbg;
                cgsol      =  CHNL_TYPE * ddx(Qfgd, V(GP));
                cgdol      =  CHNL_TYPE * ddx(Qfgs, V(GP));

                cjsbot     = -MULT_i * CHNL_TYPE * ABDRAIN_i * ddx(qjunbot_d, V(DI));
                cjsgat     = -MULT_i * CHNL_TYPE * LGDRAIN_i * ddx(qjungat_d, V(DI));
                cjssti     = -MULT_i * CHNL_TYPE * LSDRAIN_i * ddx(qjunsti_d, V(DI));
                cjs        =  cjsbot + cjsgat + cjssti;
                cjdbot     = -MULT_i * CHNL_TYPE * ABSOURCE_i * ddx(qjunbot_s, V(SI));
                cjdgat     = -MULT_i * CHNL_TYPE * LGSOURCE_i * ddx(qjungat_s, V(SI));
                cjdsti     = -MULT_i * CHNL_TYPE * LSSOURCE_i * ddx(qjunsti_s, V(SI));
                cjd        =  cjdbot + cjdgat + cjdsti;
`endif // OPderiv
            end else begin
                ise        = is - Igsove + Igisle - ijun_s;
                ige        = ig;
                ide        = id_op - Igdove + Igidle - ijun_d;
                ibe        = ib + ijun_s + ijun_d;
                ids        = Idse;
                idb        = Iimpacte + Igidle - ijun_d;
                isb        = Igisle - ijun_s;
                igs        = Igcse + Igsove;
                igd        = Igcde + Igdove;
                igb        = Igbe;
                igcs       = MULT_i * Igcs;
                igcd       = MULT_i * Igcd;
                iavl       = Iimpacte;
                igisl      = Igisle;
                igidl      = Igidle;

                if (SWJUNEXP_i == 1) begin
                    ijsbot     = 0.0;
                    ijsgat     = 0.0;
                    ijssti     = 0.0;
                    ijdbot     = 0.0;
                    ijdgat     = 0.0;
                    ijdsti     = 0.0;
                end else begin
                    ijsbot     = MULT_i * ABSOURCE_i * ijunbot_s;
                    ijsgat     = MULT_i * LGSOURCE_i * ijungat_s;
                    ijssti     = MULT_i * LSSOURCE_i * ijunsti_s;
                    ijdbot     = MULT_i * ABDRAIN_i * ijunbot_d;
                    ijdgat     = MULT_i * LGDRAIN_i * ijungat_d;
                    ijdsti     = MULT_i * LSDRAIN_i * ijunsti_d;
                end
                ijs        = ijun_s;
                ijd        = ijun_d;

                vds        = Vds;
                vgs        = Vgs;
                vsb        = Vsb;
                vto        = VFB_i + P_D * facvsb0         + Gf_dc * sqrt(phit1 * facvsb0);
                vts        = VFB_i + P_D * facvsb - Vsbnud + Gf_dc * sqrt(phit1 * facvsb );
                vth        = vts - delVg;
                vgt        = vgs - vth;
                vdss       = Vdsat_dc;
                vsat       = Vds - vdss;

                temp       = Idse + Iimpacte + Igidle - Igcde - Igdove - ijun_d;
`ifdef OPderiv
                gm         =  CHNL_TYPE * ddx(temp, V(GP));
                gmb        =  CHNL_TYPE * ddx(temp, V(BP));
                gds        =  CHNL_TYPE * ddx(temp, V(DI));

                gjs        = -ddx(ijun_s, V(SI));
                gjd        = -ddx(ijun_d, V(DI));

                cdd        =  CHNL_TYPE * ddx(Qd, V(DI));
                cdg        = -CHNL_TYPE * ddx(Qd, V(GP));
                cdb        = -CHNL_TYPE * ddx(Qd, V(BP));
                cds        =  cdd - cdg - cdb;
                cgd        = -CHNL_TYPE * ddx(Qg, V(DI));
                cgg        =  CHNL_TYPE * ddx(Qg, V(GP));
                cgb        = -CHNL_TYPE * ddx(Qg, V(BP));
                cgs        =  cgg - cgd - cgb;
                csd        = -CHNL_TYPE * ddx(Qs, V(DI));
                csg        = -CHNL_TYPE * ddx(Qs, V(GP));
                csb        = -CHNL_TYPE * ddx(Qs, V(BP));
                css        =  csg + csd + csb;
                cbd        = -CHNL_TYPE * ddx(Qb, V(DI));
                cbg        = -CHNL_TYPE * ddx(Qb, V(GP));
                cbb        =  CHNL_TYPE * ddx(Qb, V(BP));
                cbs        =  cbb - cbd - cbg;
                cgsol      =  CHNL_TYPE * ddx(Qfgs, V(GP));
                cgdol      =  CHNL_TYPE * ddx(Qfgd, V(GP));

                cjsbot     = -MULT_i * CHNL_TYPE * ABSOURCE_i * ddx(qjunbot_s, V(SI));
                cjsgat     = -MULT_i * CHNL_TYPE * LGSOURCE_i * ddx(qjungat_s, V(SI));
                cjssti     = -MULT_i * CHNL_TYPE * LSSOURCE_i * ddx(qjunsti_s, V(SI));
                cjs        =  cjsbot + cjsgat + cjssti;
                cjdbot     = -MULT_i * CHNL_TYPE * ABDRAIN_i * ddx(qjunbot_d, V(DI));
                cjdgat     = -MULT_i * CHNL_TYPE * LGDRAIN_i * ddx(qjungat_d, V(DI));
                cjdsti     = -MULT_i * CHNL_TYPE * LSDRAIN_i * ddx(qjunsti_d, V(DI));
                cjd        =  cjdbot + cjdgat + cjdsti;
`endif // OPderiv
            end
            weff       = WE;
            leff       = LE;
`ifdef OPderiv
            if (abs(gds) < 1e-18) begin
                u          = 0;
                rout       = 0;
                vearly     = 0;
            end else begin
                u          = gm / gds;
                rout       = 1.0 / gds;
                vearly     = ide / gds;
            end
            if (abs(vgt) < 1e-12) begin
                beff       = 0;
            end else begin
                beff       = 2 * abs(ide) / (vgt * vgt);
            end
            if (abs(cgg + cgsol + cgdol) < 1e-30) begin
                fug        = 0.0;
            end else begin
                fug        = gm / (2 * `PI * (cgg + cgsol + cgdol));
            end
            rg         = RG_i / MULT_i;

            sfl        = Sfl;
            if (abs(gm) < 1e-18) begin
                sqrtsff    = 0;
                sqrtsfw    = 0;
            end else begin
                sqrtsff    = sqrt(MULT_i * Sfl / 1000) / gm;
                sqrtsfw    = sqid / gm;
            end
            sid        = sqid * sqid;
            sig        = MULT_i * nt * sig1k / (1 + sig1k * mig);
            cigid      = c_igid;
            if (sid == 0) begin
                fknee      = 0;
            end else begin
                fknee      = Sfl / sid;
            end
            siavl      = shot_iavl;
            if (sigVds < 0) begin
                sigs       = shot_igcsx + shot_igdov;
                sigd       = shot_igcdx + shot_igsov;
                ssi        = jnoisex_d;
                sdi        = jnoisex_s;
            end else begin
                sigs       = shot_igcsx + shot_igsov;
                sigd       = shot_igcdx + shot_igdov;
                ssi        = jnoisex_s;
                sdi        = jnoisex_d;
            end
`endif // OPderiv

            lp_vfb       = VFB_i;
            lp_stvfb     = STVFB_i;
            lp_tox       = TOX_i;
            lp_epsrox    = EPSROX_i;
            lp_neff      = NEFF_i;
            lp_facneffac = FACNEFFAC_i;
            lp_gfacnud   = GFACNUD_i;
            lp_vsbnud    = VSBNUD_i;
            lp_dvsbnud   = DVSBNUD_i;
            lp_vnsub     = VNSUB_i;
            lp_nslp      = NSLP_i;
            lp_dnsub     = DNSUB_i;
            lp_dphib     = DPHIB_i;
            lp_delvtac   = DELVTAC_i;
            lp_np        = NP_i;
            lp_ct        = CT_i;
            lp_toxov     = TOXOV_i;
            lp_toxovd    = TOXOVD_i;
            lp_nov       = NOV_i;
            lp_novd      = NOVD_i;
            lp_cf        = CF_i;
            lp_cfb       = CFB_i;
            lp_betn      = BETN_i;
            lp_stbet     = STBET_i;
            lp_mue       = MUE_i;
            lp_stmue     = STMUE_i;
            lp_themu     = THEMU_i;
            lp_stthemu   = STTHEMU_i;
            lp_cs        = CS_i;
            lp_stcs      = STCS_i;
            lp_xcor      = XCOR_i;
            lp_stxcor    = STXCOR_i;
            lp_feta      = FETA_i;
            lp_rs        = RS_i;
            lp_strs      = STRS_i;
            lp_rsb       = RSB_i;
            lp_rsg       = RSG_i;
            lp_thesat    = THESAT_i;
            lp_stthesat  = STTHESAT_i;
            lp_thesatb   = THESATB_i;
            lp_thesatg   = THESATG_i;
            lp_ax        = AX_i;
            lp_alp       = ALP_i;
            lp_alp1      = ALP1_i;
            lp_alp2      = ALP2_i;
            lp_vp        = VP_i;
            lp_a1        = A1_i;
            lp_a2        = A2_i;
            lp_sta2      = STA2_i;
            lp_a3        = A3_i;
            lp_a4        = A4_i;
            lp_gco       = GCO_i;
            lp_iginv     = IGINV_i;
            lp_igov      = IGOV_i;
            lp_igovd     = IGOVD_i;
            lp_stig      = STIG_i;
            lp_gc2       = GC2_i;
            lp_gc3       = GC3_i;
            lp_chib      = CHIB_i;
            lp_agidl     = AGIDL_i;
            lp_agidld    = AGIDLD_i;
            lp_bgidl     = BGIDL_i;
            lp_bgidld    = BGIDLD_i;
            lp_stbgidl   = STBGIDL_i;
            lp_stbgidld  = STBGIDLD_i;
            lp_cgidl     = CGIDL_i;
            lp_cgidld    = CGIDLD_i;
            lp_cox       = COX_i;
            lp_cgov      = CGOV_i;
            lp_cgovd     = CGOVD_i;
            lp_cgbov     = CGBOV_i;
            lp_cfr       = CFR_i;
            lp_cfrd      = CFRD_i;
            lp_fnt       = FNT_i;
            lp_nfa       = NFA_i;
            lp_nfb       = NFB_i;
            lp_nfc       = NFC_i;
            lp_ef        = EF_i;
            lp_rg        = RG_i;
            lp_rse       = RSE_i;
            lp_rde       = RDE_i;
            lp_rbulk     = RBULK_i;
            lp_rwell     = RWELL_i;
            lp_rjuns     = RJUNS_i;
            lp_rjund     = RJUND_i;
`ifdef NQSmodel
            lp_munqs     = MUNQS_i;
`endif // NQSmodel
        end // OPinfo
`endif // doOPinfo
    end // analogBlock
