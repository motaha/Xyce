//-----------------------------------------------------------------------------
// Copyright Notice
//
//   Copyright 2002 Sandia Corporation. Under the terms
//   of Contract DE-AC04-94AL85000 with Sandia Corporation, the U.S.
//   Government retains certain rights in this software.
//
//    Xyce(TM) Parallel Electrical Simulator
//    Copyright (C) 2002-2014 Sandia Corporation
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Filename      : $RCSfile: N_MPDE_Builder.C,v $
// Purpose       : 
// Special Notes :
// Creator       : Robert Hoekstra, 9233, Computational Sciences
// Creation Date : 03/12/04
//
// Revision Information:
// ---------------------
// Revision Number: $Revision: 1.49 $
// Revision Date  : $Date: 2014/02/24 23:49:24 $
// Current Owner  : $Author: tvrusso $
//-----------------------------------------------------------------------------

#include <Xyce_config.h>

#include <N_MPDE_Builder.h>
#include <N_MPDE_Discretization.h>
#include <N_MPDE_Manager.h>

#include <Epetra_Comm.h>
#include <Epetra_Map.h>
#include <Epetra_CrsGraph.h>

#include <N_LAS_BlockVector.h>
#include <N_LAS_BlockMatrix.h>
#include <N_LAS_BlockSystemHelpers.h>
#include <N_PDS_ParMap.h>
#include <N_PDS_Comm.h>

#include <N_ERH_ErrorMgr.h>

//-----------------------------------------------------------------------------
// Function      : N_MPDE_Builder::createVector
// Purpose       : 
// Special Notes :
// Scope         : public
// Creator       : Robert Hoekstra, 9233, Computational Sciences
// Creation Date : 03/12/04
//-----------------------------------------------------------------------------
N_LAS_Vector * N_MPDE_Builder::createVector( double initialValue ) const
{
  if (warpMPDE_)
  {
    // tscoffe/tmei 08/11/05:  Appending an extra row for omega and phi
    return dynamic_cast<N_LAS_Vector*>(
          new N_LAS_BlockVector( Size_, MPDEMap_, BaseMap_, 2 ) );
  }
  else
  {
    return dynamic_cast<N_LAS_Vector*>(
          new N_LAS_BlockVector( Size_, MPDEMap_, BaseMap_ ) );
  }
}



//-----------------------------------------------------------------------------
// Function      : N_MPDE_Builder::createStateVector
// Purpose       : 
// Special Notes :
// Scope         : public
// Creator       : Todd Coffey, 1414
// Creation Date : 01/17/07
//-----------------------------------------------------------------------------
N_LAS_Vector * N_MPDE_Builder::createStateVector( double initialValue ) const
{
  return dynamic_cast<N_LAS_Vector*>(
        new N_LAS_BlockVector( Size_, MPDEStateMap_, BaseStateMap_ ) );
}

//-----------------------------------------------------------------------------
// Function      : N_MPDE_Builder::createStoreVector
// Purpose       : 
// Special Notes :
// Scope         : public
// Creator       : Eric Keiter
// Creation Date : 
//-----------------------------------------------------------------------------
N_LAS_Vector * N_MPDE_Builder::createStoreVector( double initialValue ) const
{
  return dynamic_cast<N_LAS_Vector*>(
        new N_LAS_BlockVector( Size_, MPDEStoreMap_, BaseStoreMap_ ) );
}

//-----------------------------------------------------------------------------
// Function      : N_MPDE_Builder::createDAEdQdxMatrix
// Purpose       : 
// Special Notes :
// Scope         : public
// Creator       : Robert Hoekstra, 9233, Computational Sciences
// Creation Date : 03/12/04
//-----------------------------------------------------------------------------
N_LAS_Matrix * N_MPDE_Builder::createDAEdQdxMatrix( double initialValue ) const
{
  return createDAEdFdxMatrix( initialValue );
}

//-----------------------------------------------------------------------------
// Function      : N_MPDE_Builder::createDAEdFdxMatrix
// Purpose       : 
// Special Notes :
// Scope         : public
// Creator       : Robert Hoekstra, 9233, Computational Sciences
// Creation Date : 03/12/04
//-----------------------------------------------------------------------------
N_LAS_Matrix * N_MPDE_Builder::createDAEdFdxMatrix( double initialValue ) const
{
  std::vector< std::vector<int> > Cols(Size_);
  int Start = Disc_->Start();
  int Width = Disc_->Width();

  for( int i = 0; i < Size_; ++i )
  {
    Cols[i].resize(Width);
    for( int j = 0; j < Width; ++j )
    {
      int Loc = i+(j+Start);
      if( Loc < 0 )           Loc += Size_;
      else if( Loc >= Size_ ) Loc -= Size_;
      Cols[i][j] = Loc;
    }
    sort(Cols[i].begin(),Cols[i].end());
  }

  if (warpMPDE_)
  {
    // tscoffe/tmei 08/11/05:  Appending an extra row & column for omega and phi
    return dynamic_cast<N_LAS_Matrix*>(
          new N_LAS_BlockMatrix( Size_,
                                 offset_, 
                                 Cols,
                                 *MPDEdFdxGraph_,
                                 *BasedFdxGraph_,
                                 2) );
  }
  else
  {
    return dynamic_cast<N_LAS_Matrix*>(
          new N_LAS_BlockMatrix( Size_,
                                 offset_,
                                 Cols,
                                 *MPDEdFdxGraph_,
                                 *BasedFdxGraph_ ) );
  }
}

//-----------------------------------------------------------------------------
// Function      : N_MPDE_Builder::createDAEFullMatrix
// Purpose       : 
// Special Notes :
// Scope         : public
// Creator       : Robert Hoekstra, 9233, Computational Sciences
// Creation Date : 03/12/04
//-----------------------------------------------------------------------------
N_LAS_Matrix * N_MPDE_Builder::createDAEFullMatrix( double initialValue ) const
{
  return createDAEdFdxMatrix( initialValue );
}

//-----------------------------------------------------------------------------
// Function      : N_MPDE_Builder::generateMaps
// Purpose       : 
// Special Notes :
// Scope         : public
// Creator       : Robert Hoekstra, 9233, Computational Sciences
// Creation Date : 03/12/04
//-----------------------------------------------------------------------------
bool N_MPDE_Builder::generateMaps( const RCP<N_PDS_ParMap>& BaseMap )
{
  //Save copy of base map
  BaseMap_ = BaseMap;
  
  //determine block offset
  offset_ = generateOffset( *BaseMap );

  std::vector<int> augGIDs(2);
  if (warpMPDE_)
  {
    // tscoffe/tmei 08/02/05:  Added two to size of map for omega and phi
    MPDEMap_ = createBlockParMap( Size_, *BaseMap, 2, &augGIDs );
    omegaGID_ = augGIDs[0];
    phiGID_ = augGIDs[1];
    
    // Figure out which processor owns the augmented rows.
    int omegaLID = MPDEMap_->globalToLocalIndex( omegaGID_ );
    int augProc = -1;
    if (omegaLID >= 0)
      augProc = BaseMap->pdsComm()->procID();
    BaseMap->pdsComm()->maxAll( &augProc, &augProcID_, 1 );
  }
  else
  {
    MPDEMap_ = createBlockParMap( Size_, *BaseMap );
  }

  return true;
}

//-----------------------------------------------------------------------------
// Function      : N_MPDE_Builder::generateStateMaps
// Purpose       : 
// Special Notes :
// Scope         : public
// Creator       : Todd Coffey, 1414
// Creation Date : 01/17/07
//-----------------------------------------------------------------------------
bool N_MPDE_Builder::generateStateMaps( const RCP<N_PDS_ParMap>& BaseStateMap )
{
  //Save copy of base map
  BaseStateMap_ = BaseStateMap;

  //determine block offset
  stateOffset_= generateOffset( *BaseStateMap );

  //Setup Block Maps for state
  MPDEStateMap_ = createBlockParMap( Size_, *BaseStateMap );

  return true;
}

//-----------------------------------------------------------------------------
// Function      : N_MPDE_Builder::generateStoreMaps
// Purpose       : 
// Special Notes :
// Scope         : public
// Creator       : Eric Keiter
// Creation Date : 
//-----------------------------------------------------------------------------
bool N_MPDE_Builder::generateStoreMaps( const RCP<N_PDS_ParMap>& BaseStoreMap )
{
  //Save copy of base map
  BaseStoreMap_ = BaseStoreMap;

  //determine block offset
  storeOffset_= generateOffset( *BaseStoreMap );

  //Setup Block Maps for store
  MPDEStoreMap_ = createBlockParMap( Size_, *BaseStoreMap );

  return true;
}

//-----------------------------------------------------------------------------
// Function      : N_MPDE_Builder::generateGraphs
// Purpose       : 
// Special Notes :
// Scope         : public
// Creator       : Robert Hoekstra, 9233, Computational Sciences
// Creation Date : 03/12/04
//-----------------------------------------------------------------------------
bool N_MPDE_Builder::generateGraphs( const Epetra_CrsGraph & BasedQdxGraph,
                                     const Epetra_CrsGraph & BasedFdxGraph,
                                     const Epetra_CrsGraph & BaseFullGraph )
{
  if( Teuchos::is_null(BaseMap_) )
    Xyce::Report::DevelFatal0().in("N_MPDE_Builder::generateGraphs")
      << "Need to setup Maps first";

  //Copies of base graphs
  BasedQdxGraph_ = rcp(new Epetra_CrsGraph( BasedQdxGraph ));
  BasedFdxGraph_ = rcp(new Epetra_CrsGraph( BasedFdxGraph ));
  BaseFullGraph_ = rcp(new Epetra_CrsGraph( BaseFullGraph ));

  int BlockSize = BaseMap_->numLocalEntities();

  //Construct MPDE dFdX Graph
  MPDEdFdxGraph_ = rcp(new Epetra_CrsGraph( Copy,
                                            *(MPDEMap_->petraBlockMap()),
                                            0 ));
  
  int MaxIndices = BasedFdxGraph_->MaxNumIndices();
  std::vector<int> Indices(MaxIndices);
  int NumIndices;
  int BaseRow;
  int MPDERow;
  for( int i = 0; i < Size_; ++i )
  {
    for( int j = 0; j < BlockSize; ++j )
    {
      BaseRow = BaseMap_->localToGlobalIndex(j);
      BasedFdxGraph.ExtractGlobalRowCopy( BaseRow, MaxIndices, NumIndices, &Indices[0] );
      for( int k = 0; k < NumIndices; ++k ) Indices[k] += offset_*i;
      //Diagonal Block
      MPDERow = BaseRow + offset_*i;
      MPDEdFdxGraph_->InsertGlobalIndices( MPDERow, NumIndices, &Indices[0] );
    }
  }

#ifdef Xyce_DEBUG_MPDE
  if (mpdeMgr_->debugLevel > 0)
  {
    Xyce::dout() << "Q and F graphs before adding warped terms:" << std::endl;
    Xyce::dout() << "MPDEdFdxGraph = [same as MPDEQddxGraph]" << std::endl;
    Xyce::dout() << "MPDEdFdxGraph = " << std::endl;
    MPDEdFdxGraph_->Print(std::cout);
  }
#endif // Xyce_DEBUG_MPDE

  MaxIndices = BasedFdxGraph_->MaxNumIndices();
  Indices.resize(MaxIndices);
  std::vector<int> NewIndices(MaxIndices);
  int DiscStart = Disc_->Start();
  int DiscWidth = Disc_->Width();
  std::vector<int> Cols(DiscWidth);
  for( int i = 0; i < Size_; ++i )
  {
    for( int j = 0; j < DiscWidth; ++j )
    {
      Cols[j] = i + (j+DiscStart);
      if( Cols[j] < 0 ) Cols[j] += Size_;
      else if( Cols[j] > (Size_-1) ) Cols[j] -= Size_;
    }

    for( int j = 0; j < BlockSize; ++j )
    {
      BaseRow = BaseMap_->localToGlobalIndex(j);
      BasedFdxGraph.ExtractGlobalRowCopy( BaseRow, MaxIndices, NumIndices, &Indices[0] );

      MPDERow = BaseRow + offset_*i;
      for( int k = 0; k < DiscWidth; ++k )
      {
        int Shift = Cols[k]*offset_;
        for( int kk = 0; kk < NumIndices; ++kk ) NewIndices[kk] = Indices[kk] + Shift;
        MPDEdFdxGraph_->InsertGlobalIndices( MPDERow, NumIndices, &NewIndices[0] );
      }
    }
  }
  if (warpMPDE_)
  {
    // tscoffe 01/15/07 This block adds dependence on omega in the dFdx matrix everywhere that q is nonzero.
    // dqdt1 + omega dqdt2 + f + b
    // q = dqdt1   f = omega dqdt2 + f   b = b
    for( int i = 0; i < Size_; ++i )
    {
      for( int j = 0; j < BlockSize; ++j )
      {
        BaseRow = BaseMap_->localToGlobalIndex(j);
        MPDERow = BaseRow + offset_*i;
        NumIndices = 1;
        NewIndices[0] = omegaGID_; 
        MPDEdFdxGraph_->InsertGlobalIndices( MPDERow, NumIndices, &NewIndices[0] );
      }
    }
    if ( BaseMap_->pdsComm()->procID() == augProcID_ )
    {
      NumIndices = 1;
      Indices[0] = phiGID_;
      MPDEdFdxGraph_->InsertGlobalIndices( phiGID_, NumIndices, &Indices[0] );

      Teuchos::RCP<std::vector<int> > phaseGraph = warpMPDEPhasePtr_->getPhaseGraph();
      NumIndices = phaseGraph->size();
      MPDEdFdxGraph_->InsertGlobalIndices( omegaGID_, NumIndices, &((*phaseGraph)[0]) );

      // An (omegaGID, omegaGID) entry must be inserted if not done by the phase graph.
      // This is because when the augmented column is loaded, an entry is expected for each
      // row of column omegaGID.
      bool isOmegaCol = false;
      for (int i=0; i<NumIndices; ++i)
      {
        if ((*phaseGraph)[i] == omegaGID_)
          isOmegaCol = true;
      }

      // Enter graph details for phi:  \dot{phi(t_1)} = omega(t_1)
      NumIndices = 1;
      NewIndices.clear();
      NewIndices.push_back(omegaGID_);
      MPDEdFdxGraph_->InsertGlobalIndices( phiGID_, NumIndices, &NewIndices[0] );

      // Add (omegaGID, omegaGID) entry if one doesn't already exist.
      if (!isOmegaCol) 
        MPDEdFdxGraph_->InsertGlobalIndices( omegaGID_, NumIndices, &NewIndices[0] );
    }
  }
  MPDEdFdxGraph_->FillComplete();

  //Construct MPDE dQdx Graph
  MPDEdQdxGraph_ = rcp(new Epetra_CrsGraph( *MPDEdFdxGraph_ ));
  MPDEdQdxGraph_->FillComplete();

  //Construct MPDE Full Graph
  MPDEFullGraph_ = rcp(new Epetra_CrsGraph( *MPDEdFdxGraph_ ));
  MPDEFullGraph_->FillComplete();

#ifdef Xyce_DEBUG_MPDE
  if (mpdeMgr_->debugLevel > 0)
  {  
    Xyce::dout() << "Final MPDEdQdxGraph = " << std::endl;
    MPDEdQdxGraph_->Print(std::cout);
    Xyce::dout() << "Final MPDEdFdxGraph = " << std::endl;
    MPDEdFdxGraph_->Print(std::cout);
  }
#endif // Xyce_DEBUG_MPDE

  return true;
}

//-----------------------------------------------------------------------------
// Function      : N_MPDE_Builder::getSolutionMap
// Purpose       : 
// Special Notes : This is specifically for blockAnalysis types (like MPDE & HB)
// so we can get a valid map from the builder.
// Scope         : Public
// Creator       : Todd Coffey, 1414
// Creation Date : 09/05/08
//-----------------------------------------------------------------------------
Teuchos::RCP<const Epetra_Map> N_MPDE_Builder::getSolutionMap() const
{
  return(rcp( MPDEMap_->petraMap(), false ));
}

//-----------------------------------------------------------------------------
// Function      : N_MPDE_Builder::getStateMap
// Purpose       : 
// Special Notes : This is specifically for blockAnalysis types (like MPDE & HB)
// so we can get a valid map from the builder.
// Scope         : Public
// Creator       : Todd Coffey, 1414
// Creation Date : 09/05/08
//-----------------------------------------------------------------------------
Teuchos::RCP<const Epetra_Map> N_MPDE_Builder::getStateMap() const
{
  return(rcp( MPDEStateMap_->petraMap(), false ));
}

//-----------------------------------------------------------------------------
// Function      : N_MPDE_Builder::getStoreMap
// Purpose       : 
// Special Notes : This is specifically for blockAnalysis types (like MPDE & HB)
// so we can get a valid map from the builder.
// Scope         : Public
// Creator       : Eric Keiter
// Creation Date : 
//-----------------------------------------------------------------------------
Teuchos::RCP<const Epetra_Map> N_MPDE_Builder::getStoreMap() const
{
  return(rcp( MPDEStoreMap_->petraMap(), false ));
}

