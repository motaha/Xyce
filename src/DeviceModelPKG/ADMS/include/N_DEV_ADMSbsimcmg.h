
// -*-c++-*-
//-----------------------------------------------------------------------------
// Copyright Notice
//
//   Copyright 2002 Sandia Corporation. Under the terms
//   of Contract DE-AC04-94AL85000 with Sandia Corporation, the U.S.
//   Government retains certain rights in this software.
//
//    Xyce(TM) Parallel Electrical Simulator
//    Copyright (C) 2002-2014 Sandia Corporation
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Filename       : $RCSfile: N_DEV_ADMSbsimcmg.h,v $
//
// Purpose        :
//
// Special Notes  : Generated from verilog file bsimcmg.va with ADMS 
//                  interface for Xyce 6.1.0
//                  DO NOT EDIT THIS FILE DIRECTLY!  It may be overwritten!
//
// Creator        : admsXml-2.3.0
//
// Creation Date  : Tue, 11 Mar 2014 10:54:42
//
// Revision Information:
// ---------------------
//
// Revision Number: $Revision: 1.21.2.3 $
//
// Revision Date  : $Date: 2014/03/11 17:21:52 $
//
// Current Owner  : $Author: tvrusso $
//-----------------------------------------------------------------------------
#ifndef Xyce_N_DEV_ADMSbsimcmg_h
#define Xyce_N_DEV_ADMSbsimcmg_h


#include <Sacado.hpp>

#include <N_DEV_Configuration.h>
#include <N_DEV_Const.h>
#include <N_DEV_DeviceBlock.h>
#include <N_DEV_DeviceInstance.h>
#include <N_DEV_DeviceModel.h>
#include <N_DEV_MOSFET1.h>


namespace Xyce {
namespace Device {
namespace ADMSbsimcmg {

class Model;
class Instance;

struct Traits: public DeviceTraits<Model, Instance, MOSFET1::Traits>
{
  static const char *name() {return "BSIM-CMG FINFET v107.0.0";}
  static const char *deviceTypeName() {return "m level 107";}

  static const int numNodes() {return 4;}
  static const bool modelRequired() {return true;}
  static const bool isLinearDevice() {return false;}

  static Device *factory(const Configuration &configuration, const FactoryBlock &factory_block);
  static void loadModelParameters(ParametricData<Model> &model_parameters);
  static void loadInstanceParameters(ParametricData<Instance> &instance_parameters);
};

//-----------------------------------------------------------------------------
// Class         : Instance

//
// Purpose       : This class represents a single instance  of the
//                 device.  It mainly contains indices and pointers into
//                 the matrix equation (see the resistor instance class for
//                 more details).
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class Instance : public DeviceInstance
{
  friend class ParametricData<Instance>;
  friend class Model;
  friend class Traits;

  // This typedef is for our automatic differentiation:
  typedef Sacado::Fad::SFad<double,14> AdmsFadType;

public:
  Instance(
     const Configuration &       configuration,
     const InstanceBlock &       instance_block,
     Model &                     model,
     const FactoryBlock &        factory_block);

  ~Instance();

private:
  Instance(const Instance &);
  Instance &operator=(const Instance &);

public:
  void registerLIDs( const std::vector<int> & intLIDVecRef,
                     const std::vector<int> & extLIDVecRef );
  void registerStateLIDs( const std::vector<int> & staLIDVecRef );
  void setupPointers();

  std::map<int,std::string> & getIntNameMap ();

  const std::vector< std::vector<int> > & jacobianStamp() const;
  void registerJacLIDs( const std::vector< std::vector<int> > & jacLIDVec );

  bool processParams();
  bool updateTemperature ( const double & temp = -999.0 );
  bool updateIntermediateVars ();
  bool updatePrimaryState ();
  bool updateSecondaryState ();

  // load functions, residual:
  bool loadDAEQVector ();
  bool loadDAEFVector ();

  // load functions, Jacobian:
  bool loadDAEdQdx ();
  bool loadDAEdFdx ();


private:
  // Limited exponential --- NOT what verilog LRM says, but what qucs,
  // ng-spice, and zspice do.

  template <typename T>
  T limexp(T &x)
  {
    if ((x) < 80.0)
      return (exp(x));
    else
      return (exp(80.0)*(x-79.0));
  }


public:
  // iterator reference to the bsimcmg model which owns this instance.
  // Getters and setters
  Model &getModel()
  {
    return model_;
  }

private:

  Model & model_;   //< Owning Model
  // Begin verilog Instance Variables
  //   Instance Parameters
  double L;
  double D;
  double TFIN;
  double FPITCH;
  double NFIN;
  int NGCON;
  double ASEO;
  double ADEO;
  double PSEO;
  double PDEO;
  double ASEJ;
  double ADEJ;
  double PSEJ;
  double PDEJ;
  double COVS;
  double COVD;
  double CGSP;
  double CGDP;
  double CDSP;
  double NRS;
  double NRD;
  double LRSD;
  //  Variables of global_instance scope
  // end verilog Instance Variables=====
  // Nodal LID Variables
  int li_d;
  int li_g;
  int li_s;
  int li_e;
  int li_di;
  int li_si;
  // end Nodal LID Variables
  // Branch LID Variables
  // end Branch LID Variables
  // Jacobian  pointers
  double * f_di_Equ_g_Node_Ptr;
  double * f_di_Equ_di_Node_Ptr;
  double * f_si_Equ_g_Node_Ptr;
  double * f_si_Equ_di_Node_Ptr;
  double * f_di_Equ_si_Node_Ptr;
  double * f_si_Equ_si_Node_Ptr;
  double * f_di_Equ_e_Node_Ptr;
  double * f_si_Equ_e_Node_Ptr;
  double * f_g_Equ_g_Node_Ptr;
  double * f_g_Equ_di_Node_Ptr;
  double * f_g_Equ_si_Node_Ptr;
  double * f_g_Equ_e_Node_Ptr;
  double * f_g_Equ_s_Node_Ptr;
  double * f_si_Equ_s_Node_Ptr;
  double * f_g_Equ_d_Node_Ptr;
  double * f_si_Equ_d_Node_Ptr;
  double * f_di_Equ_s_Node_Ptr;
  double * f_di_Equ_d_Node_Ptr;
  double * f_e_Equ_g_Node_Ptr;
  double * f_e_Equ_e_Node_Ptr;
  double * f_e_Equ_di_Node_Ptr;
  double * f_e_Equ_si_Node_Ptr;
  double * f_e_Equ_s_Node_Ptr;
  double * f_e_Equ_d_Node_Ptr;
  double * f_d_Equ_d_Node_Ptr;
  double * f_d_Equ_s_Node_Ptr;
  double * f_s_Equ_d_Node_Ptr;
  double * f_s_Equ_s_Node_Ptr;
  double * f_s_Equ_di_Node_Ptr;
  double * f_s_Equ_si_Node_Ptr;
  double * f_s_Equ_g_Node_Ptr;
  double * f_s_Equ_e_Node_Ptr;
  double * f_d_Equ_di_Node_Ptr;
  double * f_d_Equ_si_Node_Ptr;
  double * f_d_Equ_g_Node_Ptr;
  double * f_d_Equ_e_Node_Ptr;
  double * q_di_Equ_g_Node_Ptr;
  double * q_di_Equ_di_Node_Ptr;
  double * q_si_Equ_g_Node_Ptr;
  double * q_si_Equ_di_Node_Ptr;
  double * q_di_Equ_si_Node_Ptr;
  double * q_si_Equ_si_Node_Ptr;
  double * q_di_Equ_e_Node_Ptr;
  double * q_si_Equ_e_Node_Ptr;
  double * q_g_Equ_g_Node_Ptr;
  double * q_g_Equ_di_Node_Ptr;
  double * q_g_Equ_si_Node_Ptr;
  double * q_g_Equ_e_Node_Ptr;
  double * q_g_Equ_s_Node_Ptr;
  double * q_si_Equ_s_Node_Ptr;
  double * q_g_Equ_d_Node_Ptr;
  double * q_si_Equ_d_Node_Ptr;
  double * q_di_Equ_s_Node_Ptr;
  double * q_di_Equ_d_Node_Ptr;
  double * q_e_Equ_g_Node_Ptr;
  double * q_e_Equ_e_Node_Ptr;
  double * q_e_Equ_di_Node_Ptr;
  double * q_e_Equ_si_Node_Ptr;
  double * q_e_Equ_s_Node_Ptr;
  double * q_e_Equ_d_Node_Ptr;
  double * q_d_Equ_d_Node_Ptr;
  double * q_d_Equ_s_Node_Ptr;
  double * q_s_Equ_d_Node_Ptr;
  double * q_s_Equ_s_Node_Ptr;
  double * q_s_Equ_di_Node_Ptr;
  double * q_s_Equ_si_Node_Ptr;
  double * q_s_Equ_g_Node_Ptr;
  double * q_s_Equ_e_Node_Ptr;
  double * q_d_Equ_di_Node_Ptr;
  double * q_d_Equ_si_Node_Ptr;
  double * q_d_Equ_g_Node_Ptr;
  double * q_d_Equ_e_Node_Ptr;
  // end of Jacobian and pointers
  // node numbers
  static const int admsNodeID_d = 0;
  static const int admsNodeID_g = 1;
  static const int admsNodeID_s = 2;
  static const int admsNodeID_e = 3;
  static const int admsNodeID_di = 4;
  static const int admsNodeID_si = 5;
  // end node numbers
  // Additional IDs for branch equations
  // end branch numbers
  // Probe numbers
  static const int admsProbeID_V_s_si = 0;
  static const int admsProbeID_V_d_di = 1;
  static const int admsProbeID_V_e_g = 2;
  static const int admsProbeID_V_d_s = 3;
  static const int admsProbeID_V_g_d = 4;
  static const int admsProbeID_V_g_s = 5;
  static const int admsProbeID_V_di_d = 6;
  static const int admsProbeID_V_si_s = 7;
  static const int admsProbeID_V_g_e = 8;
  static const int admsProbeID_V_e_di = 9;
  static const int admsProbeID_V_e_si = 10;
  static const int admsProbeID_V_g_di = 11;
  static const int admsProbeID_V_di_si = 12;
  static const int admsProbeID_V_g_si = 13;
  // end probe numbers
  // State LIDs
  // end state LIDs
  // Arrays to hold probes
  std::vector < AdmsFadType > probeVars;
  // Arrays to hold contributions
  // dynamic contributions are differentiated w.r.t time
  std::vector < AdmsFadType > staticContributions;
  std::vector < AdmsFadType > dynamicContributions;


  // this is what we'll use when any model uses $temperature.  We'll
  // set it in updateTemperature, and initialize it to whatever
  // is in devOptions when the instance is constructed.
  double admsTemperature;

  // vt at $temperature;
  double adms_vt_nom;


  // This one is for the annoying bogus "XyceADMSInstTemp" parameter
  // that we need so we can set it from the device manager when there's no
  // "TEMP" parameter to use
  double admsInstTemp;

  // thermal voltage at kelvin temperature temp)
  inline double adms_vt(double temp) {return(CONSTKoverQ*temp);};

  static std::vector< std::vector<int> > jacStamp;
  static std::vector<int> jacMap;
  static std::vector< std::vector<int> > jacMap2;
};


// Class AnalogFunctions

class AnalogFunctions
{
public:

  // Analog Function lexp
  template<typename ScalarT> ScalarT lexp(ScalarT x)
  {


    ScalarT lexp;
    {
      if ((x>80.0))
      {
        lexp = (5.540622384e+34*((1.0+x)-80.0));
      }
      else
      {
        if ((x<(-80.0)))
        {
          lexp = 1.804851387e-35;
        }
        else
        {
          lexp = exp(x);
        }
      }
    }
    return(lexp);
  }


  // Analog Function lln
  template<typename ScalarT> ScalarT lln(ScalarT x)
  {


    ScalarT lln;
    {
      lln = log(std::max(x,1.0e-38));
    }
    return(lln);
  }


  // Analog Function hypsmooth
  template<typename ScalarT> ScalarT hypsmooth(ScalarT x, ScalarT c)
  {


    ScalarT hypsmooth;
    {
      hypsmooth = (0.5*(x+sqrt(((x*x)+((4*c)*c)))));
    }
    return(hypsmooth);
  }


  // Analog Function hypmax
  template<typename ScalarT> ScalarT hypmax(ScalarT x, ScalarT xmin, ScalarT c)
  {


    ScalarT hypmax;
    {
      hypmax = (xmin+(0.5*(((x-xmin)-c)+sqrt(((((x-xmin)-c)*((x-xmin)-c))-((4*xmin)*c))))));
    }
    return(hypmax);
  }

};


//-----------------------------------------------------------------------------
// Class         : Model

// Purpose       :
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class Model : public DeviceModel
{
  typedef std::vector<Instance *> InstanceVector;

  friend class ParametricData<Model>;
  friend class Instance;
  friend class Traits;

  typedef Sacado::Fad::SFad<double,14> AdmsFadType;

public:
  Model(
     const Configuration &       configuration,
     const ModelBlock &          model_block,
     const FactoryBlock &        factory_block);

  ~Model();

private:
  Model(const Model &);
  Model &operator=(const Model &);

public:
  virtual void forEachInstance(DeviceInstanceOp &op) const /* override */;
  virtual std::ostream &printOutInstances(std::ostream &os) const;
  bool processParams();
  bool processInstanceParams();

private:
  AnalogFunctions analogFunctions;

public:
  void addInstance(Instance *instance)
  {
    instanceContainer.push_back(instance);
  }

  InstanceVector &getInstanceVector()
  {
    return instanceContainer;
  }

  const InstanceVector &getInstanceVector() const
  {
    return instanceContainer;
  }

private:
  std::vector<Instance*> instanceContainer;

private:

  // This one is for the annoying bogus "XyceADMSInstTemp" parameter
  // that we need so we can set it from the device manager when there's no
  // "TEMP" model parameter to use
  double admsModTemp;
  // Begin verilog Model Variables
  //   Model Parameters
  double L;
  double D;
  double TFIN;
  double FPITCH;
  int NF;
  double NFIN;
  int NGCON;
  double ASEO;
  double ADEO;
  double PSEO;
  double PDEO;
  double ASEJ;
  double ADEJ;
  double PSEJ;
  double PDEJ;
  double COVS;
  double COVD;
  double CGSP;
  double CGDP;
  double CDSP;
  double NRS;
  double NRD;
  double LRSD;
  double XL;
  double DTEMP;
  double DELVTRAND;
  double U0MULT;
  double IDS0MULT;
  int DEVTYPE;
  int BULKMOD;
  int COREMOD;
  int GEOMOD;
  int CGEO1SW;
  int RDSMOD;
  int ASYMMOD;
  int IGCMOD;
  int IGBMOD;
  int GIDLMOD;
  int IIMOD;
  int NQSMOD;
  int SHMOD;
  int RGATEMOD;
  int RGEOMOD;
  int CGEOMOD;
  int CAPMOD;
  double LINT;
  double LL;
  double LLN;
  double DLC;
  double DLCACC;
  double DLBIN;
  double LLC;
  double EOT;
  double TOXP;
  double EOTBOX;
  double HFIN;
  double FECH;
  double DELTAW;
  double FECHCV;
  double DELTAWCV;
  double NBODY;
  double NBODYN1;
  double NBODYN2;
  double NSD;
  double PHIG;
  double PHIGL;
  double PHIGN1;
  double PHIGN2;
  double EPSROX;
  double EPSRSUB;
  double EASUB;
  double NI0SUB;
  double BG0SUB;
  double NC0SUB;
  double NGATE;
  double Imin;
  double CIT;
  double CDSC;
  double CDSCN1;
  double CDSCN2;
  double CDSCD;
  double CDSCDN1;
  double CDSCDN2;
  double CDSCDR;
  double CDSCDRN1;
  double CDSCDRN2;
  double DVT0;
  double DVT1;
  double DVT1SS;
  double PHIN;
  double ETA0;
  double ETA0N1;
  double ETA0N2;
  double TETA0;
  double ETA0R;
  double TETA0R;
  double DSUB;
  double DVTP0;
  double DVTP1;
  double K1RSCE;
  double LPE0;
  double DVTSHIFT;
  double K0;
  double K01;
  double K0SI;
  double K0SI1;
  double K1SI;
  double K1SI1;
  double PHIBE;
  double K1;
  double K11;
  double K1SAT;
  double K1SAT1;
  double QMFACTOR;
  double QMTCENIV;
  double QMTCENCV;
  double QMTCENCVA;
  double AQMTCEN;
  double BQMTCEN;
  double ETAQM;
  double QM0;
  double PQM;
  double QM0ACC;
  double PQMACC;
  double VSAT;
  double VSATN1;
  double VSATN2;
  double AVSAT;
  double BVSAT;
  double VSAT1;
  double VSAT1N1;
  double VSAT1N2;
  double VSAT1R;
  double VSAT1RN1;
  double VSAT1RN2;
  double AVSAT1;
  double BVSAT1;
  double DELTAVSAT;
  double PSAT;
  double APSAT;
  double BPSAT;
  double KSATIV;
  double VSATCV;
  double AVSATCV;
  double BVSATCV;
  double DELTAVSATCV;
  double PSATCV;
  double APSATCV;
  double BPSATCV;
  double MEXP;
  double AMEXP;
  double BMEXP;
  double MEXPR;
  double AMEXPR;
  double BMEXPR;
  double PTWG;
  double PTWGR;
  double APTWG;
  double BPTWG;
  double AT;
  double TMEXP;
  double TMEXPR;
  double PTWGT;
  double U0;
  double U0N1;
  double U0N2;
  double ETAMOB;
  double UP;
  double LPA;
  double UA;
  double AUA;
  double BUA;
  double UC;
  double EU;
  double AEU;
  double BEU;
  double UD;
  double AUD;
  double BUD;
  double UCS;
  double UTE;
  double UTL;
  double EMOBT;
  double UA1;
  double UC1;
  double UD1;
  double UCSTE;
  double CHARGEWF;
  double RDSWMIN;
  double RDSW;
  double ARDSW;
  double BRDSW;
  double RSWMIN;
  double RSW;
  double ARSW;
  double BRSW;
  double RDWMIN;
  double RDW;
  double ARDW;
  double BRDW;
  double RSDR;
  double RSDRR;
  double RDDR;
  double RDDRR;
  double PRSDR;
  double PRDDR;
  double PRWGS;
  double PRWGD;
  double WR;
  double PRT;
  double TRSDR;
  double TRDDR;
  double PDIBL1;
  double PDIBL1R;
  double PDIBL2;
  double DROUT;
  double PVAG;
  double PCLM;
  double APCLM;
  double BPCLM;
  double PCLMG;
  double PCLMCV;
  double A1;
  double A11;
  double A2;
  double A21;
  double RGEXT;
  double RGFIN;
  double RSHS;
  double RSHD;
  double HEPI;
  double TSILI;
  double RHOC;
  double RHORSD;
  double CRATIO;
  double DELTAPRSD;
  int SDTERM;
  double LSP;
  double EPSRSP;
  double TGATE;
  double TMASK;
  double ASILIEND;
  double ARSDEND;
  double PRSDEND;
  double NSDE;
  double RGEOA;
  double RGEOB;
  double RGEOC;
  double RGEOD;
  double RGEOE;
  double CGEOA;
  double CGEOB;
  double CGEOC;
  double CGEOD;
  double CGEOE;
  double AIGBINV;
  double AIGBINV1;
  double BIGBINV;
  double CIGBINV;
  double EIGBINV;
  double NIGBINV;
  double AIGBACC;
  double AIGBACC1;
  double BIGBACC;
  double CIGBACC;
  double NIGBACC;
  double AIGC;
  double AIGC1;
  double BIGC;
  double CIGC;
  double PIGCD;
  double DLCIGS;
  double AIGS;
  double AIGS1;
  double BIGS;
  double CIGS;
  double DLCIGD;
  double AIGD;
  double AIGD1;
  double BIGD;
  double CIGD;
  double TOXREF;
  double TOXG;
  double NTOX;
  double POXEDGE;
  double AGISL;
  double BGISL;
  double CGISL;
  double EGISL;
  double PGISL;
  double AGIDL;
  double BGIDL;
  double CGIDL;
  double EGIDL;
  double PGIDL;
  double ALPHA0;
  double ALPHA01;
  double ALPHA1;
  double ALPHA11;
  double BETA0;
  double ALPHAII0;
  double ALPHAII01;
  double ALPHAII1;
  double ALPHAII11;
  double BETAII0;
  double BETAII1;
  double BETAII2;
  double ESATII;
  double LII;
  double SII0;
  double SII1;
  double SII2;
  double SIID;
  double EOTACC;
  double DELVFBACC;
  double CFS;
  double CFD;
  double CGSO;
  double CGDO;
  double CGSL;
  double CGDL;
  double CKAPPAS;
  double CKAPPAD;
  double CGBO;
  double CGBN;
  double CGBL;
  double CKAPPAB;
  double CSDESW;
  double CJS;
  double CJD;
  double CJSWS;
  double CJSWD;
  double CJSWGS;
  double CJSWGD;
  double PBS;
  double PBD;
  double PBSWS;
  double PBSWD;
  double PBSWGS;
  double PBSWGD;
  double MJS;
  double MJD;
  double MJSWS;
  double MJSWD;
  double MJSWGS;
  double MJSWGD;
  double SJS;
  double SJD;
  double SJSWS;
  double SJSWD;
  double SJSWGS;
  double SJSWGD;
  double MJS2;
  double MJD2;
  double MJSWS2;
  double MJSWD2;
  double MJSWGS2;
  double MJSWGD2;
  double JSS;
  double JSD;
  double JSWS;
  double JSWD;
  double JSWGS;
  double JSWGD;
  double NJS;
  double NJD;
  double IJTHSFWD;
  double IJTHDFWD;
  double IJTHSREV;
  double IJTHDREV;
  double BVS;
  double BVD;
  double XJBVS;
  double XJBVD;
  double JTSS;
  double JTSD;
  double JTSSWS;
  double JTSSWD;
  double JTSSWGS;
  double JTSSWGD;
  double JTWEFF;
  double NJTS;
  double NJTSD;
  double NJTSSW;
  double NJTSSWD;
  double NJTSSWG;
  double NJTSSWGD;
  double VTSS;
  double VTSD;
  double VTSSWS;
  double VTSSWD;
  double VTSSWGS;
  double VTSSWGD;
  double LINTIGEN;
  double NTGEN;
  double AIGEN;
  double BIGEN;
  double XRCRG1;
  double XRCRG2;
  int NSEG;
  double EF;
  double EM;
  double NOIA;
  double NOIB;
  double NOIC;
  double NTNOI;
  double TNOM;
  double TBGASUB;
  double TBGBSUB;
  double KT1;
  double KT1L;
  double TSS;
  double IIT;
  double TII;
  double TGIDL;
  double IGT;
  double TCJ;
  double TCJSW;
  double TCJSWG;
  double TPB;
  double TPBSW;
  double TPBSWG;
  double XTIS;
  double XTID;
  double XTSS;
  double XTSD;
  double XTSSWS;
  double XTSSWD;
  double XTSSWGS;
  double XTSSWGD;
  double TNJTS;
  double TNJTSD;
  double TNJTSSW;
  double TNJTSSWD;
  double TNJTSSWG;
  double TNJTSSWGD;
  double RTH0;
  double CTH0;
  double WTH0;
  double LNBODY;
  double NNBODY;
  double PNBODY;
  double LPHIG;
  double NPHIG;
  double PPHIG;
  double LNGATE;
  double NNGATE;
  double PNGATE;
  double LCIT;
  double NCIT;
  double PCIT;
  double LCDSC;
  double NCDSC;
  double PCDSC;
  double LCDSCD;
  double NCDSCD;
  double PCDSCD;
  double LCDSCDR;
  double NCDSCDR;
  double PCDSCDR;
  double LDVT0;
  double NDVT0;
  double PDVT0;
  double LDVT1;
  double NDVT1;
  double PDVT1;
  double LDVT1SS;
  double NDVT1SS;
  double PDVT1SS;
  double LPHIN;
  double NPHIN;
  double PPHIN;
  double LETA0;
  double NETA0;
  double PETA0;
  double LETA0R;
  double NETA0R;
  double PETA0R;
  double LDSUB;
  double NDSUB;
  double PDSUB;
  double LK1RSCE;
  double NK1RSCE;
  double PK1RSCE;
  double LLPE0;
  double NLPE0;
  double PLPE0;
  double LDVTSHIFT;
  double NDVTSHIFT;
  double PDVTSHIFT;
  double LPHIBE;
  double NPHIBE;
  double PPHIBE;
  double LK0;
  double NK0;
  double PK0;
  double LK01;
  double NK01;
  double PK01;
  double LK0SI;
  double NK0SI;
  double PK0SI;
  double LK0SI1;
  double NK0SI1;
  double PK0SI1;
  double LK1SI;
  double NK1SI;
  double PK1SI;
  double LK1SI1;
  double NK1SI1;
  double PK1SI1;
  double LK1;
  double NK1;
  double PK1;
  double LK11;
  double NK11;
  double PK11;
  double LK1SAT;
  double NK1SAT;
  double PK1SAT;
  double LK1SAT1;
  double NK1SAT1;
  double PK1SAT1;
  double LDVTB;
  double NDVTB;
  double PDVTB;
  double LLPEB;
  double NLPEB;
  double PLPEB;
  double LQMFACTOR;
  double NQMFACTOR;
  double PQMFACTOR;
  double LQMTCENIV;
  double NQMTCENIV;
  double PQMTCENIV;
  double LQMTCENCV;
  double NQMTCENCV;
  double PQMTCENCV;
  double LQMTCENCVA;
  double NQMTCENCVA;
  double PQMTCENCVA;
  double LVSAT;
  double NVSAT;
  double PVSAT;
  double LVSAT1;
  double NVSAT1;
  double PVSAT1;
  double LVSAT1R;
  double NVSAT1R;
  double PVSAT1R;
  double LPSAT;
  double NPSAT;
  double PPSAT;
  double LDELTAVSAT;
  double NDELTAVSAT;
  double PDELTAVSAT;
  double LKSATIV;
  double NKSATIV;
  double PKSATIV;
  double LVSATCV;
  double NVSATCV;
  double PVSATCV;
  double LPSATCV;
  double NPSATCV;
  double PPSATCV;
  double LDELTAVSATCV;
  double NDELTAVSATCV;
  double PDELTAVSATCV;
  double LMEXP;
  double NMEXP;
  double PMEXP;
  double LMEXPR;
  double NMEXPR;
  double PMEXPR;
  double LPTWG;
  double NPTWG;
  double PPTWG;
  double LPTWGR;
  double NPTWGR;
  double PPTWGR;
  double LU0;
  double NU0;
  double PU0;
  double LETAMOB;
  double NETAMOB;
  double PETAMOB;
  double LUP;
  double NUP;
  double PUP;
  double LUA;
  double NUA;
  double PUA;
  double LUC;
  double NUC;
  double PUC;
  double LEU;
  double NEU;
  double PEU;
  double LUD;
  double NUD;
  double PUD;
  double LUCS;
  double NUCS;
  double PUCS;
  double LPCLM;
  double NPCLM;
  double PPCLM;
  double LPCLMG;
  double NPCLMG;
  double PPCLMG;
  double LPCLMCV;
  double NPCLMCV;
  double PPCLMCV;
  double LA1;
  double NA1;
  double PA1;
  double LA11;
  double NA11;
  double PA11;
  double LA2;
  double NA2;
  double PA2;
  double LA21;
  double NA21;
  double PA21;
  double LRDSW;
  double NRDSW;
  double PRDSW;
  double LRSW;
  double NRSW;
  double PRSW;
  double LRDW;
  double NRDW;
  double PRDW;
  double LPRWGS;
  double NPRWGS;
  double PPRWGS;
  double LPRWGD;
  double NPRWGD;
  double PPRWGD;
  double LWR;
  double NWR;
  double PWR;
  double LPDIBL1;
  double NPDIBL1;
  double PPDIBL1;
  double LPDIBL1R;
  double NPDIBL1R;
  double PPDIBL1R;
  double LPDIBL2;
  double NPDIBL2;
  double PPDIBL2;
  double LDROUT;
  double NDROUT;
  double PDROUT;
  double LPVAG;
  double NPVAG;
  double PPVAG;
  double LAIGBINV;
  double NAIGBINV;
  double PAIGBINV;
  double LAIGBINV1;
  double NAIGBINV1;
  double PAIGBINV1;
  double LBIGBINV;
  double NBIGBINV;
  double PBIGBINV;
  double LCIGBINV;
  double NCIGBINV;
  double PCIGBINV;
  double LEIGBINV;
  double NEIGBINV;
  double PEIGBINV;
  double LNIGBINV;
  double NNIGBINV;
  double PNIGBINV;
  double LAIGBACC;
  double NAIGBACC;
  double PAIGBACC;
  double LAIGBACC1;
  double NAIGBACC1;
  double PAIGBACC1;
  double LBIGBACC;
  double NBIGBACC;
  double PBIGBACC;
  double LCIGBACC;
  double NCIGBACC;
  double PCIGBACC;
  double LNIGBACC;
  double NNIGBACC;
  double PNIGBACC;
  double LAIGC;
  double NAIGC;
  double PAIGC;
  double LAIGC1;
  double NAIGC1;
  double PAIGC1;
  double LBIGC;
  double NBIGC;
  double PBIGC;
  double LCIGC;
  double NCIGC;
  double PCIGC;
  double LPIGCD;
  double NPIGCD;
  double PPIGCD;
  double LAIGS;
  double NAIGS;
  double PAIGS;
  double LAIGS1;
  double NAIGS1;
  double PAIGS1;
  double LBIGS;
  double NBIGS;
  double PBIGS;
  double LCIGS;
  double NCIGS;
  double PCIGS;
  double LAIGD;
  double NAIGD;
  double PAIGD;
  double LAIGD1;
  double NAIGD1;
  double PAIGD1;
  double LBIGD;
  double NBIGD;
  double PBIGD;
  double LCIGD;
  double NCIGD;
  double PCIGD;
  double LNTOX;
  double NNTOX;
  double PNTOX;
  double LPOXEDGE;
  double NPOXEDGE;
  double PPOXEDGE;
  double LAGISL;
  double NAGISL;
  double PAGISL;
  double LBGISL;
  double NBGISL;
  double PBGISL;
  double LCGISL;
  double NCGISL;
  double PCGISL;
  double LEGISL;
  double NEGISL;
  double PEGISL;
  double LPGISL;
  double NPGISL;
  double PPGISL;
  double LAGIDL;
  double NAGIDL;
  double PAGIDL;
  double LBGIDL;
  double NBGIDL;
  double PBGIDL;
  double LCGIDL;
  double NCGIDL;
  double PCGIDL;
  double LEGIDL;
  double NEGIDL;
  double PEGIDL;
  double LPGIDL;
  double NPGIDL;
  double PPGIDL;
  double LALPHA0;
  double NALPHA0;
  double PALPHA0;
  double LALPHA1;
  double NALPHA1;
  double PALPHA1;
  double LALPHAII0;
  double NALPHAII0;
  double PALPHAII0;
  double LALPHAII1;
  double NALPHAII1;
  double PALPHAII1;
  double LBETA0;
  double NBETA0;
  double PBETA0;
  double LBETAII0;
  double NBETAII0;
  double PBETAII0;
  double LBETAII1;
  double NBETAII1;
  double PBETAII1;
  double LBETAII2;
  double NBETAII2;
  double PBETAII2;
  double LESATII;
  double NESATII;
  double PESATII;
  double LLII;
  double NLII;
  double PLII;
  double LSII0;
  double NSII0;
  double PSII0;
  double LSII1;
  double NSII1;
  double PSII1;
  double LSII2;
  double NSII2;
  double PSII2;
  double LSIID;
  double NSIID;
  double PSIID;
  double LCFS;
  double NCFS;
  double PCFS;
  double LCFD;
  double NCFD;
  double PCFD;
  double LCOVS;
  double NCOVS;
  double PCOVS;
  double LCOVD;
  double NCOVD;
  double PCOVD;
  double LCGSL;
  double NCGSL;
  double PCGSL;
  double LCGDL;
  double NCGDL;
  double PCGDL;
  double LCKAPPAS;
  double NCKAPPAS;
  double PCKAPPAS;
  double LCKAPPAD;
  double NCKAPPAD;
  double PCKAPPAD;
  double LCGBL;
  double NCGBL;
  double PCGBL;
  double LCKAPPAB;
  double NCKAPPAB;
  double PCKAPPAB;
  double LNTGEN;
  double NNTGEN;
  double PNTGEN;
  double LAIGEN;
  double NAIGEN;
  double PAIGEN;
  double LBIGEN;
  double NBIGEN;
  double PBIGEN;
  double LXRCRG1;
  double NXRCRG1;
  double PXRCRG1;
  double LXRCRG2;
  double NXRCRG2;
  double PXRCRG2;
  double LINTNOI;
  double LUTE;
  double NUTE;
  double PUTE;
  double LUTL;
  double NUTL;
  double PUTL;
  double LEMOBT;
  double NEMOBT;
  double PEMOBT;
  double LUA1;
  double NUA1;
  double PUA1;
  double LUC1;
  double NUC1;
  double PUC1;
  double LUD1;
  double NUD1;
  double PUD1;
  double LUCSTE;
  double NUCSTE;
  double PUCSTE;
  double LPTWGT;
  double NPTWGT;
  double PPTWGT;
  double LAT;
  double NAT;
  double PAT;
  double LSTTHETASAT;
  double NSTTHETASAT;
  double PSTTHETASAT;
  double LPRT;
  double NPRT;
  double PPRT;
  double LKT1;
  double NKT1;
  double PKT1;
  double LTSS;
  double NTSS;
  double PTSS;
  double LIIT;
  double NIIT;
  double PIIT;
  double LTII;
  double NTII;
  double PTII;
  double LTGIDL;
  double NTGIDL;
  double PTGIDL;
  double LIGT;
  double NIGT;
  double PIGT;
  //  Variables of global_model scope
  // end verilog model variables=====
};

void registerDevice();

} // namespace ADMSbsimcmg
} // namespace Device
} // namespace Xyce
#endif //Xyce_N_DEV_ADMSbsimcmg_h
