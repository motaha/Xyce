
// -*-c++-*-
//-----------------------------------------------------------------------------
// Copyright Notice
//
//   Copyright 2002 Sandia Corporation. Under the terms
//   of Contract DE-AC04-94AL85000 with Sandia Corporation, the U.S.
//   Government retains certain rights in this software.
//
//    Xyce(TM) Parallel Electrical Simulator
//    Copyright (C) 2002-2013  Sandia Corporation
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Filename       : $RCSfile: N_DEV_ADMSvbic.h,v $
//
// Purpose        :
//
// Special Notes  : Generated from verilog file vbic_3T_et_cf_Xyce_typed.vla with ADMS 
//                  interface for Xyce 6.0.0
//                  DO NOT EDIT THIS FILE DIRECTLY!  It may be overwritten!
//
// Creator        : admsXml-2.3.0
//
// Creation Date  : Tue, 04 Jun 2013 09:58:34
//
// Revision Information:
// ---------------------
//
// Revision Number: $Revision: 1.22.2.2 $
//
// Revision Date  : $Date: 2013/10/03 17:23:34 $
//
// Current Owner  : $Author: tvrusso $
//-----------------------------------------------------------------------------
#ifndef Xyce_N_DEV_ADMSvbic_h
#define Xyce_N_DEV_ADMSvbic_h

// ----------   Xyce Includes   ----------
#include <Sacado.hpp>
#include <N_DEV_DeviceBlock.h>
#include <N_DEV_DeviceInstance.h>
#include <N_DEV_DeviceModel.h>

#include <N_DEV_Param.h>

namespace Xyce {
namespace Device {
namespace ADMSvbic {

// ---------- Forward Declarations ----------
class Model;

//-----------------------------------------------------------------------------
// Class         : Instance

//
// Purpose       : This class represents a single instance  of the
//                 device.  It mainly contains indices and pointers into
//                 the matrix equation (see the resistor instance class for
//                 more details).
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class Instance : public DeviceInstance
{
  friend class ParametricData<Instance>;
  friend class Model;

  // This typedef is for our automatic differentiation:
  typedef Sacado::Fad::SFad<double,15> AdmsFadType;

public:
  static ParametricData<Instance> &getParametricData();

  virtual const ParametricData<void> &getMyParametricData() const
  {
    return getParametricData();
  }

  Instance(InstanceBlock & IB,
           Model & Miter,
           MatrixLoadData & mlData1,
           SolverState &ss1,
           ExternData  &ed1,
           DeviceOptions & do1);

  // destructor
  ~Instance();

private:
  Instance(const Instance &);
  Instance &operator=(const Instance &);

public:
  void registerLIDs( const vector<int> & intLIDVecRef,
                     const vector<int> & extLIDVecRef );
  void registerStateLIDs( const vector<int> & staLIDVecRef );
  void setupPointers();

  map<int,string> & getIntNameMap ();

  const vector< vector<int> > & jacobianStamp() const;
  void registerJacLIDs( const vector< vector<int> > & jacLIDVec );

  bool processParams (string param = "");
  bool updateTemperature ( const double & temp = -999.0 );
  bool updateIntermediateVars ();
  bool updatePrimaryState ();
  bool updateSecondaryState ();

  // load functions, residual:
  bool loadDAEQVector ();
  bool loadDAEFVector ();

  // load functions, Jacobian:
  bool loadDAEdQdx ();
  bool loadDAEdFdx ();

  void collapseNodes();

private:
  // Limited exponential --- NOT what verilog LRM says, but what qucs,
  // ng-spice, and zspice do.

  template <typename T>
  T limexp(T &x)
  {
    if ((x) < 80.0)
      return (exp(x));
    else
      return (exp(80.0)*(x-79.0));
  }


public:
  // iterator reference to the vbic model which owns this instance.
  // Getters and setters
  Model &getModel()
  {
    return model_;
  }

private:

  Model & model_;   //< Owning Model
  // Begin verilog Instance Variables
  //   Instance Parameters
  int M;
  //  Variables of global_instance scope
  // end verilog Instance Variables=====
  // Nodal LID Variables
  int li_c;
  int li_b;
  int li_e;
  int li_dt;
  int li_cx;
  int li_ci;
  int li_bx;
  int li_bi;
  int li_ei;
  int li_bp;
  // end Nodal LID Variables
  // Branch LID Variables
  // end Branch LID Variables
  // Jacobian  pointers
  double * f_bi_Equ_bi_Node_Ptr;
  double * f_bi_Equ_ei_Node_Ptr;
  double * f_ei_Equ_bi_Node_Ptr;
  double * f_ei_Equ_ei_Node_Ptr;
  double * f_bi_Equ_dt_Node_Ptr;
  double * f_ei_Equ_dt_Node_Ptr;
  double * f_bx_Equ_bx_Node_Ptr;
  double * f_bx_Equ_ei_Node_Ptr;
  double * f_ei_Equ_bx_Node_Ptr;
  double * f_bx_Equ_dt_Node_Ptr;
  double * f_ci_Equ_bi_Node_Ptr;
  double * f_ci_Equ_ci_Node_Ptr;
  double * f_ei_Equ_ci_Node_Ptr;
  double * f_ci_Equ_ei_Node_Ptr;
  double * f_ci_Equ_dt_Node_Ptr;
  double * f_bi_Equ_ci_Node_Ptr;
  double * f_bx_Equ_bp_Node_Ptr;
  double * f_bp_Equ_bx_Node_Ptr;
  double * f_bp_Equ_bp_Node_Ptr;
  double * f_bp_Equ_dt_Node_Ptr;
  double * f_c_Equ_dt_Node_Ptr;
  double * f_cx_Equ_dt_Node_Ptr;
  double * f_c_Equ_c_Node_Ptr;
  double * f_c_Equ_cx_Node_Ptr;
  double * f_cx_Equ_c_Node_Ptr;
  double * f_cx_Equ_cx_Node_Ptr;
  double * f_cx_Equ_bi_Node_Ptr;
  double * f_ci_Equ_cx_Node_Ptr;
  double * f_cx_Equ_ci_Node_Ptr;
  double * f_b_Equ_dt_Node_Ptr;
  double * f_b_Equ_b_Node_Ptr;
  double * f_b_Equ_bx_Node_Ptr;
  double * f_bx_Equ_b_Node_Ptr;
  double * f_bx_Equ_bi_Node_Ptr;
  double * f_bx_Equ_ci_Node_Ptr;
  double * f_bi_Equ_bx_Node_Ptr;
  double * f_e_Equ_dt_Node_Ptr;
  double * f_e_Equ_e_Node_Ptr;
  double * f_e_Equ_ei_Node_Ptr;
  double * f_ei_Equ_e_Node_Ptr;
  double * f_bp_Equ_bi_Node_Ptr;
  double * f_bp_Equ_ci_Node_Ptr;
  double * f_cx_Equ_bx_Node_Ptr;
  double * f_cx_Equ_bp_Node_Ptr;
  double * f_bp_Equ_cx_Node_Ptr;
  double * f_bi_Equ_cx_Node_Ptr;
  double * f_b_Equ_e_Node_Ptr;
  double * f_e_Equ_b_Node_Ptr;
  double * f_b_Equ_c_Node_Ptr;
  double * f_c_Equ_b_Node_Ptr;
  double * f_dt_Equ_dt_Node_Ptr;
  double * f_dt_Equ_bp_Node_Ptr;
  double * f_dt_Equ_cx_Node_Ptr;
  double * f_dt_Equ_e_Node_Ptr;
  double * f_dt_Equ_ei_Node_Ptr;
  double * f_dt_Equ_bx_Node_Ptr;
  double * f_dt_Equ_bi_Node_Ptr;
  double * f_dt_Equ_b_Node_Ptr;
  double * f_dt_Equ_ci_Node_Ptr;
  double * f_dt_Equ_c_Node_Ptr;
  double * q_bi_Equ_bi_Node_Ptr;
  double * q_bi_Equ_ei_Node_Ptr;
  double * q_ei_Equ_bi_Node_Ptr;
  double * q_ei_Equ_ei_Node_Ptr;
  double * q_bi_Equ_dt_Node_Ptr;
  double * q_ei_Equ_dt_Node_Ptr;
  double * q_bx_Equ_bx_Node_Ptr;
  double * q_bx_Equ_ei_Node_Ptr;
  double * q_ei_Equ_bx_Node_Ptr;
  double * q_bx_Equ_dt_Node_Ptr;
  double * q_ci_Equ_bi_Node_Ptr;
  double * q_ci_Equ_ci_Node_Ptr;
  double * q_ei_Equ_ci_Node_Ptr;
  double * q_ci_Equ_ei_Node_Ptr;
  double * q_ci_Equ_dt_Node_Ptr;
  double * q_bi_Equ_ci_Node_Ptr;
  double * q_bx_Equ_bp_Node_Ptr;
  double * q_bp_Equ_bx_Node_Ptr;
  double * q_bp_Equ_bp_Node_Ptr;
  double * q_bp_Equ_dt_Node_Ptr;
  double * q_c_Equ_dt_Node_Ptr;
  double * q_cx_Equ_dt_Node_Ptr;
  double * q_c_Equ_c_Node_Ptr;
  double * q_c_Equ_cx_Node_Ptr;
  double * q_cx_Equ_c_Node_Ptr;
  double * q_cx_Equ_cx_Node_Ptr;
  double * q_cx_Equ_bi_Node_Ptr;
  double * q_ci_Equ_cx_Node_Ptr;
  double * q_cx_Equ_ci_Node_Ptr;
  double * q_b_Equ_dt_Node_Ptr;
  double * q_b_Equ_b_Node_Ptr;
  double * q_b_Equ_bx_Node_Ptr;
  double * q_bx_Equ_b_Node_Ptr;
  double * q_bx_Equ_bi_Node_Ptr;
  double * q_bx_Equ_ci_Node_Ptr;
  double * q_bi_Equ_bx_Node_Ptr;
  double * q_e_Equ_dt_Node_Ptr;
  double * q_e_Equ_e_Node_Ptr;
  double * q_e_Equ_ei_Node_Ptr;
  double * q_ei_Equ_e_Node_Ptr;
  double * q_bp_Equ_bi_Node_Ptr;
  double * q_bp_Equ_ci_Node_Ptr;
  double * q_cx_Equ_bx_Node_Ptr;
  double * q_cx_Equ_bp_Node_Ptr;
  double * q_bp_Equ_cx_Node_Ptr;
  double * q_bi_Equ_cx_Node_Ptr;
  double * q_b_Equ_e_Node_Ptr;
  double * q_e_Equ_b_Node_Ptr;
  double * q_b_Equ_c_Node_Ptr;
  double * q_c_Equ_b_Node_Ptr;
  double * q_dt_Equ_dt_Node_Ptr;
  double * q_dt_Equ_bp_Node_Ptr;
  double * q_dt_Equ_cx_Node_Ptr;
  double * q_dt_Equ_e_Node_Ptr;
  double * q_dt_Equ_ei_Node_Ptr;
  double * q_dt_Equ_bx_Node_Ptr;
  double * q_dt_Equ_bi_Node_Ptr;
  double * q_dt_Equ_b_Node_Ptr;
  double * q_dt_Equ_ci_Node_Ptr;
  double * q_dt_Equ_c_Node_Ptr;
  // end of Jacobian and pointers
  // node numbers
  static const int admsNodeID_c = 0;
  static const int admsNodeID_b = 1;
  static const int admsNodeID_e = 2;
  static const int admsNodeID_dt = 3;
  static const int admsNodeID_cx = 4;
  static const int admsNodeID_ci = 5;
  static const int admsNodeID_bx = 6;
  static const int admsNodeID_bi = 7;
  static const int admsNodeID_ei = 8;
  static const int admsNodeID_bp = 9;
  // end node numbers
  // Additional IDs for branch equations
  // end branch numbers
  // Probe numbers
  static const int admsProbeID_V_ci_ei = 0;
  static const int admsProbeID_V_b_c = 1;
  static const int admsProbeID_V_bp_cx = 2;
  static const int admsProbeID_V_e_ei = 3;
  static const int admsProbeID_V_b_bx = 4;
  static const int admsProbeID_V_bx_bi = 5;
  static const int admsProbeID_V_cx_ci = 6;
  static const int admsProbeID_V_c_cx = 7;
  static const int admsProbeID_V_b_e = 8;
  static const int admsProbeID_V_dt_GND = 9;
  static const int admsProbeID_V_bx_bp = 10;
  static const int admsProbeID_V_bi_cx = 11;
  static const int admsProbeID_V_bx_ei = 12;
  static const int admsProbeID_V_bi_ci = 13;
  static const int admsProbeID_V_bi_ei = 14;
  // end probe numbers
  // State LIDs
  int li_state_admsProbeID_V_bi_ei;
  int li_state_admsProbeID_V_bi_ci;
  int li_state_admsProbeID_V_bx_ei;
  int li_state_admsProbeID_V_bi_cx;
  int li_state_admsProbeID_V_bx_bp;
  int li_state_admsProbeID_V_dt_GND;
  int li_state_admsProbeID_V_b_e;
  // end state LIDs
  // bools for collapsing nodes
  bool collapseNode_cx;
  bool collapseNode_bx;
  bool collapseNode_ei;
  // Arrays to hold probes
  vector < AdmsFadType > probeVars;
  // Arrays to hold contributions
  // dynamic contributions are differentiated w.r.t time
  vector < AdmsFadType > staticContributions;
  vector < AdmsFadType > dynamicContributions;

  // This array stores the differences between original and limited variables.
  vector<double> probeDiffs;
  // These store the Jdxp's for F and Q, respectively
  vector<double> Jdxp_static;
  vector<double> Jdxp_dynamic;

  // this is what we'll use when any model uses $temperature.  We'll
  // set it in updateTemperature, and initialize it to whatever
  // is in devOptions when the instance is constructed.
  double admsTemperature;

  // vt at $temperature;
  double adms_vt_nom;


  // This one is for the annoying bogus "XyceADMSInstTemp" parameter
  // that we need so we can set it from the device manager when there's no
  // "TEMP" parameter to use
  double admsInstTemp;

  // This is used to flag whether the cx, bx, and ei nodes are exposed
  // on the instance line as external nodes.
  bool externalNodeMode;

  // thermal voltage at kelvin temperature temp)
  inline double adms_vt(double temp) {return(CONSTKoverQ*temp);};

  vector< vector<int> > jacStamp;
  vector<int> jacMap;
  vector< vector<int> > jacMap2;
};


// Class AnalogFunctions

class AnalogFunctions
{
public:

  // Analog Function limRTH
  template<typename ScalarT> ScalarT limRTH(ScalarT orig, ScalarT old)
  {


    ScalarT limRTH;
    ScalarT t0;
    ScalarT t1;
    ScalarT retval;
    {
      t0 = (orig-old);
      t1 = fabs(t0);
      retval = orig;
      if ((t1>5.0))
      {
        if ((t0>0))
        {
          retval = (old+5.0);
        }
        else
        {
          retval = (old-5.0);
        }
      }
      limRTH = retval;
    }
    return(limRTH);
  }

};


//-----------------------------------------------------------------------------
// Class         : Model

// Purpose       :
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class Model : public DeviceModel
{
  typedef std::vector<Instance *> InstanceVector;

  friend class ParametricData<Model>;
  friend class Instance;

  typedef Sacado::Fad::SFad<double,15> AdmsFadType;

public:
  static ParametricData<Model> &getParametricData();

  virtual const ParametricData<void> &getMyParametricData() const
  {
    return getParametricData();
  }

  Model(const ModelBlock &MB,
        SolverState & ss1,
        DeviceOptions & do1);
  ~Model();

private:
  Model();
  Model(const Model &);
  Model &operator=(const Model &);

public:
  virtual std::ostream &printOutInstances(std::ostream &os) const;
  bool processParams (string param = "");
  bool processInstanceParams (string param = "");

private:
  AnalogFunctions analogFunctions;

public:
  InstanceVector &getInstanceVector()
  {
    return instanceContainer;
  }

  const InstanceVector &getInstanceVector() const
  {
    return instanceContainer;
  }

private:
  vector<Instance*> instanceContainer;

private:

  // This one is for the annoying bogus "XyceADMSInstTemp" parameter
  // that we need so we can set it from the device manager when there's no
  // "TEMP" model parameter to use
  double admsModTemp;
  // Begin verilog Model Variables
  //   Model Parameters
  double TNOM;
  double RCX;
  double RCI;
  double VO;
  double GAMM;
  double HRCF;
  double RBX;
  double RBI;
  double RE;
  double RS;
  double RBP;
  double IS;
  double NF;
  double NR;
  double FC;
  double CBEO;
  double CJE;
  double PE;
  double ME;
  double AJE;
  double CBCO;
  double CJC;
  double QCO;
  double CJEP;
  double PC;
  double MC;
  double AJC;
  double CJCP;
  double PS;
  double MS;
  double AJS;
  double IBEI;
  double WBE;
  double NEI;
  double IBEN;
  double NEN;
  double IBCI;
  double NCI;
  double IBCN;
  double NCN;
  double AVC1;
  double AVC2;
  double ISP;
  double WSP;
  double NFP;
  double IBEIP;
  double IBENP;
  double IBCIP;
  double NCIP;
  double IBCNP;
  double NCNP;
  double VEF;
  double VER;
  double IKF;
  double IKR;
  double IKP;
  double TF;
  double QTF;
  double XTF;
  double VTF;
  double ITF;
  double TR;
  double TD;
  double KFN;
  double AFN;
  double BFN;
  double XRE;
  double XRBI;
  double XRCI;
  double XRS;
  double XVO;
  double EA;
  double EAIE;
  double EAIC;
  double EAIS;
  double EANE;
  double EANC;
  double EANS;
  double XIS;
  double XII;
  double XIN;
  double TNF;
  double TAVC;
  double RTH;
  double CTH;
  double VRT;
  double ART;
  double CCSO;
  double QBM;
  double NKF;
  double XIKF;
  double XRCX;
  double XRBX;
  double XRBP;
  double ISRR;
  double XISR;
  double DEAR;
  double EAP;
  double VBBE;
  double NBBE;
  double IBBE;
  double TVBBE1;
  double TVBBE2;
  double TNBBE;
  double EBBE;
  double DTEMP;
  double VERS;
  double VREV;
  int dtype;
  //  Variables of global_model scope
  // end verilog model variables=====
};

} // namespace ADMSvbic
} // namespace Device
} // namespace Xyce

typedef Xyce::Device::ADMSvbic::Instance N_DEV_ADMSvbicInstance;
typedef Xyce::Device::ADMSvbic::Model N_DEV_ADMSvbicModel;

#endif //Xyce_N_DEV_ADMSvbic_h
