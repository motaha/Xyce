
// -*-c++-*-
//-----------------------------------------------------------------------------
// Copyright Notice
//
//   Copyright 2002 Sandia Corporation. Under the terms
//   of Contract DE-AC04-94AL85000 with Sandia Corporation, the U.S.
//   Government retains certain rights in this software.
//
//    Xyce(TM) Parallel Electrical Simulator
//    Copyright (C) 2002-2013  Sandia Corporation
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Filename       : $RCSfile: N_DEV_ADMSHBT_X.h,v $
//
// Purpose        :
//
// Special Notes  : Generated from verilog file fbhhbt-2.1_nonoise_limited_inductors_typed.va with ADMS 
//                  interface for Xyce 6.0.0
//                  DO NOT EDIT THIS FILE DIRECTLY!  It may be overwritten!
//
// Creator        : admsXml-2.3.0
//
// Creation Date  : Wed, 24 Apr 2013 14:07:14
//
// Revision Information:
// ---------------------
//
// Revision Number: $Revision: 1.10.2.2 $
//
// Revision Date  : $Date: 2013/10/03 17:23:34 $
//
// Current Owner  : $Author: tvrusso $
//-----------------------------------------------------------------------------
#ifndef Xyce_N_DEV_ADMSHBT_X_h
#define Xyce_N_DEV_ADMSHBT_X_h

// ----------   Xyce Includes   ----------
#include <Sacado.hpp>
#include <N_DEV_DeviceBlock.h>
#include <N_DEV_DeviceInstance.h>
#include <N_DEV_DeviceModel.h>

#include <N_DEV_Param.h>

namespace Xyce {
namespace Device {
namespace ADMSHBT_X {

// ---------- Forward Declarations ----------
class Model;

//-----------------------------------------------------------------------------
// Class         : Instance

//
// Purpose       : This class represents a single instance  of the
//                 device.  It mainly contains indices and pointers into
//                 the matrix equation (see the resistor instance class for
//                 more details).
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class Instance : public DeviceInstance
{
  friend class ParametricData<Instance>;
  friend class Model;

  // This typedef is for our automatic differentiation:
  typedef Sacado::Fad::SFad<double,19> AdmsFadType;

public:
  static ParametricData<Instance> &getParametricData();

  virtual const ParametricData<void> &getMyParametricData() const
  {
    return getParametricData();
  }

  Instance(InstanceBlock & IB,
           Model & Miter,
           MatrixLoadData & mlData1,
           SolverState &ss1,
           ExternData  &ed1,
           DeviceOptions & do1);

  // destructor
  ~Instance();

private:
  Instance(const Instance &);
  Instance &operator=(const Instance &);

public:
  void registerLIDs( const vector<int> & intLIDVecRef,
                     const vector<int> & extLIDVecRef );
  void registerStateLIDs( const vector<int> & staLIDVecRef );
  void setupPointers();

  map<int,string> & getIntNameMap ();

  const vector< vector<int> > & jacobianStamp() const;
  void registerJacLIDs( const vector< vector<int> > & jacLIDVec );

  bool processParams (string param = "");
  bool updateTemperature ( const double & temp = -999.0 );
  bool updateIntermediateVars ();
  bool updatePrimaryState ();
  bool updateSecondaryState ();

  // load functions, residual:
  bool loadDAEQVector ();
  bool loadDAEFVector ();

  // load functions, Jacobian:
  bool loadDAEdQdx ();
  bool loadDAEdFdx ();

  // thermal voltage at kelvin temperature temp)
  template <typename T> static inline T adms_vt(T temp) {return(CONSTKoverQ*temp);};

private:
  // Limited exponential --- NOT what verilog LRM says, but what qucs,
  // ng-spice, and zspice do.

  template <typename T>
  T limexp(T &x)
  {
    if ((x) < 80.0)
      return (exp(x));
    else
      return (exp(80.0)*(x-79.0));
  }


public:
  // iterator reference to the HBT_X model which owns this instance.
  // Getters and setters
  Model &getModel()
  {
    return model_;
  }

private:

  Model & model_;   //< Owning Model
  // Begin verilog Instance Variables
  //   Instance Parameters
  double Temp;
  int N;
  double L;
  double W;
  //  Variables of global_instance scope
  // end verilog Instance Variables=====
  // Nodal LID Variables
  int li_c;
  int li_b;
  int li_e;
  int li_t;
  int li_ei;
  int li_bi;
  int li_bii;
  int li_ci;
  int li_ti;
  int li_ex;
  int li_exx;
  int li_cx;
  // end Nodal LID Variables
  // Branch LID Variables
  int li_BRA_b_bi;
  int li_BRA_e_ei;
  int li_BRA_c_ci;
  // end Branch LID Variables
  // Jacobian  pointers
  double * f_bi_Equ_ti_Node_Ptr;
  double * f_ci_Equ_ti_Node_Ptr;
  double * f_bi_Equ_bi_Node_Ptr;
  double * f_bi_Equ_ci_Node_Ptr;
  double * f_ci_Equ_bi_Node_Ptr;
  double * f_ci_Equ_ci_Node_Ptr;
  double * f_bii_Equ_ti_Node_Ptr;
  double * f_bii_Equ_bii_Node_Ptr;
  double * f_bii_Equ_ci_Node_Ptr;
  double * f_ci_Equ_bii_Node_Ptr;
  double * f_bii_Equ_ei_Node_Ptr;
  double * f_ci_Equ_ei_Node_Ptr;
  double * f_ei_Equ_bii_Node_Ptr;
  double * f_ei_Equ_ci_Node_Ptr;
  double * f_ei_Equ_ti_Node_Ptr;
  double * f_ei_Equ_ei_Node_Ptr;
  double * f_ex_Equ_ti_Node_Ptr;
  double * f_ex_Equ_ex_Node_Ptr;
  double * f_ex_Equ_ei_Node_Ptr;
  double * f_ei_Equ_ex_Node_Ptr;
  double * f_exx_Equ_ti_Node_Ptr;
  double * f_exx_Equ_exx_Node_Ptr;
  double * f_exx_Equ_ei_Node_Ptr;
  double * f_ei_Equ_exx_Node_Ptr;
  double * f_cx_Equ_ti_Node_Ptr;
  double * f_cx_Equ_cx_Node_Ptr;
  double * f_cx_Equ_ci_Node_Ptr;
  double * f_ci_Equ_cx_Node_Ptr;
  double * f_bii_Equ_bi_Node_Ptr;
  double * f_bi_Equ_bii_Node_Ptr;
  double * f_ex_Equ_bii_Node_Ptr;
  double * f_bii_Equ_ex_Node_Ptr;
  double * f_exx_Equ_bii_Node_Ptr;
  double * f_bii_Equ_exx_Node_Ptr;
  double * f_cx_Equ_bii_Node_Ptr;
  double * f_bii_Equ_cx_Node_Ptr;
  double * f_b_Equ_b_Node_Ptr;
  double * f_c_Equ_c_Node_Ptr;
  double * f_b_Equ_c_Node_Ptr;
  double * f_c_Equ_b_Node_Ptr;
  double * f_ti_Equ_bi_Node_Ptr;
  double * f_ti_Equ_ci_Node_Ptr;
  double * f_ti_Equ_ei_Node_Ptr;
  double * f_ti_Equ_bii_Node_Ptr;
  double * f_ti_Equ_ti_Node_Ptr;
  double * f_t_Equ_t_Node_Ptr;
  double * f_t_Equ_ti_Node_Ptr;
  double * f_ti_Equ_t_Node_Ptr;
  double * f_c_Equ_BRA_c_ci_Var_Ptr;
  double * f_b_Equ_BRA_b_bi_Var_Ptr;
  double * f_e_Equ_BRA_e_ei_Var_Ptr;
  double * f_ei_Equ_BRA_e_ei_Var_Ptr;
  double * f_bi_Equ_BRA_b_bi_Var_Ptr;
  double * f_ci_Equ_BRA_c_ci_Var_Ptr;
  double * f_BRA_b_bi_Equ_b_Node_Ptr;
  double * f_BRA_b_bi_Equ_bi_Node_Ptr;
  double * f_BRA_b_bi_Equ_BRA_b_bi_Var_Ptr;
  double * f_BRA_e_ei_Equ_e_Node_Ptr;
  double * f_BRA_e_ei_Equ_ei_Node_Ptr;
  double * f_BRA_e_ei_Equ_BRA_e_ei_Var_Ptr;
  double * f_BRA_c_ci_Equ_c_Node_Ptr;
  double * f_BRA_c_ci_Equ_ci_Node_Ptr;
  double * f_BRA_c_ci_Equ_BRA_c_ci_Var_Ptr;
  double * q_bi_Equ_ti_Node_Ptr;
  double * q_ci_Equ_ti_Node_Ptr;
  double * q_bi_Equ_bi_Node_Ptr;
  double * q_bi_Equ_ci_Node_Ptr;
  double * q_ci_Equ_bi_Node_Ptr;
  double * q_ci_Equ_ci_Node_Ptr;
  double * q_bii_Equ_ti_Node_Ptr;
  double * q_bii_Equ_bii_Node_Ptr;
  double * q_bii_Equ_ci_Node_Ptr;
  double * q_ci_Equ_bii_Node_Ptr;
  double * q_bii_Equ_ei_Node_Ptr;
  double * q_ci_Equ_ei_Node_Ptr;
  double * q_ei_Equ_bii_Node_Ptr;
  double * q_ei_Equ_ci_Node_Ptr;
  double * q_ei_Equ_ti_Node_Ptr;
  double * q_ei_Equ_ei_Node_Ptr;
  double * q_ex_Equ_ti_Node_Ptr;
  double * q_ex_Equ_ex_Node_Ptr;
  double * q_ex_Equ_ei_Node_Ptr;
  double * q_ei_Equ_ex_Node_Ptr;
  double * q_exx_Equ_ti_Node_Ptr;
  double * q_exx_Equ_exx_Node_Ptr;
  double * q_exx_Equ_ei_Node_Ptr;
  double * q_ei_Equ_exx_Node_Ptr;
  double * q_cx_Equ_ti_Node_Ptr;
  double * q_cx_Equ_cx_Node_Ptr;
  double * q_cx_Equ_ci_Node_Ptr;
  double * q_ci_Equ_cx_Node_Ptr;
  double * q_bii_Equ_bi_Node_Ptr;
  double * q_bi_Equ_bii_Node_Ptr;
  double * q_ex_Equ_bii_Node_Ptr;
  double * q_bii_Equ_ex_Node_Ptr;
  double * q_exx_Equ_bii_Node_Ptr;
  double * q_bii_Equ_exx_Node_Ptr;
  double * q_cx_Equ_bii_Node_Ptr;
  double * q_bii_Equ_cx_Node_Ptr;
  double * q_b_Equ_b_Node_Ptr;
  double * q_c_Equ_c_Node_Ptr;
  double * q_b_Equ_c_Node_Ptr;
  double * q_c_Equ_b_Node_Ptr;
  double * q_ti_Equ_bi_Node_Ptr;
  double * q_ti_Equ_ci_Node_Ptr;
  double * q_ti_Equ_ei_Node_Ptr;
  double * q_ti_Equ_bii_Node_Ptr;
  double * q_ti_Equ_ti_Node_Ptr;
  double * q_t_Equ_t_Node_Ptr;
  double * q_t_Equ_ti_Node_Ptr;
  double * q_ti_Equ_t_Node_Ptr;
  double * q_c_Equ_BRA_c_ci_Var_Ptr;
  double * q_b_Equ_BRA_b_bi_Var_Ptr;
  double * q_e_Equ_BRA_e_ei_Var_Ptr;
  double * q_ei_Equ_BRA_e_ei_Var_Ptr;
  double * q_bi_Equ_BRA_b_bi_Var_Ptr;
  double * q_ci_Equ_BRA_c_ci_Var_Ptr;
  double * q_BRA_b_bi_Equ_b_Node_Ptr;
  double * q_BRA_b_bi_Equ_bi_Node_Ptr;
  double * q_BRA_b_bi_Equ_BRA_b_bi_Var_Ptr;
  double * q_BRA_e_ei_Equ_e_Node_Ptr;
  double * q_BRA_e_ei_Equ_ei_Node_Ptr;
  double * q_BRA_e_ei_Equ_BRA_e_ei_Var_Ptr;
  double * q_BRA_c_ci_Equ_c_Node_Ptr;
  double * q_BRA_c_ci_Equ_ci_Node_Ptr;
  double * q_BRA_c_ci_Equ_BRA_c_ci_Var_Ptr;
  // end of Jacobian and pointers
  // node numbers
  static const int admsNodeID_c = 0;
  static const int admsNodeID_b = 1;
  static const int admsNodeID_e = 2;
  static const int admsNodeID_t = 3;
  static const int admsNodeID_ei = 4;
  static const int admsNodeID_bi = 5;
  static const int admsNodeID_bii = 6;
  static const int admsNodeID_ci = 7;
  static const int admsNodeID_ti = 8;
  static const int admsNodeID_ex = 9;
  static const int admsNodeID_exx = 10;
  static const int admsNodeID_cx = 11;
  // end node numbers
  // Additional IDs for branch equations
  static const int admsBRA_ID_b_bi = 12;
  static const int admsBRA_ID_e_ei = 13;
  static const int admsBRA_ID_c_ci = 14;
  // end branch numbers
  // Probe numbers
  static const int admsProbeID_V_t_ti = 0;
  static const int admsProbeID_V_b_c = 1;
  static const int admsProbeID_V_c_GND = 2;
  static const int admsProbeID_V_b_GND = 3;
  static const int admsProbeID_V_cx_bii = 4;
  static const int admsProbeID_V_exx_bii = 5;
  static const int admsProbeID_V_ex_bii = 6;
  static const int admsProbeID_V_bii_bi = 7;
  static const int admsProbeID_I_c_ci = 8;
  static const int admsProbeID_I_e_ei = 9;
  static const int admsProbeID_I_b_bi = 10;
  static const int admsProbeID_V_ti_GND = 11;
  static const int admsProbeID_V_ci_ei = 12;
  static const int admsProbeID_V_exx_ei = 13;
  static const int admsProbeID_V_cx_ci = 14;
  static const int admsProbeID_V_ex_ei = 15;
  static const int admsProbeID_V_bii_ei = 16;
  static const int admsProbeID_V_bii_ci = 17;
  static const int admsProbeID_V_bi_ci = 18;
  // end probe numbers
  // State LIDs
  int li_state_admsProbeID_V_bi_ci;
  int li_state_admsProbeID_V_bii_ci;
  int li_state_admsProbeID_V_bii_ei;
  // end state LIDs
  // Arrays to hold probes
  vector < AdmsFadType > probeVars;
  // Arrays to hold contributions
  // dynamic contributions are differentiated w.r.t time
  vector < AdmsFadType > staticContributions;
  vector < AdmsFadType > dynamicContributions;

  // This array stores the differences between original and limited variables.
  vector<double> probeDiffs;
  // These store the Jdxp's for F and Q, respectively
  vector<double> Jdxp_static;
  vector<double> Jdxp_dynamic;

  // this is what we'll use when any model uses $temperature.  We'll
  // set it in updateTemperature, and initialize it to whatever
  // is in devOptions when the instance is constructed.
  double admsTemperature;

  // vt at $temperature;
  double adms_vt_nom;


  // This one is for the annoying bogus "XyceADMSInstTemp" parameter
  // that we need so we can set it from the device manager when there's no
  // "TEMP" parameter to use
  double admsInstTemp;

  static vector< vector<int> > jacStamp;
  static vector<int> jacMap;
  static vector< vector<int> > jacMap2;
};


// Class AnalogFunctions

class AnalogFunctions
{
public:

  // Analog Function exp_soft
  template<typename ScalarT> ScalarT exp_soft(ScalarT x)
  {


    ScalarT exp_soft;
    ScalarT maxexp;
    ScalarT maxarg;
    {
      maxexp = 1.0e25;
      maxarg = log(maxexp);
      if ((x<maxarg))
      {
        exp_soft = exp(x);
      }
      else
      {
        exp_soft = (((x+1.0)-maxarg)*maxexp);
      }
    }
    return(exp_soft);
  }


  // Analog Function Vt
  template<typename RetScalarT,typename Arg1ScalarT, typename Arg2ScalarT> RetScalarT Vt(Arg1ScalarT U, Arg2ScalarT Ud)
  {


    RetScalarT Vt;
    Arg2ScalarT Vch;
    Arg2ScalarT VF;
    RetScalarT exparg;
    {
      Vch = (0.1*Ud);
      VF = (0.9*Ud);
      if ((U<VF))
      {
        exparg=((U-VF)/Vch);
        Vt = (U-(Vch*log((1.0+exp(exparg)))));
      }
      else
      {
        exparg=((VF-U)/Vch);
        Vt = (VF-(Vch*log((1.0+exp(exparg)))));
      }
    }
    return(Vt);
  }


  // Analog Function diode
  template<typename RetScalarT,typename Arg1ScalarT,typename Arg3ScalarT,typename Arg4ScalarT,typename Arg6ScalarT>
  RetScalarT diode(Arg1ScalarT U, double Is, Arg3ScalarT Ug, Arg4ScalarT N, double AREA, Arg6ScalarT TJ, double TNOM)
  {


    RetScalarT diode;
    RetScalarT exparg1;
    RetScalarT exparg2;
    RetScalarT VTH0;
    Arg6ScalarT VTHJ;
    double VTHNOM;
    double maxi;
    Arg3ScalarT Tmax;
    Arg6ScalarT TJM;
    Arg6ScalarT TJM_arg1;
    double KDURCHQ;
    double lnIs;
    {
      VTH0 = Instance::adms_vt((20.0+273.15));
      VTHNOM = Instance::adms_vt((TNOM+273.15));
      KDURCHQ = 0.861708692e-4;
      lnIs = log((Is*AREA));
      maxi = log(1e6);
      if (((maxi<(Ug/VTHNOM))&&(U<0.0)))
      {
        Tmax = (((Ug*VTHNOM)/((Ug-(maxi*VTHNOM))*KDURCHQ))-273.15);
        TJM = Vt<Arg6ScalarT>(TJ,Tmax);
      }
      else
      {
        TJM = TJ;
      }
      TJM_arg1=TJM+273.15;
      VTHJ = Instance::adms_vt((TJM_arg1));
      if ((Ug>0.0))
      {
        exparg1=((((U/(N*VTHJ))+(Ug/VTHNOM))-(Ug/VTHJ))+lnIs);
        exparg2=(((Ug/VTHNOM)-(Ug/VTHJ))+lnIs);
        diode = (exp_soft(exparg1)-exp_soft(exparg2));
      }
      else
      {
        exparg1=((U/(N*VTH0))+lnIs);
        diode = (exp_soft(exparg1)-(Is*AREA));
      }
    }
    return(diode);
  }


  // Analog Function MM
  template<typename ScalarT> ScalarT MM(ScalarT VBCI, ScalarT VCBO, ScalarT MC, ScalarT VCBLIN, ScalarT BF, ScalarT KC)
  {


    ScalarT MM;
    ScalarT FBD;
    ScalarT vcbi;
    {
      if ((((KC>0.0)&&(MC>0.0))&&(VCBO>0.0)))
      {
        vcbi = VBCI;
        FBD = (VCBLIN/VCBO);
        if ((VBCI>0.0))
        {
          MM = 1.0;
        }
        else
        {
          if ((VBCI>(-VCBLIN)))
          {
            if ((MC==1))
            {
              MM = (1.0/(1.0-(vcbi/(-VCBO))));
            }
            else
            {
              MM = (1.0/(1.0-pow((vcbi/(-VCBO)),MC)));
            }
          }
          else
          {
            if ((VBCI<=(-VCBLIN)))
            {
              if ((MC==1))
              {
                MM = ((1.0/(1.0-FBD))-((((1.0/VCBO)*1.0)/pow((1.0-FBD),2.0))*(vcbi+(FBD*VCBO))));
              }
              else
              {
                MM = ((1.0/(1.0-pow(FBD,MC)))-((((MC/VCBO)*pow(FBD,(MC-1.0)))/pow((1.0-pow(FBD,MC)),2.0))*(vcbi+(FBD*VCBO))));
              }
            }
          }
        }
      }
      else
      {
        MM = 1.0;
      }
    }
    return(MM);
  }


  // Analog Function charge
  template< typename RetScalarT> RetScalarT charge(RetScalarT U, double C0, double Ud, double m, double Area)
  {


    RetScalarT charge;
    RetScalarT Vj;
    double Vjo;
    double VF;
    {
      Vj = Vt<RetScalarT>(U,Ud);
      Vjo = Vt<double>(0.0,Ud);
      VF = (0.9*Ud);
      if ((m==1.0))
      {
        charge = ((Area*C0)*((Ud*(log((1.0-(Vjo/Ud)))-log((1.0-(Vj/Ud)))))+((1.0/(1.0-(VF/Ud)))*((U-Vj)+Vjo))));
      }
      else
      {
        charge = ((Area*C0)*((((Ud/(1.0-m))*(pow((1.0-(Vjo/Ud)),(1.0-m))-pow((1.0-(Vj/Ud)),(1.0-m))))+(pow((1.0-(VF/Ud)),(-m))*((U-Vj)+Vjo)))-(Ud*(1.0/(1.0-m)))));
      }
    }
    return(charge);
  }


  // Analog Function Vceff
  template<typename ScalarT> ScalarT Vceff(ScalarT U, ScalarT VCES)
  {


    ScalarT Vceff;
    ScalarT Vth0;
    {
      Vth0 = 0.025;
      if ((U<VCES))
      {
        Vceff = (Vth0+(Vth0*log((1.0+exp((((U-VCES)/Vth0)-1.0))))));
      }
      else
      {
        Vceff = ((U-VCES)+(Vth0*log((1.0+exp((1.0-((U-VCES)/Vth0)))))));
      }
    }
    return(Vceff);
  }


  // Analog Function ICK
  template<typename ScalarT> ScalarT ICK(ScalarT U, ScalarT RCI0, ScalarT VLIM, ScalarT InvVPT, ScalarT VCES)
  {


    ScalarT ICK;
    ScalarT VC;
    ScalarT x;
    {
      VC = Vceff(U,VCES);
      x = ((VC-VLIM)*InvVPT);
      ICK = (((VC/RCI0)*(1.0/sqrt((1.0+((VC/VLIM)*(VC/VLIM))))))*(1.0+((x+sqrt(((x*x)+0.001)))/2.0)));
    }
    return(ICK);
  }

};


//-----------------------------------------------------------------------------
// Class         : Model

// Purpose       :
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class Model : public DeviceModel
{
  typedef std::vector<Instance *> InstanceVector;

  friend class ParametricData<Model>;
  friend class Instance;

  typedef Sacado::Fad::SFad<double,19> AdmsFadType;

public:
  static ParametricData<Model> &getParametricData();

  virtual const ParametricData<void> &getMyParametricData() const
  {
    return getParametricData();
  }

  Model(const ModelBlock &MB,
        SolverState & ss1,
        DeviceOptions & do1);
  ~Model();

private:
  Model();
  Model(const Model &);
  Model &operator=(const Model &);

public:
  virtual std::ostream &printOutInstances(std::ostream &os) const;
  bool processParams (string param = "");
  bool processInstanceParams (string param = "");

private:
  AnalogFunctions analogFunctions;

public:
  InstanceVector &getInstanceVector()
  {
    return instanceContainer;
  }

  const InstanceVector &getInstanceVector() const
  {
    return instanceContainer;
  }

private:
  vector<Instance*> instanceContainer;

private:

  // This one is for the annoying bogus "XyceADMSInstTemp" parameter
  // that we need so we can set it from the device manager when there's no
  // "TEMP" model parameter to use
  double admsModTemp;
  // Begin verilog Model Variables
  //   Model Parameters
  int Mode;
  int Noise;
  int Debug;
  int DebugPlus;
  double Rth;
  double Cth;
  double Jsf;
  double nf;
  double Vg;
  double Jse;
  double ne;
  double Rbxx;
  double Vgb;
  double Jsee;
  double nee;
  double Rbbxx;
  double Vgbb;
  double Jsr;
  double nr;
  double Vgr;
  double XCjc;
  double Jsc;
  double nc;
  double Rcxx;
  double Vgc;
  double Bf;
  double kBeta;
  double Br;
  double VAF;
  double VAR;
  double IKF;
  double IKR;
  double Mc;
  double BVceo;
  double kc;
  double BVebo;
  double Tr;
  double Trx;
  double Tf;
  double Tft;
  double Thcs;
  double Ahc;
  double Cje;
  double mje;
  double Vje;
  double Cjc;
  double mjc;
  double Vjc;
  double kjc;
  double Cmin;
  double J0;
  double XJ0;
  double Rci0;
  double Jk;
  double RJk;
  double Vces;
  double Rc;
  double Re;
  double Rb;
  double Rb2;
  double Lc;
  double Le;
  double Lb;
  double Cq;
  double Cpb;
  double Cpc;
  double Tnom;
  int dtype;
  //  Variables of global_model scope
  // end verilog model variables=====
};

} // namespace ADMSHBT_X
} // namespace Device
} // namespace Xyce

typedef Xyce::Device::ADMSHBT_X::Instance N_DEV_ADMSHBT_XInstance;
typedef Xyce::Device::ADMSHBT_X::Model N_DEV_ADMSHBT_XModel;

#endif //Xyce_N_DEV_ADMSHBT_X_h
