 //-----------------------------------------------------------------------------
// Copyright Notice
//
//   Copyright 2002 Sandia Corporation. Under the terms
//   of Contract DE-AC04-94AL85000 with Sandia Corporation, the U.S.
//   Government retains certain rights in this software.
//
//    Xyce(TM) Parallel Electrical Simulator
//    Copyright (C) 2002-2013  Sandia Corporation
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//-----------------------------------------------------------------------------

//-------------------------------------------------------------------------
// Filename       : $RCSfile: N_DEV_MutIndLin.C,v $
//
// Purpose        :
//
// Special Notes  :
//
// Creator        : Rich Schiek, SNL, Parallel Computational Sciences
//
// Creation Date  : 03/21/2005
//
// Revision Information:
// ---------------------
//
// Revision Number: $Revision: 1.100.2.4 $
//
// Revision Date  : $Date: 2013/10/03 17:23:38 $
//
// Current Owner  : $Author: tvrusso $
//-------------------------------------------------------------------------
#include <Xyce_config.h>

// ---------- Standard Includes ----------
#include <N_UTL_Misc.h>

#ifdef HAVE_CMATH
#include <cmath>
#else
#include <math.h>
#endif

#include <algorithm>
#include <set>

// ----------   Xyce Includes   ----------
#include <N_DEV_MutIndLin.h>
#include <N_DEV_ExternData.h>
#include <N_DEV_SolverState.h>
#include <N_DEV_DeviceOptions.h>
#include <N_DEV_MatrixLoadData.h>
#include <N_DEV_OutputPars.h>

#include <N_LAS_Vector.h>
#include <N_LAS_Matrix.h>

#include <N_UTL_Expression.h>

namespace Xyce {
namespace Device {

template<>
ParametricData<MutIndLin::Instance>::ParametricData()
{
    setNumNodes(2);
    setNumOptionalNodes(0);
    setNumFillNodes(0);
    setModelRequired(0);
    setPrimaryParameter("COUP_VAL");

    // Set up double precision variables:
    addPar ("COUP_VAL",   1.0, false,   ParameterType::NO_DEP,
        &MutIndLin::Instance::mutualCup,
        &MutIndLin::Instance::mutualCupGiven,
        U_NONE, CAT_NONE, "Coupling value");

    // Set up exceptions (ie variables that are not doubles):
    addPar ("COUPLEDMutIndLin", std::vector<std::string>(), false, ParameterType::NO_DEP,
            &MutIndLin::Instance::inductorNames, NULL, U_NONE, CAT_NONE, "");
    addPar ("COUPLEDINDUCTANCE", std::vector<double>(), false, ParameterType::NO_DEP,
            &MutIndLin::Instance::inductorInductances, NULL, U_NONE, CAT_NONE, "");
    addPar ("NODE1", std::vector<std::string>(), false, ParameterType::NO_DEP,
            &MutIndLin::Instance::inductorsNode1, NULL, U_NONE, CAT_NONE, "");
    addPar ("NODE2", std::vector<std::string>(), false, ParameterType::NO_DEP,
            &MutIndLin::Instance::inductorsNode2, NULL, U_NONE, CAT_NONE, "");
    addPar ("COUPLING", std::vector<double>(), false, ParameterType::SOLN_DEP,
            &MutIndLin::Instance::couplingCoefficient, NULL, U_NONE, CAT_NONE, "Coupling coefficient");
    addPar ("COUPLEDINDUCTOR", std::vector<std::string>(), false, ParameterType::NO_DEP,
            &MutIndLin::Instance::couplingInductor, NULL, U_NONE, CAT_NONE, "");
}

template<>
ParametricData<MutIndLin::Model>::ParametricData()
{
    addPar ("TNOM",   27.0,      false,   ParameterType::NO_DEP,
        &MutIndLin::Model::tnom,
        NULL, U_DEGC, CAT_MATERIAL, "Reference temperature");

    addPar ("TC1",     0.0,      false,   ParameterType::NO_DEP,
        &MutIndLin::Model::tempCoeff1,
        NULL, U_NONE, CAT_MATERIAL, "First order temperature coeff.");

    addPar ("TC2",     0.0,      false,   ParameterType::NO_DEP,
        &MutIndLin::Model::tempCoeff2,
        NULL, U_NONE, CAT_MATERIAL, "Second order temperature coeff.");
}

//-----------------------------------------------------------------------------
// Function      : InductorInstanceData::InductorInstanceData
// Purpose       :
// Special Notes :
//
// Need to have a constructor for this data-only class
// or it is treated as in-line by some compilers (gcc 3.3 on the mac)
// Trying to inline this could cause problems
//
// Scope         : public
// Creator       : Rich Schiek
// Creation Date :
//-----------------------------------------------------------------------------
InductorInstanceData::InductorInstanceData():
    name(""),    // name of inductor
    L(0.0),
    IC(0.0),
    ICGiven(false),
    baseL(0.0),
    li_Pos(-1),
    li_Neg(-1),
    li_Branch(-1),
    APosEquBraVarOffset(-1),
    ANegEquBraVarOffset(-1),
    ABraEquPosNodeOffset(-1),
    ABraEquNegNodeOffset(-1),
    ABraEquBraVarOffset(-1),
    magOffset(-1),
    vPosOffset(-1),
    vNegOffset(-1),
#ifndef Xyce_NONPOINTER_MATRIX_LOAD
    // Pointers for dFdx entries:
    f_PosEquBraVarPtr(0),
    f_NegEquBraVarPtr(0),
    f_BraEquPosNodePtr(0),
    f_BraEquNegNodePtr(0),
    f_BraEquBraVarPtr(0),
    // offsets only needed in nonlinear application
    f_magPtr(0),
    f_vPosPtr(0),
    f_vNegPtr(0),
    q_PosEquBraVarPtr(0),
    q_NegEquBraVarPtr(0),
    q_BraEquPosNodePtr(0),
    q_BraEquNegNodePtr(0),
    q_BraEquBraVarPtr(0),
    // offsets only needed in nonlinear application
    q_magPtr(0),
    q_vPosPtr(0),
    q_vNegPtr(0)
#endif
{}

namespace MutIndLin {

ParametricData<Instance> &Instance::getParametricData() {
  static ParametricData<Instance> parMap;

  return parMap;
}

ParametricData<Model> &Model::getParametricData() {
  static ParametricData<Model> parMap;

  return parMap;
}

//-----------------------------------------------------------------------------
// Function      : Instance::Instance
// Purpose       : constructor
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
Instance::Instance(InstanceBlock & IB,
                                Model & Iiter,
                                MatrixLoadData & mlData1,
                                SolverState & ss1,
                                ExternData  & ed1,
                                DeviceOptions & do1)
  : DeviceInstance (IB, mlData1, ss1, ed1, do1),
    model_(Iiter),
    numInductors(0),
    mutualCup(0.0),
    mutualCupGiven(false),
    scalingRHS(1.0),
    temp(getDeviceOptions().temp.dVal()),
    tempGiven(false)
{
  scalingRHS = 1.0;

  // set some default values.  May be changed by processParams
  numExtVars   = 2;
  numIntVars   = 1;
  numStateVars = 0;

  setName(IB.getName());
  setModelName(model_.getName());


  // Set params to constant default values:
  setDefaultParams ();

  // Set params according to instance line and constant defaults from metadata:
  setParams (IB.params);

#ifdef Xyce_DEBUG_DEVICE
  //if (getDeviceOptions().debugLevel > 0)
  //{
    //cout << "\n\nInstance Params:\n";
    //outputParams(*this, OutputMode::DEFAULT);
  //}
#endif


  // now load the instance data vector
  for( int i=0; i<inductorNames.size(); ++i )
  {
    InductorInstanceData * inductorData = new InductorInstanceData();
    inductorData->name = inductorNames[i];
    inductorData->L = inductorInductances[i];
    inductorData->baseL = inductorInductances[i];
    inductorData->ICGiven = false;
    inductorData->inductorCurrentOffsets.resize( inductorNames.size() );
    inductorData->f_inductorCurrentPtrs.resize( inductorNames.size() );
    inductorData->q_inductorCurrentPtrs.resize( inductorNames.size() );
    inductorData->depVarPairs.clear();
    instanceData.push_back( inductorData );
  }

  numInductors = instanceData.size();

  // set up the device connectivity map
  // each simple inductor in this mutual inductor
  // is maked as a connection (given a common, non-zero
  // value in devConMap)
  devConMap.resize(2*numInductors);
  for(int i=0; i<numInductors; i++)
  {
    devConMap[i] = devConMap[i+1] = (i+1);
  }

  // now assemble the mutual coupling coefficient matrix
  // assume no coupling except to self, so just ones on dialgonal.
  mutualCouplingCoef.resize( numInductors );
  mutualCouplingCoefDerivs.resize( numInductors );
  for( int i=0; i<numInductors; ++i )
  {
    mutualCouplingCoef[i].resize( numInductors );
    fill( mutualCouplingCoef[i].begin(), mutualCouplingCoef[i].end(), 0.0 );
    mutualCouplingCoef[i][i] = 1.0;

    mutualCouplingCoefDerivs[i].resize( numInductors );
    fill( mutualCouplingCoefDerivs[i].begin(),
          mutualCouplingCoefDerivs[i].end(), 0.0 );
  }

  // take the vector couplingInductor in pairs to figure out
  // the coupling value between inductors then insert it into
  // the couplingCoefficient matrix.
  indexPairs.resize(couplingInductor.size()/2);
  for( int i=0; i<couplingInductor.size() ; i+=2 )
  {
    // from inductor names, derive indices.
    int indexInductorOne = -1;
    int indexInductorTwo = -1;
    for( int j=0; j<inductorNames.size(); ++j)
    {
      if( couplingInductor[i] == inductorNames[j] )
      {
        indexInductorOne = j;
      }
      if( couplingInductor[i+1] == inductorNames[j] )
      {
        indexInductorTwo = j;
      }
      if( indexInductorOne != -1 && indexInductorTwo != -1 )
      {
        // stop searching if we found the answers.
        break;
      }
    }
    // Save the indices for later
    indexPairs[i/2].first = indexInductorOne;
    indexPairs[i/2].second = indexInductorTwo;
      
    // with the indices at hand, assign the value.
    // note that couplingCoefficient can be of length 1 if all coefficients were the 
    // same.  Catch that case here. 
    if( (i/2) < couplingCoefficient.size() )
    {
      mutualCouplingCoef[ indexInductorOne ][ indexInductorTwo ] = 
        mutualCouplingCoef[ indexInductorTwo ][ indexInductorOne ] = couplingCoefficient[ (i / 2) ];
    }
    else
    {
      mutualCouplingCoef[ indexInductorOne ][ indexInductorTwo ] = 
        mutualCouplingCoef[ indexInductorTwo ][ indexInductorOne ] = couplingCoefficient[ 0 ];
    }
  }

#ifdef Xyce_DEBUG_DEVICE
  if (getDeviceOptions().debugLevel > 0)
  {
    cout << "mutualCouplingCoef:  " << endl;
    for( int i=0; i<numInductors; ++i )
    {
      for( int j=0; j<numInductors; ++j )
      {
        cout << mutualCouplingCoef[i][j] << "  ";
      }
      cout << endl;
    }
  }
#endif

  inductorCurrents.resize( numInductors );
  dIdt.resize( numInductors );

  inductanceVals.resize( numInductors );
  LOI.resize( numInductors );
  LO.resize( numInductors );
  for( int i=0; i<numInductors; ++i)
  {
    LO[i].resize( numInductors );
  }

  updateInductanceMatrix();

  // Calculate any parameters specified as expressions:
  updateDependentParameters();

  // calculate dependent (ie computed) params and check for errors:
  processParams ();

  // update internal/external/state variable counts
  numExtVars = 2*numInductors;
  numIntVars = numInductors;
  numStateVars = 0;

  numCoupDepVars.resize(couplingCoefficient.size(),0);
  expPtrs.resize(couplingCoefficient.size(),0); // null pointers
  couplingCoefficientVarDerivs.resize(couplingCoefficient.size());

  // set up the jacobian stamp
  // for an individual inductor the stamp would be:
  //
  //          V1   V2   Ib
  //  kcl1               1
  //  kcl2              -1
  //  branch  1    -1   L/dt
  //
  //  for a collection of these, the internal variable, branch equations,
  //  must be at the end of a given stamp row.
  //
  //  So for N inductors the samp is:
  //
  //           V1  V2  V3  V4 ... V2N  I1  I2  ... IN
  //  kcl1                              1
  //  kcl2                             -1
  //  kcl3                                  1
  //  kcl4                                 -1
  //  branch1  1   -1                 L/dt  c  ... c
  //  branch2           1  -1          c  L/dt ... c
  //
  // where "c" is an induced current change.

  jacStamp.resize( 3 * numInductors );
  for( int i=0; i< numInductors; ++i )
  {
    jacStamp[2*i].resize(1);          // Vpos row
    jacStamp[2*i+1].resize(1);        // Vneg row
    jacStamp[2*numInductors + i].resize(numInductors + 2); // Ibranch row

    jacStamp[2*i  ][0] = 2*numInductors + i;    // vpos-ibranch
    jacStamp[2*i+1][0] = 2*numInductors + i;    // vneg-ibranch
    jacStamp[2*numInductors + i][0] = 2*i;      // ibranch-vpos
    jacStamp[2*numInductors + i][1] = 2*i + 1;  // ibranch-vneg
    for( int j=0; j<numInductors; ++j )
    {
      jacStamp[2*numInductors + i][j+2] = 2*numInductors + j;
                                               // ibranch-ibranch[j]
    }
  }

  // Now we process our dependent variables.
  // We need to bump up the jacstamp for all the dependencies on
  // the coupling vars that are expressions.  We also need to keep track of
  // how many variables each inductor depends on.
  vector<sDepend>::iterator d;
  vector<sDepend>::iterator begin=dependentParams.begin();
  vector<sDepend>::iterator end=dependentParams.end();

  for (d=begin; d != end; ++d)
  {

    if (d->name == "COUPLING" && d->vectorIndex != -1)
    {
      // sanity check, they should all have the first two conditions,
      // and the next means we actually have work to do
      if (d->n_vars >0)
      {
        // Keep track of the number of variables this coefficient depends on:
        numCoupDepVars[d->vectorIndex] = d->n_vars;

        // Save the pointer to the expresison, we need to be able to evaluate it.
        expPtrs[d->vectorIndex] = d->expr;

        // These are the two inductors that this coefficient couples
        int indexInductorOne = indexPairs[d->vectorIndex].first;
        int indexInductorTwo = indexPairs[d->vectorIndex].second;

        // The coupling coefficient introduces terms to both equations
        int inductorOneBranchSize = jacStamp[2*numInductors+
                                             indexInductorOne].size();
        int inductorTwoBranchSize = jacStamp[2*numInductors+
                                             indexInductorTwo].size();
        jacStamp[2*numInductors+indexInductorOne].resize(inductorOneBranchSize+
                                                         d->n_vars);
        jacStamp[2*numInductors+indexInductorTwo].resize(inductorTwoBranchSize+
                                                         d->n_vars);
        for (int i=0; i<d->n_vars; i++)
        {
          jacStamp[2*numInductors+indexInductorOne][inductorOneBranchSize+i]
            = d->lo_var+i+3*numInductors;
          jacStamp[2*numInductors+indexInductorTwo][inductorTwoBranchSize+i]
            = d->lo_var+i+3*numInductors;

          // We need to be able to determine which of our dependent var
          // indices map onto which variable of what coupling coefficient
          // when we go to do the jacobian loads.  We do this so we don't
          // need to keep all kinds of two-dimensional arrays like
          // mutualCoupling that are just copies of the one-dimensonal
          // arrays like couplingCoefficient.
          instanceData[indexInductorOne]->depVarPairs.push_back(
             pair<int,int>(d->vectorIndex,i));
          instanceData[indexInductorTwo]->depVarPairs.push_back(
             pair<int,int>(d->vectorIndex,i));
        }
      }
    }
    else
    {
      string msg="Error in mutual inductor constructor for ";
      msg += getName();
      msg += ": Found a dependent parameter that fails sanity check.";
      msg += "Name:" + d->name + " ";
      msg += "Value: " + (d->expr)->get_expression() + " ";
      N_ERH_ErrorMgr::report(N_ERH_ErrorMgr::DEV_FATAL, msg);
    }
  }


  // We're now done processing all the dependent variables, so we know
  // everything we need to know about expressions and derivative numbers.
  for (int i=0; i<couplingCoefficient.size(); ++i)
  {
    couplingCoefficientVarDerivs[i].resize(numCoupDepVars[i]);
  }

#ifdef Xyce_DEBUG_DEVICE
  if (getDeviceOptions().debugLevel > 0)
  {
    cout << "Instance::Instance-----------------" << endl;
    cout << "numExtVars = " << numExtVars << endl
      << "numIntVars = " << numIntVars << endl
      << "numStateVars = " << numStateVars << endl
      << "numInductors = " << numInductors << endl
      << "jacStamp = " << endl;
    for( int i = 0; i<jacStamp.size(); ++i )
    {
      cout << "jacStamp[ " << i << " ] = { ";
      for( int j=0; j<jacStamp[i].size(); ++j)
      {
        cout << jacStamp[i][j];
        if( j != ( jacStamp[i].size() -1 ) )
        {
          cout << ", ";
        }
      }
      cout << " }" << endl;
    }
  }
#endif

}

//-----------------------------------------------------------------------------
// Function      : Instance::~Instance
// Purpose       : destructor
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
Instance::~Instance()
{
  vector< InductorInstanceData* >::iterator currentInductor = instanceData.begin();
  vector< InductorInstanceData* >::iterator endInductor = instanceData.end();
  for ( ; currentInductor != endInductor ; ++currentInductor)
  {
    delete *currentInductor;
  }
}

//-----------------------------------------------------------------------------
// Function      : Instance::registerLIDs
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
void Instance::registerLIDs(const vector<int> & intLIDVecRef,
                                          const vector<int> & extLIDVecRef)
{
  string msg;
  string tmpstr;

  // Check if the size of the ID lists corresponds to the
  // proper number of internal and external variables.
  int numInt = intLIDVecRef.size();
  int numExt = extLIDVecRef.size();

  if (numInt != numIntVars)
  {
    msg = "Instance::registerLIDs:";
    msg += "numInt != numIntVars";
    N_ERH_ErrorMgr::report ( N_ERH_ErrorMgr::DEV_FATAL,msg);
  }

  if (numExt != numExtVars)
  {
    msg = "Instance::registerLIDs:";
    msg += "numExt != numExtVars";
    N_ERH_ErrorMgr::report ( N_ERH_ErrorMgr::DEV_FATAL,msg);
  }

  // copy over the global ID lists.
  intLIDVec = intLIDVecRef;
  extLIDVec = extLIDVecRef;

  // Now use these lists to obtain the indices into the
  // linear algebra entities.  This assumes an order.
  // For the matrix  indices, first do the rows.
  // get the current values of the inductances and currentOffsets
  vector< InductorInstanceData* >::iterator currentInductor = instanceData.begin();
  vector< InductorInstanceData* >::iterator endInductor = instanceData.end();
  int i = 0;
  int j = 0;
  while( currentInductor != endInductor )
  {
    (*currentInductor)->li_Pos = extLIDVec[ i++ ];
    (*currentInductor)->li_Neg = extLIDVec[ i++ ];
    (*currentInductor)->li_Branch = intLIDVec[ j++ ];
    ++currentInductor;
  }

#ifdef Xyce_DEBUG_DEVICE
  if (getDeviceOptions().debugLevel > 0)
  {
    cout << "Instance::registerLIDs----------------------------" << endl;
    currentInductor = instanceData.begin();
    i=0;
    while( currentInductor != endInductor )
    {
      cout << "Inductor [ " << i++ << " ] "
           << "   li_Pos = " << (*currentInductor)->li_Pos
           << "   li_Neg = " << (*currentInductor)->li_Neg
           << "   li_Branch = " << (*currentInductor)->li_Branch << endl;
      ++currentInductor;
    }
  }
#endif
}

//-----------------------------------------------------------------------------
// Function      : DiodeInstance::getIntNameMap
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Dave Shirley, PSSI
// Creation Date : 04/26/06
//-----------------------------------------------------------------------------
map<int,string> & Instance::getIntNameMap ()
{
  // set up the internal name map, if it hasn't been already.
  if (intNameMap.empty ())
  {
    string tmpstr;
    for( int i=0; i<instanceData.size() ; ++i)
    {
      tmpstr = getName() + "_" + instanceData[i]->name + "_branch";
      spiceInternalName (tmpstr);
      intNameMap[ intLIDVec[i] ] = tmpstr;
    }
  }

  return intNameMap;
}

//-----------------------------------------------------------------------------
// Function      : Instance::registerStateLIDs
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
void Instance::registerStateLIDs( const vector<int> & staLIDVecRef )
{
  string msg;

  // Check if the size of the ID lists corresponds to the
  // proper number of internal and external variables.
  int numSta = staLIDVecRef.size();

  if (numSta != numStateVars)
  {
    msg = "Instance::registerStateLIDs:";
    msg += "numSta != numStateVars";
    N_ERH_ErrorMgr::report ( N_ERH_ErrorMgr::DEV_FATAL,msg);
  }

  // copy over the global ID lists.
  staLIDVec = staLIDVecRef;
}

//-----------------------------------------------------------------------------
// Function      : BsrcInstance::getDepSolnVars
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Rob Hoekstra, SNL, Parallel Computational Sciences
// Creation Date : 06/06/01
//-----------------------------------------------------------------------------
const vector<string> & Instance::getDepSolnVars()
{
  return DeviceInstance::getDepSolnVars();
}

//-----------------------------------------------------------------------------
// Function      : Instance::jacobianStamp
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
const vector< vector<int> > & Instance::jacobianStamp() const
{
  return jacStamp;
}

//-----------------------------------------------------------------------------
// Function      : Instance::registerJacLIDs
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
void Instance::registerJacLIDs( const vector< vector<int> > & jacLIDVec )
{
  DeviceInstance::registerJacLIDs( jacLIDVec );
#ifdef Xyce_DEBUG_DEVICE
  if (getDeviceOptions().debugLevel > 0)
  {
    cout << "Instance::registerJacLIDs ----------------------------" << endl;
  }
#endif
  vector< InductorInstanceData* >::iterator currentInductor = instanceData.begin();
  vector< InductorInstanceData* >::iterator endInductor = instanceData.end();
  int i = 0;
  while( currentInductor != endInductor )
  {
    (*currentInductor)->APosEquBraVarOffset  = jacLIDVec[ 2*i     ][ 0 ];
    (*currentInductor)->ANegEquBraVarOffset  = jacLIDVec[ 2*i + 1 ][ 0 ];
    (*currentInductor)->ABraEquPosNodeOffset = jacLIDVec[ 2*numInductors + i ][ 0 ];
    (*currentInductor)->ABraEquNegNodeOffset = jacLIDVec[ 2*numInductors + i ][ 1 ];
    for( int j=0; j<numInductors; ++j )
    {
      if( i == j )
      {
        (*currentInductor)->ABraEquBraVarOffset  = jacLIDVec[ 2*numInductors + i ][ j + 2 ];
      }
      (*currentInductor)->inductorCurrentOffsets[ j ] = jacLIDVec[ 2*numInductors + i ][ j + 2 ];
    }
    // Now do the parts that are for the dependent variables
    int numdepvars=(*currentInductor)->depVarPairs.size();
    (*currentInductor)->ABraEquDepVarOffsets.resize(numdepvars);
    for (int j = 0; j < numdepvars; ++j)
    {
      (*currentInductor)->ABraEquDepVarOffsets[j] =
        jacLIDVec[2*numInductors+i][numInductors+2+j];
    }
    ++currentInductor;
    ++i;
  }

#ifdef Xyce_DEBUG_DEVICE
  if (getDeviceOptions().debugLevel > 0)
  {
    cout << "Instance::registerJacLIDs--------------------------" << endl;
    currentInductor = instanceData.begin();
    i=0;
    while( currentInductor != endInductor )
    {
      cout << "Inductor [ " << i << " ] " << (*currentInductor)->name
           << "   APosEquBraVarOffset = " << (*currentInductor)->APosEquBraVarOffset
           << "   ANegEquBraVarOffset = " << (*currentInductor)->ANegEquBraVarOffset
           << "   ABraEquPosNodeOffset = " << (*currentInductor)->ABraEquPosNodeOffset
           << "   ABraEquNegNodeOffset = " << (*currentInductor)->ABraEquNegNodeOffset
           << "   ABraEquBraVarOffset = " << (*currentInductor)->ABraEquBraVarOffset << endl;
      cout << "\tInductor branch offsets = { ";
      for( int j=0; j<numInductors ; ++j )
      {
        cout << (*currentInductor)->inductorCurrentOffsets[ j ] << ", ";
      }
      cout << "} " << endl;
      ++i;
      ++currentInductor;
    }
  }
#endif
}

//-----------------------------------------------------------------------------
// Function      : Instance::setupPointers
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Eric Keiter, SNL
// Creation Date : 12/12/08
//-----------------------------------------------------------------------------
void Instance::setupPointers ()
{
#ifndef Xyce_NONPOINTER_MATRIX_LOAD
  N_LAS_Matrix & dFdx = *(extData.dFdxMatrixPtr);
  N_LAS_Matrix & dQdx = *(extData.dQdxMatrixPtr);

  vector< InductorInstanceData* >::iterator currentInductor = instanceData.begin();
  vector< InductorInstanceData* >::iterator endInductor = instanceData.end();
  int i = 0;
  while( currentInductor != endInductor )
  {
    // dFdx pointers:
    (*currentInductor)->f_PosEquBraVarPtr  =
        &(dFdx[((*currentInductor)->li_Pos)] [((*currentInductor)->APosEquBraVarOffset)] );

    (*currentInductor)->f_NegEquBraVarPtr =
        &(dFdx[((*currentInductor)->li_Neg)]   [((*currentInductor)->ANegEquBraVarOffset)] );

    (*currentInductor)->f_BraEquPosNodePtr =
        &(dFdx[((*currentInductor)->li_Branch)][((*currentInductor)->ABraEquPosNodeOffset)] );

    (*currentInductor)->f_BraEquNegNodePtr =
        &(dFdx[((*currentInductor)->li_Branch)][((*currentInductor)->ABraEquNegNodeOffset)] );

    for( int j=0; j<numInductors; ++j )
    {
      if( i == j )
      {
        //(*currentInductor)->ABraEquBraVarOffset  =
        // Is this only used for JMat?  (ie old DAE)?

      }
      (*currentInductor)->f_inductorCurrentPtrs[ j ] =
            &(dFdx[((*currentInductor)->li_Branch)][(*currentInductor)->inductorCurrentOffsets[j]] );
    }
    // Now do the parts that are for the dependent variables
    int numdepvars=(*currentInductor)->depVarPairs.size();
    (*currentInductor)->f_BraEquDepVarPtrs.resize(numdepvars);

    for (int j = 0; j < numdepvars; ++j)
    {
      (*currentInductor)->f_BraEquDepVarPtrs[j] =
            &(dFdx[((*currentInductor)->li_Branch)][(*currentInductor)->ABraEquDepVarOffsets[j]] );

    }

    // dQdx pointers:
    (*currentInductor)->q_PosEquBraVarPtr  =
        &(dQdx[((*currentInductor)->li_Pos)] [((*currentInductor)->APosEquBraVarOffset)] );

    (*currentInductor)->q_NegEquBraVarPtr =
        &(dQdx[((*currentInductor)->li_Neg)]   [((*currentInductor)->ANegEquBraVarOffset)] );

    (*currentInductor)->q_BraEquPosNodePtr =
        &(dQdx[((*currentInductor)->li_Branch)][((*currentInductor)->ABraEquPosNodeOffset)] );

    (*currentInductor)->q_BraEquNegNodePtr =
        &(dQdx[((*currentInductor)->li_Branch)][((*currentInductor)->ABraEquNegNodeOffset)] );

    for( int j=0; j<numInductors; ++j )
    {
      if( i == j )
      {
        //(*currentInductor)->ABraEquBraVarOffset  =
        // Is this only used for JMat?  (ie old DAE)?

      }
      (*currentInductor)->q_inductorCurrentPtrs[ j ] =
            &(dQdx[((*currentInductor)->li_Branch)][(*currentInductor)->inductorCurrentOffsets[j]] );
    }
    // Now do the parts that are for the dependent variables
    numdepvars=(*currentInductor)->depVarPairs.size();
    (*currentInductor)->q_BraEquDepVarPtrs.resize(numdepvars);

    for (int j = 0; j < numdepvars; ++j)
    {
      (*currentInductor)->q_BraEquDepVarPtrs[j] =
            &(dQdx[((*currentInductor)->li_Branch)][(*currentInductor)->ABraEquDepVarOffsets[j]] );

    }

    ++currentInductor;
    ++i;
  }



#endif
}

//-----------------------------------------------------------------------------
// Function      : Instance::processParams
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
bool Instance::processParams(string param)
{
  int i, j;

  // take the vector couplingInductor in pairs to figure out
  // the coupling value between inductors then insert it into
  // the couplingCoefficient matrix.
  j = indexPairs.size();
  for( i=0; i<j ; ++i )
  {      
    // note that couplingCoefficient can be of length 1 if all coefficients were the 
    // same.  Catch that case here. 
    if( i < couplingCoefficient.size() )
    {
      mutualCouplingCoef[ indexPairs[i].first ][ indexPairs[i].second ] =
        mutualCouplingCoef[ indexPairs[i].second ][ indexPairs[i].first ] = couplingCoefficient[i];
    }
    else
    {
      mutualCouplingCoef[ indexPairs[i].first ][ indexPairs[i].second ] =
        mutualCouplingCoef[ indexPairs[i].second ][ indexPairs[i].first ] = couplingCoefficient[0];
    }
  }
#ifdef Xyce_DEBUG_DEVICE
  if (getDeviceOptions().debugLevel > 0  && getSolverState().debugTimeFlag)
  {
    cout << "processParams: mutualCouplingCoef:  " << endl;
    for( int i=0; i<numInductors; ++i )
    {
      for( int j=0; j<numInductors; ++j )
      {
        cout << mutualCouplingCoef[i][j] << "  ";
      }
      cout << endl;
    }
  }
#endif

  // set the temperature related stuff.
  updateTemperature(temp);

  return true;
}

//-----------------------------------------------------------------------------
// Function      : Instance::updateTemperature
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
bool Instance::updateTemperature ( const double & temp)
{
  bool bsuccess = true;

  // current temp difference from reference temp.
  double difference = temp - model_.tnom;

  vector< InductorInstanceData* >::iterator currentData = instanceData.begin();
  while( currentData != instanceData.end() )
  {
    double factor = 1.0 + (model_.tempCoeff1)*difference +
                          (model_.tempCoeff2)*difference*difference;
    (*currentData)->L = ((*currentData)->baseL)*factor;
    ++currentData;
  }

  // now that the inductances have changed we need to update the matrix.
  updateInductanceMatrix();

  return bsuccess;
}

//-----------------------------------------------------------------------------
// Function      : Instance::updateIntermediateVars
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
bool Instance::updateIntermediateVars ()
{
  bool bsuccess = true;

  // This method is never called anymore

  return bsuccess;
}

//-----------------------------------------------------------------------------
// Function      : Instance::updateInductanceMatrix()
// Purpose       : A matrix of inductances is used often enough that it
//                 calculated and stored as a member variable here
//                 If and inductance ever changes say from updating
//                 the temperature or a parameter udpate, then this
//                 routine must be called again.
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
void Instance::updateInductanceMatrix()
{
  vector< InductorInstanceData* >::iterator
    currentInductor = instanceData.begin();
  vector< InductorInstanceData* >::iterator
    endInductor = instanceData.end();

  // collec the inductances
  int i=0;
  while( currentInductor != endInductor )
  {
    inductanceVals[ i ] = ((*currentInductor)->L);
    ++i;
    ++currentInductor;
  }

  // compute the inductance matrix
  for( i=0; i<numInductors; ++i)
  {
    for( int j=0; j<numInductors; ++j)
    {
      LO[i][j] = sqrt( inductanceVals[i]*inductanceVals[j] );
    }
  }

}
//-----------------------------------------------------------------------------
// Function      : Instance::updatePrimaryState
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
bool Instance::updatePrimaryState()
{
  // nothing happens in updateIntermediateVars() anymore
  // bsuccess = updateIntermediateVars ();

#ifdef  Xyce_DEBUG_DEVICE
  if (getDeviceOptions().debugLevel > 0 && getSolverState().debugTimeFlag)
  {
    cout << "Instance::updatePrimaryState------------------" << endl
         << "\tname = " << getName() << endl;
  }
#endif

  double * solVec = extData.nextSolVectorRawPtr;

  // Evaluate the derivatives of all (dependent) coupling coefficients w.r.t
  // their variables.  We need these for both new and old DAE.
  int ncoupcoef=couplingCoefficient.size();
  for (int i=0; i<ncoupcoef; ++i)
  {
    if (expPtrs[i])
    {
      double junk;
      expPtrs[i]->evaluate( junk, couplingCoefficientVarDerivs[i]);
    }
  }

  // get the currents in each inductor
  vector< InductorInstanceData* >::iterator
  currentInductor = instanceData.begin();
  vector< InductorInstanceData* >::iterator
  endInductor = instanceData.end();
  int i = 0;
  while( currentInductor != endInductor )
  {
    if( (getSolverState().dcopFlag) && ((*currentInductor)->ICGiven) )
    {
      inductorCurrents[ i ] = (*currentInductor)->IC;
    }
    else
    {
      inductorCurrents[ i ] = solVec[ (*currentInductor)->li_Branch ];
    }
    ++i;
    ++currentInductor;
  }

  return true;
}

//-----------------------------------------------------------------------------
// Function      : Instance::loadDeviceMask
//
// Purpose       : Loads the zero elements of the device mask
//
// Special Notes : elements of the error vector associated with zero
//                 elements of the mask will not be included in weighted
//                 norms by the time integrator.
//
// Scope         : public
// Creator       : Richard Schiek, SNL, Electrical and Microsystems Modeling
// Creation Date : 02/06/07
//-----------------------------------------------------------------------------
bool Instance::loadDeviceMask ()
{
  bool returnVal=false;
#ifndef Xyce_NO_MUTINDLIN_MASK
  N_LAS_Vector * maskVectorPtr = extData.deviceMaskVectorPtr;

  vector< InductorInstanceData* >::iterator currentInductor = instanceData.begin();
  vector< InductorInstanceData* >::iterator endInductor = instanceData.end();
  while( currentInductor != endInductor )
  {
    (*maskVectorPtr)[((*currentInductor)->li_Branch)] = 0.0;
    ++currentInductor;
  }
  returnVal = true;
#endif
  return (returnVal);
}

//-----------------------------------------------------------------------------
// Function      : Instance::loadDAEQVector
//
// Purpose       : Loads the Q-vector contributions for a single
//                 Mutual Inductor instance.
//
// Special Notes : The "Q" vector is part of a standard DAE formalism in
//                 which the system of equations is represented as:
//
//                 f(x) = dQ(x)/dt + F(x) - B(t) = 0
//
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
bool Instance::loadDAEQVector ()
{
#ifdef  Xyce_DEBUG_DEVICE
  if (getDeviceOptions().debugLevel > 0 && getSolverState().debugTimeFlag)
  {
    cout << "Instance::loadDAEQVector---------------------------" << endl
         << "\tname = " << getName() << endl;
  }
#endif
  double * qVec = extData.daeQVectorRawPtr;

  // calculate the following product
  // I = column vector of currents
  // L = row vector of inductances
  // LO = matrix = mutualCup * sqrt( L' * L )
  // LOI = column vector = mutualCup * sqrt( L' * L ) * I
  // LOI[1] = mutualCup * sqrt(L[1]*L[1])*I[1]) +
  //          mutualCup * sqrt(L[1]*L[2])*I[2]) + ...
  //          mutualCup * sqrt(L[1]*L[n])*I[n])

  for( int i = 0; i < numInductors; ++i )
  {
    LOI[ i ] = 0.0;
    for( int j = 0; j < numInductors; ++j )
    {
      LOI[i] += mutualCouplingCoef[i][j] * LO[i][j] * inductorCurrents[j];
    }
  }

  // loop over each inductor and load it's Q vector components
  vector< InductorInstanceData* >::iterator currentInductor = instanceData.begin();
  vector< InductorInstanceData* >::iterator endInductor = instanceData.end();
  int i=0;
  while( currentInductor != endInductor )
  {
    qVec[(*currentInductor)->li_Branch] += LOI[ i ];
    ++i;
    ++currentInductor;
  }

  return true;
}

//-----------------------------------------------------------------------------
// Function      : Instance::loadDAEFVector
//
// Purpose       : Loads the F-vector contributions for a single
//                 Mutual Inductor instance.
//
// Special Notes :
//
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
bool Instance::loadDAEFVector ()
{
#ifdef  Xyce_DEBUG_DEVICE
  if (getDeviceOptions().debugLevel > 0 && getSolverState().debugTimeFlag)
  {
    cout << "Instance::loadDAEFVector---------------------------" << endl
         << "\tname = " << getName() << endl;
  }
#endif

  double * fVec = extData.daeFVectorRawPtr;
  double * solVec = extData.nextSolVectorRawPtr;

  // loop over each inductor and load it's F vector components
  vector< InductorInstanceData* >::iterator currentInductor = instanceData.begin();
  vector< InductorInstanceData* >::iterator endInductor = instanceData.end();
  int i = 0;

  while( currentInductor != endInductor )
  {
    double current   = solVec[(*currentInductor)->li_Branch];
    double vNodePos  = solVec[(*currentInductor)->li_Pos];
    double vNodeNeg  = solVec[(*currentInductor)->li_Neg];
    fVec[((*currentInductor)->li_Pos)]    +=  scalingRHS * current;
    fVec[((*currentInductor)->li_Neg)]    += -scalingRHS * current;
    fVec[((*currentInductor)->li_Branch)] += -(vNodePos - vNodeNeg);

#ifdef  Xyce_DEBUG_DEVICE
    if (getDeviceOptions().debugLevel > 0 && getSolverState().debugTimeFlag)
    {
      cout << "  Inductor = " << (*currentInductor)->name
           << "\tcurrent = " << current
           << "\tvNodePos = " << vNodePos
           << "\tvNodeNeg = " << vNodeNeg
           << endl;
    }
#endif

    ++currentInductor;
    ++i;
  }

  return true;
}

//-----------------------------------------------------------------------------
// Function      : Instance::loadDAEdQdx
//
// Purpose       : Loads the Q-vector contributions for a single
//                 Mutual Inductor instance.
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
bool Instance::loadDAEdQdx ()
{
#ifdef  Xyce_DEBUG_DEVICE
  if (getDeviceOptions().debugLevel > 0 && getSolverState().debugTimeFlag)
  {
    cout << "Instance::loadDAEdQdx--------------------------" << endl
         << "\tname = " << getName() << endl;
  }
#endif

  // During the DCOP, the dQdx*pdt matrix is summed into the Jacobian,
  // even though the Q*pdt vector is not summed into the residual.
  //if (!getSolverState().dcopFlag)
  {
    N_LAS_Matrix & dQdx = *(extData.dQdxMatrixPtr);

    // loop over each inductor and load it's Q vector components
    vector< InductorInstanceData* >::iterator currentInductor = instanceData.begin();
    vector< InductorInstanceData* >::iterator endInductor = instanceData.end();
    int i=0;
    while( currentInductor != endInductor )
    {
      for( int j=0; j<numInductors; ++j )
      {
        dQdx[((*currentInductor)->li_Branch)]
                     [(*currentInductor)->inductorCurrentOffsets[j]] += mutualCouplingCoef[i][j] * LO[i][j];
      }
      // finally do all the dependent variable terms
      int numdepterms=(*currentInductor)->depVarPairs.size();
      for (int j=0 ; j<numdepterms; ++j)
      {
        int coefficientNumber=(*currentInductor)->depVarPairs[j].first;
        int depVarNumber=(*currentInductor)->depVarPairs[j].second;
        int otherInductor;

        // indexPairs[coefficient] gives the two inductors coupled by that
        // coefficient.  One of them is currentInductor because we saved that
        // coefficient number in our depVarPairs, so the other is the one
        // we need to know

        if (i==indexPairs[coefficientNumber].first)
          otherInductor=indexPairs[coefficientNumber].second;
        else
          otherInductor=indexPairs[coefficientNumber].first;

        dQdx[((*currentInductor)->li_Branch)][(*currentInductor)->ABraEquDepVarOffsets[j]] +=
          couplingCoefficientVarDerivs[coefficientNumber][depVarNumber]
          *LO[i][otherInductor]*inductorCurrents[otherInductor];
      }

      ++i;
      ++currentInductor;
    }
  }

  return true;
}

//-----------------------------------------------------------------------------
// Function      : Instance::loadDAEdFdx ()
//
// Purpose       : Loads the F-vector contributions for a single
//                 Mutual Inductor instance.
//
// Special Notes :
//
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
bool Instance::loadDAEdFdx ()
{
  N_LAS_Matrix & dFdx = *(extData.dFdxMatrixPtr);

  // loop over each inductor and load it's dFdx components
  vector< InductorInstanceData* >::iterator currentInductor = instanceData.begin();
  vector< InductorInstanceData* >::iterator endInductor = instanceData.end();
  while( currentInductor != endInductor )
  {
    dFdx[((*currentInductor)->li_Pos)]   [((*currentInductor)->APosEquBraVarOffset)]  +=  scalingRHS;
    dFdx[((*currentInductor)->li_Neg)]   [((*currentInductor)->ANegEquBraVarOffset)]  += -scalingRHS;
    dFdx[((*currentInductor)->li_Branch)][((*currentInductor)->ABraEquPosNodeOffset)] += -1.0;
    dFdx[((*currentInductor)->li_Branch)][((*currentInductor)->ABraEquNegNodeOffset)] +=  1.0;

    ++currentInductor;
  }

  return true;
}

//-----------------------------------------------------------------------------
// Function      : Instance::setIC
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
bool Instance::setIC ()
{
  int i_bra_sol;
  int i_f_state;

  bool bsuccess = true;
  return bsuccess;
}

//-----------------------------------------------------------------------------
// Function      : Instance::varTypes
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
void Instance::varTypes( vector<char> & varTypeVec )
{
  varTypeVec.resize(numInductors);
  for(int i=0; i<numInductors; i++)
  {
    varTypeVec[i] = 'I';
  }
}

//-----------------------------------------------------------------------------
// Function      : Model::processParams
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
bool Model::processParams (string param)
{
  return true;
}

//----------------------------------------------------------------------------
// Function      : Model::processInstanceParams
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Dave Shirely, PSSI
// Creation Date : 03/23/06
//----------------------------------------------------------------------------
bool Model::processInstanceParams(string param)
{
  vector<Instance*>::iterator iter;
  vector<Instance*>::iterator first = instanceContainer.begin();
  vector<Instance*>::iterator last  = instanceContainer.end();

  for (iter=first; iter!=last; ++iter)
  {
    (*iter)->processParams();
  }

  return true;
}

//-----------------------------------------------------------------------------
// Function      : Model::Model
// Purpose       : block constructor
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
Model::Model (const ModelBlock & MB,
                                                SolverState & ss1,
                                                DeviceOptions & do1)
  : DeviceModel(MB,ss1,do1),
    tempCoeff1(0.0),
    tempCoeff2(0.0),
    tnom(do1.tnom)
{

  // Set params to constant default values:
 setDefaultParams ();

  // Set params according to .model line and constant defaults from metadata:
  setModParams (MB.params);

  // Set any non-constant parameter defaults:
  if (!given("TNOM"))
    tnom = getDeviceOptions().tnom;

#ifdef Xyce_DEBUG_DEVICE
  //if (getDeviceOptions().debugLevel > 0)
  //{
    //cout << "\n\nModel Params:\n";
    //outputParams(*this, OutputMode::DEFAULT);
  //}
#endif

  // Calculate any parameters specified as expressions:
  updateDependentParameters();

  // calculate dependent (ie computed) params and check for errors:
  processParams ();
}

//-----------------------------------------------------------------------------
// Function      : Model::~Model
// Purpose       : destructor
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
Model::~Model ()
{
  vector<Instance*>::iterator iter;
  vector<Instance*>::iterator first = instanceContainer.begin();
  vector<Instance*>::iterator last  = instanceContainer.end();

  for (iter=first; iter!=last; ++iter)
  {
    delete (*iter);
  }

}

// additional Declarations

//-----------------------------------------------------------------------------
// Function      : Model::printOutInstances
// Purpose       : debugging tool.
// Special Notes :
// Scope         : public
// Creator       : Rich Schiek, SNL, Parallel Computational Sciences
// Creation Date : 03/21/2005
//-----------------------------------------------------------------------------
std::ostream &Model::printOutInstances(std::ostream &os) const
{
  vector<Instance*>::const_iterator iter;
  vector<Instance*>::const_iterator first = instanceContainer.begin();
  vector<Instance*>::const_iterator last  = instanceContainer.end();

  int i, isize;
  isize = instanceContainer.size();

  os << endl;
  os << "Number of MutIndLin instances: " << isize << endl;
  os << "    name=\t\tmodelName\tParameters" << endl;
  for (i=0, iter=first; iter!=last; ++iter, ++i)
  {
    os << "  " << i << ": " << (*iter)->getName() << "\t";
    os << (*iter)->getModelName();
    os << endl;
  }

  os << endl;

  return os;
}

// MutIndLin Master functions:

//-----------------------------------------------------------------------------
// Function      : Master::updateState
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Eric Keiter, SNL
// Creation Date : 12/12/08
//-----------------------------------------------------------------------------
bool Master::updateState (double * solVec, double * staVec, double * stoVec)
{
  for (InstanceVector::const_iterator it = getInstanceVector().begin(); it != getInstanceVector().end(); ++it)
  {
     Instance & inst = *(*it);

    // Evaluate the derivatives of all (dependent) coupling coefficients w.r.t
    // their variables.  We need these for both new and old DAE.
    int ncoupcoef=inst.couplingCoefficient.size();
    for (int i=0; i<ncoupcoef; ++i)
    {
      if (inst.expPtrs[i])
      {
        double junk;
        inst.expPtrs[i]->evaluate( junk, inst.couplingCoefficientVarDerivs[i]);
      }
    }

    // get the currents in each inductor
    vector< InductorInstanceData* >::iterator
    currentInductor = inst.instanceData.begin();
    vector< InductorInstanceData* >::iterator
    endInductor = inst.instanceData.end();
    {
    int i = 0;
    while( currentInductor != endInductor )
    {
      if( (getSolverState().dcopFlag) && ((*currentInductor)->ICGiven) )
      {
        inst.inductorCurrents[ i ] = (*currentInductor)->IC;
      }
      else
      {
        inst.inductorCurrents[ i ] = solVec[ (*currentInductor)->li_Branch ];
      }
      ++i;
      ++currentInductor;
    }
    }
  }

  return true;
}

//-----------------------------------------------------------------------------
// Function      : Master::loadDAEVectors
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Eric Keiter, SNL
// Creation Date : 12/12/08
//-----------------------------------------------------------------------------
bool Master::loadDAEVectors (double * solVec, double * fVec, double *qVec,  double * storeLeadF, double * storeLeadQ)
{
  for (InstanceVector::const_iterator it = getInstanceVector().begin(); it != getInstanceVector().end(); ++it)
  {
    Instance & inst = *(*it);

    // F-vector:
    // loop over each inductor and load it's F vector components
    vector< InductorInstanceData* >::iterator currentInductor = inst.instanceData.begin();
    vector< InductorInstanceData* >::iterator endInductor = inst.instanceData.end();

    while( currentInductor != endInductor )
    {
      double current   = solVec[(*currentInductor)->li_Branch];
      double vNodePos  = solVec[(*currentInductor)->li_Pos];
      double vNodeNeg  = solVec[(*currentInductor)->li_Neg];

      fVec[((*currentInductor)->li_Pos)]    +=  inst.scalingRHS * current;
      fVec[((*currentInductor)->li_Neg)]    += -inst.scalingRHS * current;
      fVec[((*currentInductor)->li_Branch)] += -(vNodePos - vNodeNeg);

      ++currentInductor;
    }

    // Q-vector:
    // calculate the following product
    // I = column vector of currents
    // L = row vector of inductances
    // LO = matrix = mutualCup * sqrt( L' * L )
    // LOI = column vector = mutualCup * sqrt( L' * L ) * I
    // LOI[1] = mutualCup * sqrt(L[1]*L[1])*I[1]) +
    //          mutualCup * sqrt(L[1]*L[2])*I[2]) + ...
    //          mutualCup * sqrt(L[1]*L[n])*I[n])

    for( int i = 0; i < inst.numInductors; ++i )
    {
      inst.LOI[ i ] = 0.0;
      for( int j = 0; j < inst.numInductors; ++j )
      {
        inst.LOI[i] += inst.mutualCouplingCoef[i][j] * inst.LO[i][j] * inst.inductorCurrents[j];
      }
    }

    // loop over each inductor and load it's Q vector components
    currentInductor = inst.instanceData.begin();
    endInductor = inst.instanceData.end();
    int li=0;
    while( currentInductor != endInductor )
    {
      qVec[(*currentInductor)->li_Branch] += inst.LOI[ li ];
      ++li;
      ++currentInductor;
    }
  }
  return true;
}

#ifndef Xyce_NONPOINTER_MATRIX_LOAD
//-----------------------------------------------------------------------------
// Function      : Master::loadDAEMatrices
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Eric Keiter, SNL
// Creation Date : 12/12/08
//-----------------------------------------------------------------------------
bool Master::loadDAEMatrices (N_LAS_Matrix & dFdx, N_LAS_Matrix & dQdx)
{
  for (InstanceVector::const_iterator it = getInstanceVector().begin(); it != getInstanceVector().end(); ++it)
  {
    Instance & inst = *(*it);
    // loop over each inductor and load it's dFdx components
    vector< InductorInstanceData* >::iterator currentInductor = inst.instanceData.begin();
    vector< InductorInstanceData* >::iterator endInductor = inst.instanceData.end();
    while( currentInductor != endInductor )
    {
      *((*currentInductor)->f_PosEquBraVarPtr)  +=  inst.scalingRHS;
      *((*currentInductor)->f_NegEquBraVarPtr)  += -inst.scalingRHS;
      *((*currentInductor)->f_BraEquPosNodePtr) += -1.0;
      *((*currentInductor)->f_BraEquNegNodePtr) +=  1.0;

      ++currentInductor;
    }

    // During the DCOP, the dQdx*pdt matrix is summed into the Jacobian,
    // even though the Q*pdt vector is not summed into the residual.
    //if (!getSolverState().dcopFlag)
    {
      // loop over each inductor and load it's Q vector components
      currentInductor = inst.instanceData.begin();
      endInductor = inst.instanceData.end();
      int li=0;
      while( currentInductor != endInductor )
      {
        for( int j=0; j<inst.numInductors; ++j )
        {
          *((*currentInductor)->q_inductorCurrentPtrs[j]) += inst.mutualCouplingCoef[li][j] * inst.LO[li][j];
        }
        // finally do all the dependent variable terms
        int numdepterms=(*currentInductor)->depVarPairs.size();
        for (int j=0 ; j<numdepterms; ++j)
        {
          int coefficientNumber=(*currentInductor)->depVarPairs[j].first;
          int depVarNumber=(*currentInductor)->depVarPairs[j].second;
          int otherInductor;

          // indexPairs[coefficient] gives the two inductors coupled by that
          // coefficient.  One of them is currentInductor because we saved that
          // coefficient number in our depVarPairs, so the other is the one
          // we need to know

          if (li==inst.indexPairs[coefficientNumber].first)
            otherInductor=inst.indexPairs[coefficientNumber].second;
          else
            otherInductor=inst.indexPairs[coefficientNumber].second;

          *((*currentInductor)->q_BraEquDepVarPtrs[j]) +=
                inst.couplingCoefficientVarDerivs[coefficientNumber][depVarNumber]
                *inst.LO[li][otherInductor]*inst.inductorCurrents[otherInductor];
        }

        ++li;
        ++currentInductor;
      }
    }
  }

  return true;
}

#else
//-----------------------------------------------------------------------------
// Function      : Master::loadDAEMatrices
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Eric Keiter, SNL
// Creation Date : 12/12/08
//-----------------------------------------------------------------------------
bool Master::loadDAEMatrices (N_LAS_Matrix & dFdx, N_LAS_Matrix & dQdx)
{
  int sizeInstances = instanceContainer_.size();
  for (int i=0; i<sizeInstances; ++i)
  {
    Instance & inst = *(instanceContainer_.at(i));
    // loop over each inductor and load it's dFdx components
    vector< InductorInstanceData* >::iterator currentInductor = inst.instanceData.begin();
    vector< InductorInstanceData* >::iterator endInductor = inst.instanceData.end();
    while( currentInductor != endInductor )
    {
      dFdx[((*currentInductor)->li_Pos)]   [((*currentInductor)->APosEquBraVarOffset)]  +=  inst.scalingRHS;
      dFdx[((*currentInductor)->li_Neg)]   [((*currentInductor)->ANegEquBraVarOffset)]  += -inst.scalingRHS;
      dFdx[((*currentInductor)->li_Branch)][((*currentInductor)->ABraEquPosNodeOffset)] += -1.0;
      dFdx[((*currentInductor)->li_Branch)][((*currentInductor)->ABraEquNegNodeOffset)] +=  1.0;

      ++currentInductor;
    }

    // During the DCOP, the dQdx*pdt matrix is summed into the Jacobian,
    // even though the Q*pdt vector is not summed into the residual.
    //if (!getSolverState().dcopFlag)
    {
      // loop over each inductor and load it's Q vector components
      currentInductor = inst.instanceData.begin();
      endInductor = inst.instanceData.end();
      int i=0;
      while( currentInductor != endInductor )
      {
        for( int j=0; j<inst.numInductors; ++j )
        {
          dQdx[((*currentInductor)->li_Branch)]
                      [(*currentInductor)->inductorCurrentOffsets[j]] += inst.mutualCouplingCoef[i][j] * inst.LO[i][j];
        }
        // finally do all the dependent variable terms
        int numdepterms=(*currentInductor)->depVarPairs.size();
        for (int j=0 ; j<numdepterms; ++j)
        {
          int coefficientNumber=(*currentInductor)->depVarPairs[j].first;
          int depVarNumber=(*currentInductor)->depVarPairs[j].second;
          int otherInductor;

          // indexPairs[coefficient] gives the two inductors coupled by that
          // coefficient.  One of them is currentInductor because we saved that
          // coefficient number in our depVarPairs, so the other is the one
          // we need to know

          if (i==inst.indexPairs[coefficientNumber].first)
            otherInductor=inst.indexPairs[coefficientNumber].second;
          else
            otherInductor=inst.indexPairs[coefficientNumber].second;

          dQdx[((*currentInductor)->li_Branch)][(*currentInductor)->ABraEquDepVarOffsets[j]] +=
            inst.couplingCoefficientVarDerivs[coefficientNumber][depVarNumber]
            *inst.LO[i][otherInductor]*inst.inductorCurrents[otherInductor];
        }

        ++i;
        ++currentInductor;
      }
    }
  }
  return true;
}
#endif

} // namespace MutIndLin
} // namespace Device
} // namespace Xyce
